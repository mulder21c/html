<section>
<!-- Infrastructure - ASCII Art roolz
████ ██    ██ ████████ ████████     ███     ██████  ████████ ████████  ██     ██  ██████  ████████ ██     ██ ████████  ████████
 ██  ███   ██ ██       ██     ██   ██ ██   ██    ██    ██    ██     ██ ██     ██ ██    ██    ██    ██     ██ ██     ██ ██
 ██  ████  ██ ██       ██     ██  ██   ██  ██          ██    ██     ██ ██     ██ ██          ██    ██     ██ ██     ██ ██
 ██  ██ ██ ██ ██████   ████████  ██     ██  ██████     ██    ████████  ██     ██ ██          ██    ██     ██ ████████  ██████
 ██  ██  ████ ██       ██   ██   █████████       ██    ██    ██   ██   ██     ██ ██          ██    ██     ██ ██   ██   ██
 ██  ██   ███ ██       ██    ██  ██     ██ ██    ██    ██    ██    ██  ██     ██ ██    ██    ██    ██     ██ ██    ██  ██
████ ██    ██ ██       ██     ██ ██     ██  ██████     ██    ██     ██  ███████   ██████     ██     ███████  ██     ██ ████████
-->

<h2 id="infrastructure">공통 인프라</h2>

  <h3 id="infrastructure-terminology">전문 용어</h3>

  이 명세는 종종 동일한 상황에서 HTML과 XML 속성(attribute)와 IDL 속성(attribute) 양쪽 모두를 
  지칭합니다. 어떤 것을 지칭하고 있는지 분명하지 않을 경우, 그것들은 HTML과 XML 속성(attribute)에 
  대해서는 <a lt="content attributes">콘텐트 속성(attribute)</a>으로, IDL 인터페이스에서 명시된 것에 
  대해서는 <dfn lt="IDL attribute|IDL attributes">IDL 속성(attribute)</dfn>으로 지칭합니다. 유사하게, 
  "속성(property)"이라는 용어는 자바스크립트 객체 속성(property)와 CSS 속성(property) 모두에 대해 
  사용됩니다. 이것들이 모호한 경우 각각 <dfn lt="object property|object properties">객체 
  속성(property)</dfn>과 <dfn lt="CSS property|CSS properties">CSS 속성(property)</dfn>으로서 자격이 
  주어집니다 .

  일반적으로, 명세가 기능이 <a href="#syntax">HTML 구문</a> 혹은 <a href="#xhtml">XHTML 구문</a>에 
  적용된다고 서술하는 경우, 둘 다 포함하는 것입니다. 기능이 명확하게 두 언어 중 하나에만 적용하는  
  경우 "HTML에 대해, ... (이것은 XHTML에 적용하지 않습니다)" 처럼, 다른 형식에 적용하지 않는다고  
  명시적으로 서술하여 불립니다.

  이 명세는 짧은 정적 문서로부터 긴 에세이나 리치 멀티미디어가 있는 리포트, 뿐만아니라 훌륭한 
  인터랙티브 어플리케이션에 이르기까지 모든 HTML의 사용에 지칭하는데  
  <dfn lt="document|documents">document</dfn>이라는 용어를 사용합니다. 이 용어는 {{Document}} 객체와   
  그 객체의 후손 DOM 트리 둘 모두를 지칭하는데, 그리고 상황에 따라 
  <a href="#syntax">HTML 구문</a>이나 <a href="#xhtml">XHTML 구문</a>을 사용하여 직렬화된 바이트 
  스트림을 지칭하는데 사용됩니다.

  DOM 구조의 경우, <dfn lt="HTML document">HTML 문서</dfn>와 <a lt="XML document">XML 문서</a>라는 
  용어는 DOM 명세에서 정의된 대로 사용되고, {{Document}} 객체가 찾아질 수 있는 두 다른 모드를 
  명확하게 지칭합니다. [[!DOM]] (그런 사용법은 항상 그들의 정의에 하이퍼링크 되어 있습니다.)

  바이트 스트림의 경우, <a lt="HTML document">HTML 문서</a>라는 용어는 
  <a href="#text-html"><code>text/html</code></a>로 라벨링 된 리소스를 지칭하고, 
  <dfn lt="XML document">XML 문서</dfn>라는 용어는 <a lt="XML MIME type">XML MIME 타입</a>으로 
  라벨링 된 리소스를 지칭합니다.

  <dfn lt="XHTML document|XHTML documents">XHTML 문서</dfn>라는 용어는 상황에 따라, 
  <a lt="HTML namespace">HTML 네임스페이스</a> 내 요소(element) 노드를 포함하는 
  <a lt="XML document">XML 문서</a> 모드인 <a lt="documents">문서</a>와 <a lt="HTML namespace">HTML 
  네임스페이스</a>의 요소를 포함하는 <a lt="XML MIME type">XML MIME 타입</a>으로 라벨링 된 바이트 
  스트림을 지칭하는데 사용됩니다.

  <hr />

  간결성을 위해, <dfn lt="shown">shown</dfn>, <dfn lt="displayed">displayed</dfn>, 
  <dfn lt="visible">visible</dfn>와 같은 용어들은 (종종) 문서가 사용자에게 렌더링되는 방법을 지칭할 
  경우 사용됩니다. 이 용어들은 시각적 매체를 의미하는 것이 아닙니다; 동등한 방법으로 다른 매체에도 
  적용될 수 있도록 고려되어야 합니다.

  알고리즘 B가 다른 알고리즘 A로 돌아간다 말하는 경우, A가 B를 호출했음을 의미합니다. A로 돌아가면,
  구현은 B의 호출에서 멈춘 곳에서부터 계속 진행해야 합니다. 일부 알고리즘은 
  <dfn lt="in parallel">병렬로</dfn> 수행합니다; 이것은 알고리즘의 다음 단계가 명세 내 다른 로직과 
  동시에 (예를 들어, <a lt="event loop">이벤트 루프</a>가 동시에) 잇따라서 수행됨을 의미합니다. 이 
  명세는 다른 하이퍼쓰레드, 코어, CPU, 기계 등을 사용하여 시분할 다중 작업, fibers, 프로세스가 
  달성되는 정밀한 메커니즘을 정의하지 않습니다. 그와 대조적으로, <dfn lt="immediately">즉시</dfn> 
  수행하기 위한 작업은 현재 수행 중인 작업을 중단하고 수행해야 하며, 그후 이전에 수행 작업을 
  재개해야 합니다.

  "투명한 검정"이라는 용어는 빨강, 초록, 파랑, 알파 채널이 모두 0으로 설정된 색상을 지칭합니다.

<h4 id="resources">리소스</h4>

  유저 에이전트가 외부 리소스의 의미를 디코딩할 수 있는 구현을 가지는지를 지칭하는 경우 명세는 
  <dfn lt="supported">지원된다</dfn>라는 용어를 사용합니다. 형식(format)이나 유형(type)은 구현이 
  외부 리소스의 중요한 측면이 무시되지 않고 그 형식(foramt)이나 유형(type)의 리소스를 처리할 수 
  있다면 <i>지원된다</i>고 불립니다. 특정 리소스가 <i>지원되는</i>지 여부는 리소스의 형식이 사용되는 
  기능에 따라 달라질 수 있습니다.

  <p class="example">
    예를 들어, PNG 이미지는 구현에 알려지지 않은 이미지가 애니메이션 데이터를 포함하고 있다 하더라도 
    픽셀 데이터가 디코드되고 렌더링 될 수 있다면 구현 지원되는 형식(format)으로 간주될 것입니다.
  </p>

  <p class="example">
    MPEG-4 비디오 파일은 사용된 압축 형식(format)이 지원되지 않았다면, 구현이 파일의 메타데이터로부터 
    영상의 크기를 결정할 수 있다하더라도 지원되는 형식(format)으로 간주되지 않을 것입니다.
  </p>

  일부 명세가, 특히 HTTP 명세에서, <i>표현(representation)</i>으로 지칭된 것은 이 명세에서 
  <dfn for="http" lt="resource">리소스</dfn>로 지칭됩니다. [[!HTTP]]

  <dfn lt="mime type|mime types">MIME 타입</dfn> 이라는 용어는 프로토콜 문서에서 종종 <i>인터넷 
  미디어 타입</i>으로 불리는 것을 지칭하는데 사용됩니다. 이 명세에서 
  <dfn for="media type|media-type">media 타입</dfn> 이라는 용어는 CSS 명세에 의해 사용된 것 처럼, 
  표현을 위해 의도된 미디어의 유형을 지칭하는데 사용됩니다. [[!RFC2046]] [[!MEDIAQ]]

  문자열이 <a lt="media-type"><code>media-type</code></a> 규칙과 일치한다면 
  <dfn lt="valid MIME type">유효한 MIME 타입</dfn>입니다. 특히 <a lt="valid mime type">유효한 MIME 
  타입</a>은 MIME 타입 파라미터들을 포함할 수 있습니다. [[!HTTP]]

  문자열이 <a lt="media-type"><code>media-type</code></a> 규칙과 일치하지만, 어떤 U+003B 세미콜론 
  문자 (;)도 포함하지 않는다면 <dfn for="mime type" lt="valid MIME type with no parameters|valid MIME types with no parameters">파라미터를 가지지 않는 유효한 MIME 타입</dfn>입니다.
  다시 말해, 그것이 MIME 타입 파라미터 없이 오로지 타입과 서브 타입으로만 구성된다면. [[!HTTP]]

  <dfn lt="HTML MIME type">HTML MIME 타입</dfn> 이라는 용어는 <a lt="MIME type">MIME 타입</a> 
  <a href="#text-html"><code>text/html</code></a>를 지칭하는데 사용됩니다.

  리소스의 <dfn lt="critical subresource|critical subresources">중요한 하위 리소스</dfn>들은 완전히 
  처리되기 위해 사용 가능(available)해야 하는 것이 필요한 리소스 입니다. 어떤 자원이 중요한 것으로 
  간주되거나 그렇지 않은 지는 리소스의 형식(format)을 정의하는 명세에 의해 정의되어 있습니다. 

  <a scheme lt="data:"><code>data:</code> URL</a>이라는 용어는 <a scheme lt="data:"><code>data:</code></a> 
  스킴을  <a for="url">URLs</a> 사용하는 <a for="url">URL</a>들을 지칭합니다. [[!RFC2397]]

<h4 id="xml">XML</h4>

  HTML에서 XHTML로 쉽게 마이그레이션 하기 위해, 이 명세를 따르는 유저 에이전트는 적어도 DOM과 CSS의 
  용도를 위해 <code>https://www.w3.org/1999/xhtml</code> 네임스페이스의 HTML에 요소(element)들을 
  위치시킬 것입니다. "<dfn lt="html element|html elements">HTML 요소</dfn>"라는 용어는 이 명세에서 
  사용될 경우, 그 네임스페이스의 요소를 지칭하고, 따라서 HTML과 XHTML 요소들 모두를 지칭합니다.

  달리 명시된 것을 제외하고, 이 명세에 정의되거나 언급된 모든 요소(element)들은 
  <a lt="HTML namespace">HTML 네임스페이스</a> ("<code>https://www.w3.org/1999/xhtml</code>")에 있고, 
  이 명세에 정의되거나 언급된 모든 속성(attribute)들은 네임스페이스를 가지지 않습니다.

  <dfn lt="element type">요소(element) 유형</dfn>은 주어진 로컬 이름과 네임스페이스를 가진 요소들의 
  세트를 지칭하는데 사용됩니다. 예를 들어, <{button}> 요소(element)는 로컬 이름 "<{button}>"과 (위에 
  정의된 대로 암묵적으로) <a lt="HTML namespace">HTML 네임스페이스</a>를 가지는 것을 의미하는, 요소 
  유형을 가진 요소(element)입니다. 

  속성(attirbute) 이름은 XML에 정의된 <a for="XML" lt="Name"><code>Name</code></a> 생성과 일치하고 
  U+003A 콜론 문자(:)를 포함하지 않는다면 <dfn for="xml-compatible" lt="xml-compatible">XML 호환 
  가능</dfn>하다 불립니다. [[!XML]]

  <dfn lt="XML MIME type">XML MIME 타입</dfn>이라는 용어는 <a lt="MIME types">MIME 타입</a> 
  <code>text/xml</code>, <code>application/xml</code>, 서브 타입이 4개 문자 "<code>+xml</code>"로 
  끝나는 <a lt="MIME type">MIME 타입</a>을 지칭하는데 사용됩니다. [[!RFC7303]]

<h4 id="dom-trees">DOM 트리</h4>

  <dfn for="document" lt="root element of a document object">{{Document}} 객체의 루트 
  요소(element)</dfn>는 그 {{Document}}의 첫 번째 자식이 있다면 그것입니다. 첫 번째 자식이 없다면 
  {{Document}}는 루트 요소(element)가 없습니다.

  <dfn lt="root element|root elements">루트 요소(element)</dfn>라는 용어는, {{Document}} 객체의 루트 
  요소(element)를 지칭하지 않는 경우, 검토되는 노드의 가장 먼 조상 요소(element) 노드나 조상 노드가 
  없다면 자기 자신을 의미합니다.노드가 문서의 일부인 경우, 노드의 
  <a lt="root element">요소(element)</a>는 확실히 문서의 루트 요소(element)입니다; 하지만, 노드가 
  현재 문서 트리의 일부가 아니라면, 루트 요소(element)는 부모가 없는 노드일 것입니다.

  요소(element)의 <a lt="root element">루트 요소(element)</a>가 
  <a lt="root element of a document object"><code>Document</code> 객체의 루트 요소(element)</a>인 
  경우, 이 요소(element)는 <dfn lt="in the document|in a document">{{Document}} 안에</dfn> 있다고 
  불립니다. 요소(element)는 그것의 <a lt="root element">루트 요소(element)</a>가 변경되고 그 
  요소(element)가 이제 문서의 <a lt="root element">루트 요소(element)</a>인 경우, 
  <dfn for="document" lt="inserted into the document|inserted into a document|inserted into">문서에 
  삽입</dfn> 되었다고 불립니다. 비슷하게, 요소(element)는 그것의 <a lt="root element">루트 
  요소(element)</a>가 문서의  <a lt="root element">루트 요소(element)</a>에서 다른 요소(element)로 
  변경되는 경우 <dfn for="document" lt="removed from a document|removed from">문서에서 제거</dfn> 
  되었다고 불립니다.

  노드의 <dfn lt="home subtree|home subtrees">홈 서브트리</dfn>가 그 노드의 
  <a lt="root element">루트 요소(element)</a>에 루트를 둔 서브트리입니다. 노드가 
  <a lt="in a Document"><code>Document</code>안에</a> 있는 경우, 그것의 <a lt="home subtree">홈 
  서브트리</a>는 그 {{Document}}의 트리입니다.

  {{Node}}(요소(element) 같은)의 {{Document}}는 {{Node}}의 {{Node/ownerDocument}} IDL 
  속성(attribute)이 반환하는 {{Document}} 입니다. {{Node}}가 
  <a lt="in a Document"><code>Document</code> 안에</a> 있는 경우 그 {{Document}}는 항상 {{Node}}의 
  {{Document}}이고, {{Node}}의 {{Node/ownerDocument}} IDL 속성(attribute)은 따라서 
  항상 {{Document}}를 반환합니다.

  콘텐트 속성(attribute)의 {{Document}}는 속성(attirbute)의 요소(element)의 {{Document}}입니다.

  <dfn lt="tree order">트리 순서</dfn>라는 용어는 ({{Node/parentNode}}/{{Node/childNodes}} 관계를 
  통해) 수반된 DOM 노드의 전위 순회, 깊이 우선 탐색을 의미합니다.

  어떤 요소(element)나 속성(attribute)이 <dfn lt="ignored">무시</dfn>되거나, 어떤 다른 값으로 
  취급되거나, 마치 또 다른 것처럼 처리되는 것으로 명시되는 경우, 이것은 노드가 DOM 안에 위치된 이후 
  처리되는 것을 지칭합니다.

  콘텐트 속성(attribute)는 그것의 새로운 값이 이전 값과 다를 경우에 한해 값을 
  <dfn lt="change">바꾼다</dfn>라고 불립니다; 이미 가지고 있던 값으로 속성을 설정하는 것은 바꾸는 
  것이 아닙니다.

  {{Text}} 노드, 문자열 속성 값이 <dfn lt="empty">비어있음</dfn>으로 기술되는 경우, 그것은 텍스트의 
  길이가 0임을 의미합니다. (즉, 공백이나 <a lt="control characters">제어 문자</a>조차도 아닙니다).

  요소(element)의 <dfn lt="child text content">자식 텍스트 콘텐트</dfn>는 <a lt="tree order">tree 
  order</a>에서 요소(element)의 자식(주석이나 요소(element)같은 다른 노드는 제외하고)인 모든 
  {{Text}} 노드의 <a lt="data">data</a>의 연결입니다.

  <a lt="insertion steps">삽입 단계</a>가 인자로 <var>A</var>를 가지고 작동되고 
  <var>A</var>의 새로운 부모가 <var>B</var>인 경우 노드 <var>B</var>에 
  <a for="Node" lt="insert">노드 <var>A</var>가 삽입</a>됩니다. 비슷하게, <var>removedNode</var> 
  인자로 <var>A</var>와 <var>oldParent</var> 인자로 <var>B</var>를 가지고 
  <a lt="removing steps">제거 단계</a>가 작동되는 경우 노드 <var>B</var>로부터 
  <dfn for="Node" lt="node A is removed">노드 <var>A</var>가 제거</dfn> 됩니다.

<h4 id="scripting">스크립팅</h4>

  <code>Foo</code>가 실제로 인터페이스인 경우, 구조 "<code>Foo</code> 객체"는 때때로 좀 더 정확한
  "<code>Foo</code> 인터페이스를 구현하는 객체" 대신 사용됩니다.

  IDL 속성(attribute)는 그것의 값이 검색 되는(예를 들어, 작성자 스크립트에 의해) 경우 
  <dfn for="values" lt="getting">가져온다</dfn>라고 불리고 새로운 값이 할당되는 경우 
  <dfn for="values" lt="setting">설정한다</dfn>라고 불립니다.

  DOM 객체가 <dfn lt="live">존속된다</dfn>라고 불리는 경우, 그 객체의 속성(attribute)과 메서드(method)는 
  데이터의 스냅샷이 아닌, 실제 내부 데이터로 운용되어야 합니다.

  이벤트의 측면에서, <i>발생</i>과 <i>발송</i>이라는 용어는 DOM 명세에서 정의된 대로 사용됩니다:
  이벤트가 <dfn lt="fire|firing|fired|fires|fire a simple event|fires a simple event">발생</dfn>한다는 
  것은 생성하고 <a lt="dispatch">발송</a> 한다는 것을 의미하고, 
  이벤트를 <dfn lt="dispatch|dispatching|dispatched|dom event dispatch logic|event dispatching">발송</dfn>한다는
  것은 트리를 통해 이벤트를 전파하는 단계를 따른다는 것을 의미합니다. 
  <dfn lt="trusted|trusted event">신뢰할 수 있는 이벤트</dfn>는 {{Event/isTrusted}} 속성(attribute)가 
  true로 초기화 된 이벤트를 지칭하는데 사용됩니다. [[!DOM]]

<h4 id="plugin-content-handlers"><code>Plugin</code> 콘텐트 처리기</h4>

  <dfn lt="plugin|plugins">plugin</dfn>이라는 용어는 유저 에이전트에 의해 사용될 수 있는 콘텐츠 
  처리기의 유저 에이전트 정의 세트를 지칭합니다. 콘텐트 처리기는 유저 에이전트의 {{Document}} 객체의 
  렌더링에 참여할 수 있지만, {{Document}}의 <a lt="child browsing contexts">자식 브라우징 컨텍스트</a>로
  행동하거나 {{Document}}의 DOM에 임의의 {{Node}} 객체를 도입하지 않습니다.

  일반적으로 그러한 콘텐트 처리기들은 서드 파티로 제공되기는 하지만, 유저 에이전트는 내장 콘텐트
  처리기도 <a lt="plugins">플러그인</a>으로 지정할 수 있습니다.

  유저 에이전트는 <code>text/plain</code>과 <code>application/octet-stream</code> 유형을 등록된 
  <a lt="plugin">플러그인</a>을 가지는 것으로 간주해서는 안됩니다.

  <p class="example">
    플러그인의 한 가지 예는 사용자가 PDF 파일을 탐색할 때 <a lt="browsing context">브라우징 
    컨텍스트</a>에 인스턴스화 된 PDF 뷰어일 것입니다. 이것은 PDF 뷰어 컴포넌트를 구현한 단체가 유저 
    에이전트를 구현한 단체와 동일한지 여부와 상관 없이 플러그인으로 인정할 것입니다. 하지만, 유저 
    에이전트와 분리되어 시작하는 (동일한 인터페이스를 사용하는 것이 아닌) PDF뷰어 어플리케이션은 
    이 정의에 의해 플러그인이 아닙니다.
  </p>

  <p class="note">
    이 명세는 <a lt="plugins">플러그인</a>이 유저 에이전트와 플랫폼 종속인 것으로 예상되기 때문에 
    <a lt="plugins">플러그인</a>과 상호작용에 대한 메커니즘을 정의하지 않습니다. 일부 유저 에이전트는
    넷스케이프 플러그인 API와 같은 플러그인 메커니즘을 지원하는 것을 선택할 수 있습니다; 또 어떤 것들은
    원격 콘텐트 변환기를 사용하거나 특정 유형에 대한 내장 지원을 가질 수도 있습니다. 실제로, 이 명세는
    <a lt="plugins">플러그인</a>을 지원하는 유저 에이전트가 전혀 필요하지 않습니다. [[NPAPI]]
  </p>

  플러그인은 <{iframe/sandbox}> 속성(attribute)의 의미를 만족하면 <dfn lt="secured">보호</dfn> 될 수
  있습니다.

  <p class="example">
    예를 들어, 보호된 플러그인은 플러그인이 샌드박스 된 <{iframe}> 안에서 인스턴스화 된 경우 콘텐트가 
    팝업 윈도우를 생성하는 것을 차단할 것입니다.
  </p>

  <p class="warning">
    브라우저는 <a lt="plugins">플러그인</a>을 위해 의도된 외부 콘텐트와 상호작용을 할 경우 극도의 
    주의를 기울여야(should) 합니다. 서드 파티 소프트웨어가 유저 에이전트처럼 동일한 특권을 가지고 
    수행되는 경우, 서드 파티 소프트웨어의 취약성은 유저 에이전트의 취약성이 있는 것만큼 위험하게 
    됩니다.
  </p>

  다른 <a lt="plugins">plugins</a> 세트를 가지는 다른 사용자는 사용자를 유일하게 식별되게 하는 기회를 
  증가시키는 지문 그림을 제공하기 때문에, 유저 에이전트는 각 사용자에 대해 정확히 동일한 
  <a lt="plugins">플러그인</a> 세트를 지원하도록 권장 됩니다.
  <a class="fingerprint" href="#fingerprinting-vector"><img height="21" src="images/fingerprint.png" width="15" alt="(이것은 지문 그림입니다.)" /></a>

<h4 id="encoding-terminology">문자 인코딩</h4>

  <dfn lt="character encoding">문자 인코딩</dfn>, 혹은 애매모호하지 않은 <i>인코딩</i>은 WHATWG 
  인코딩 표준에 정의된 대로, 바이트 스트림과 유니코드 문자열 사이를 전환하기 위한 정의된 방법입니다.
  <a lt="encoding">인코딩</a>은, 인코딩 표준에 인코딩의 <i>이름</i>과 <i>라벨</i>로 지칭된, 
  <dfn lt="encoding name">인코딩 이름</dfn>이나 하나 이상의 
  <dfn lt="encoding labels">인코딩 라벨</dfn>을 가집니다. [[!ENCODING]]

  <dfn lt="UTF-16 encoding">UTF-16 인코딩</dfn>은 <a lt="UTF-16BE">UTF-16BE</a>나 <a lt="UTF-16LE">UTF-16LE</a>입니다. [[!ENCODING]]

  <dfn lt="ASCII-compatible encoding">ASCII 호환 인코딩</dfn>은 <a lt="UTF-16 encoding">UTF-16 인코딩</a>이 
  아닌 모든 <a lt="encoding">인코딩</a>입니다. [[!ENCODING]]

  <p class="note">
    WHATWG 인코딩 표준에 정의되지 않은 인코딩에 대한 지원은 금지되어 있기 때문에, 
    <a lt="UTF-16 encodings">UTF-16 인코딩</a>은 이 명세가 <a lt="ASCII-compatible encoding">ASCII 
    호환 인코딩</a>이 되지 않는 것으로 처리할 필요가 있는 유일한 인코딩입니다.
  </p>

  <dfn lt="code unit|code units">코드 단위</dfn>이라는 용어는웹 IDL 명세에 정의된 대로 사용됩니다: <code>DOMString</code>의 
  가장 작은 최소 구성 요소인 16비트 무부호 정수입니다. (이것은 유니코드에 사용된 것 보다 좁은 정의이고
  <i>code point</i>와 동일하지 않습니다.) [[!WEBIDL]]

  <dfn lt="Unicode code point">유니코드 코드 포인트</dfn>라는 용어는 그것이 가능한 경우 <i>유니코드 스칼라 값</i>을 의미하고,
  불가능한 경우 독자적인 대용 코드 포인트(isolated surrogate code point)를 의미합니다. 적합성
  요구사항이 이 문자나 유니코드 코드 포인트 용어로 정의되는 경우, 낮은 대용 코드가 뒤따르는 높은 대용 
  코드로 구성되는 한 쌍의 <a lt="code units">코드 단위</a>는 대용 코드쌍으로 나타나는 단일 코드 
  포인트로 취급되어야 하지만, 독자적인 대용 코드는 각각 대용 코드의 값을 가지고 단일 코드로 취급
  되어야 합니다. [[!UNICODE]]

  이 명세에서, <dfn lt="character|characters">문자</dfn>라는 용어는, <em>유니코드</em> 문자로서 자격이 없는 경우, 
  <a lt="Unicode code point">유니코드 코드 포인트</a> 용어와 같은 것을 의미합니다.

  <dfn lt="Unicode character|Unicode characters">유니코드 문자</dfn>는 <i>유니코드 스칼라 값</i>을 
  의미하는데 사용됩니다.(즉, 독자적인 코드 포인트가 아닌 모든 유니코드 코드 포인트) [[!UNICODE]]

  문자열의 <dfn lt="code-unit length">코드 단위 길이</dfn>는 그 문자열의 <a lt="code units">코드 
  단위</a>들의 갯수입니다.

  <p class="note">
    이 복잡성은 <a lt="Unicode characters">유니코드 문자</a>의 용어에서 보다 16비트(UTF-8) 
    <a lt="code units">코드 단위</a>(UTF-16)의 용어에서 DOM API를 정의하기 위한 역사적인 결정이 
    원인입니다. 
  </p>

<h3 id="conformance-requirements">적합성 요구사항</h3>

  이 명세의 모든 다이어그램, 예제, 주석은 모든 섹션에 비범적이라고 명시적으로 표시된 것 처럼 
  비규범적입니다. 이 명세에서 다른 모든 것들은 규범적입니다.

  이 문서의 규범적 부분에 있는 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", 
  "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", "OPTIONAL" 키워드들은 RFC2119에 설명된 대로
  해석되어야 합니다. 이 문서의 규범적인 부분에 있는 "OPTIONALLY" 키워드는 "MAY"와 "OPTIONAL"처럼 
  동일한 규범적 의미로 해석되어야 합니다. 가독성을 위해, 이 단어들은 이 명세에서 모두 대문자 글자로
  나타내지는 않습니다. [[!RFC2119]]
  
  <p class="translator-note">
    본 번역본에서는 가급적 위 표기들을 한글과 함께 영문을 괄호 안에 표기하려 하고 있으나, 깜박하고
    놓치고 지나갈 수 있기 때문에 가급적 위 키워드와 관련된 한글 표현에 대해서는 영문으로 된 원문과
    비교하여 보시기를 권합니다.
  </p>

  알고리즘의 일부분으로 명령조로 표현된 요구사항들은("선두의 모든 공백 문자를 제거"나 "false를 
  반환하고 이 단계들을 중단" 같은) 알고리즘 도입에 사용되는 키워드("must", "should", "may", 등등)의 
  의미로 해석되어야 합니다.

  <div class="example">
    예를 들어, 다음과 같은 명세가 있었다면:

    <pre>
      To eat an orange, the user must:
      1. Peel the orange.
      2. Separate each slice of the orange.
      3. Eat the orange slices.
    </pre>

    ...이것은 다음과 동등할 것입니다:

    <pre>
      To eat an orange:
      1. The user must peel the orange.
      2. The user must separate each slice of the orange.
      3. The user must eat the orange slices.
    </pre>

    여기서 키워드는 "must"입니다.

    전자의(명령조) 방식은 일반적으로 문제상의 이유로 이 명세에서 선호됩니다.
  </div>

  알고리즘이나 구체적인 단계들로 표현된 적합성 요구사항은 최종 결과가 동등한 것이기만 하면 임의의 
  방법으로 구현될 수 있습니다. (특히, 이 명세에 정의된 알고리즘은 쉽게 따라할 수 있도록 의도된 것이고,
  고성능이 되도록 의도된 것이 아닙니다.)

<h4 id="conformance-classes">적합성 종류</h4>

  이 명세는 유저 에이전트(구현자에 관련된)와 문서(작성자와 작성 도구 구현자에 관련된) 대한 적합성 
  기준을 설명합니다.

  <dfn lt="conforming document|conforming documents">적합한 문서</dfn>는 문서에 대한 모든 적합성 
  기준을 따르는 문서입니다. 가독성을 위해, 이 적합성 요구사항의 일부는 작성자에 대한 적합성 
  요구사항으로 표현됩니다; 그 요구사항들은 암묵적으로 문서에 대한 요구사항입니다: 정의에 의해, 모든
  문서들은 작성자가 있었다고 가정됩니다. (어떤 경우, 그 작성자는 유저 에이전트 자체가 될 수 있습니다.
  &mdash; 그러한 유저 에이전트는 아래 설명된 대로, 추가적인 규칙의 적용을 받습니다.)

  <p class="example">
    예를 들어, 요구사항이 "작성자는 <code>foobar</code> 요소(element)를 사용하지 않아야(must not) 
    합니다" 라고 명시한다면, 이는 문서가 <code>foobar</code>라고 명명된 요소(element)를 포함하는 
    것을 허용하지 않는다는 것을 암시합니다.
  </p>

  <p class="note impl">
    문서 적합성 요구사항과 구현 적합성 요구사항 사이의 암묵적인 관계는 없습니다. 유저 에이전트는 
    원하는 대로 부적합한 문서를 처리하는데 자유롭지 않습니다; 이 명세에 설명된 처리 모델은 입력 
    문서의 적합성에 상관없이 구현에 적용됩니다.
  </p>

  유저 에이전트는 서로 다른 적합성 요구사항을 가진 몇 가지 범주에 (중복하여) 속합니다. 

  : 웹 브라우저와 다른 인터랙티브 유저 에이전트
  :: <a href="#xhtml">XHTML 구문</a>을 지원하는 웹 브라우저는 이 명세에 설명된 대로 XML 문서에서 
      찾아지는 <a lt="HTML namespace">HTML 네임스페이스</a>의 요소(element)와 속성(attribute)을 처리 
      해야(must)하기 때문에, 그 요소의 의미가 다른 명세에 의해 재정의되지 않는 한 사용자는 그것들을 
      가지고 상호작용 할 수 있습니다.

      <p class="example">
        적합한 HTML 처리기는, XHTML 문서에서 XHTML <{script}> 요소(element)를 찾자마자, 그 요소에  
        포함된 스크립트를 실행합니다. 하지만, 요소가 XSLT에서 표현된 변형 내에서 찾아진다면 (유저 
        에이전트가 XSLT도 지원한다고 가정하여), 처리기는 대신 변형의 일부를 형성하는 불분명한
        요소(element)로서 <{script}> 요소(element)를 대신 다룰 것입니다.
      </p>

      <a href="#syntax">HTML 구문</a>을 지원하는 웹 브라우저는 이 명세에 설명된 대로 
      <a lt="HTML MIME type">HTML MIME 타입</a>으로 라벨링 된 문서를 처리해야(must) 하기 때문에, 
      사용자는 그 문서와 상호작용 할 수 있습니다.

      스크립팅을 지원하는 유저 에이전트는 또한 웹 IDL 명세에 정의된 대로, 이 명세의 IDL 코드 조각의 
      구현이 준수되어야(must) 합니다. [[!WEBIDL]]

      <p class="note">
        명시적으로 명시되지 않은 한, HTML 요소(element)의 의미를 재정의 하는 명세는 그 요소(element)를
        나타내는 DOM 객체에서의 요구사항을 재정의 하지 않습니다. 예를 들어, 위 예제에서  <{script}> 
        요소(element)는 여전히 {{HTMLScriptElement}} 인터페이스를 구현합니다.
      </p>

  : 비상호작용 프리젠테이션 유저 에이전트
  :: 순수하게 HTML과 XHTML 문서의 비상호작용 버전을 렌더링하기 위해 문서를 처리하는 유저 에이전트는,
      사용자 인터랙션에 관하여 요구사항이 면제되는 것을 제외하고, 웹 브라우저 같이 동일한 적합성 
      기준을 따라야(must) 합니다. 

      <p class="note">
        비상호작용 유저 에이전트의 전형적인 예는 프린터(정적 유저 에이전트)와 오버헤드 디스플레이(동적
        유저 에이전트)입니다. 대부분의 정적 비상호작용 프리젠테이션 유저 에이전트도 
        <a lt="lack scripting support">스크립팅 지원을 필요로</a> 하기로 선택할 것이 예상됩니다. 
      </p>

      <p class="example">
        비상호작용이지만 동적 프리젠테이션 유저 에이전트는, 동적으로 전송되는 양식을 허용 하는등으로, 
        여전히 스크립트를 실행합니다. 그러나, 사용자가 문서와 상호작용 할 수 없는 경우 "focus"의 
        개념이 상관없기 때문에, 유저 에이전트는 포커스 관련 DOM API를 지원할 필요가 없습니다.
      </p>

  : <dfn for="rendering" lt="support the suggested default rendering|supporting the suggested default rendering|Visual user agents that support the suggested default rendering">제안된 기본 렌더링을 지원하는 시각적 유저 에이전트</dfn>
  :: 유저 에이전트는, 상호작용이든 아니든, 이 명세에 정의된  
      <a lt="supporting the suggested default rendering">제안된 기본 렌더링을 지원하는 것</a>으로 
      (아마도 사용자 옵션으로) 지정됩니다.

      이것은 필요하지 않습니다. 특히, 제안된 기본 렌더링을 구현하는 유저 에이전트도 사용자에 대한 
      경험을 개선하기 위해, 예를 들어 색상 대비를 바꾸거나, 다른 포커스 스타일을 사용하거나, 그렇지 
      않으면 사용자에게 더 접근 가능하고 사용 가능한 경험을 만들기 위해, 이 기본 값을 재정의 하는 
      설정을 제공하도록 권장됩니다.

      <a lt="supporting the suggested default rendering">제안된 기본 렌더링을 지원하는 것</a>으로 
      지정된 유저 에이전트는, 그렇게 지정된 동안, [[#rendering]] 섹션 내 규칙을 구현해야(must) 합니다. 
      그 섹션은 유저에이전트가 구현할 것으로 <em>기대되는</em> 행동을 정의합니다.

  : <dfn lt="lack scripting support|User agents with no scripting support|do not support scripting">스크립트를 지원하지 않는 유저 에이전트</dfn>
  :: 스크립팅을 지원하지 않는(혹은 스크립트 기능이 완전히 비활성화 된) 구현은 이벤트와 이 명세에서 
      언급된 DOM 인터페이스 지원이 면제됩니다. 이벤트 모델의 측면이나 DOM의 측면에서 정의된 이 명세의 
      일부에 대해, 그런 유저 에이전트는 여전히 이벤트와 DOM이 지원된 것처럼 수행해야 합니다.

        <p class="note">
          스크립팅은 어플리케이션의 필수적인 부분을 형성할 수 있습니다. 스크립팅을 지원하지 않거나 
          스크립트가 비활성화 된 웹 브라우저는 작성작의 의도를 완전히 전달 할 수 없을 수도 있습니다.
        </p>

  : 적합성 검사기
  :: 적합성 검사기는 이 명세에 정의된 적절한 적합성 기준을 따르는 문서를 검증해야(must) 합니다. 
      자동화 된 적합성 검사기는 작성자 의도의 해석을 요구하는 오류를 발견하는 것은 적용되지 않습니다. 
      (예를 들어, <{blockquote}> 요소(element)의 콘텐트가 따옴표로 묶여있지 않다면 문서는 비적합 
      함에도 불구하고, 사람의 판단의 입력 없이 수행하는 적합성 검사기는 <{blockquote}> 
      요소(element)가 인용된 문장만을 포함함을 검사할 필요가 없습니다.)

      적합성 검사기는 입력 문서가 <a lt="browsing context">브라우징 컨텍스트</a> 없이 해석되는 경우
      (스크립가 수행되지 않고, 해석기의 <a lt="scripting flag">scripting 플래그</a>가 비활성화 된 
      것을 의미) 적합한지 검사해야(must) 하고, 또한 입력 문서가 스크립트를 수행하는 
      <a lt="browsing context">브라우징 컨텍스트</a>를 가지고 해석되는 경우 적합한지, 그리고 
      스크립트는 스크립트가 자신을 수행하는 동안 비적합 상태가 다른 것을 발생시키는 것을 야기하지 
      않음을 검사해야(should) 합니다. (이것은 불가능한 것으로 증명되었기 때문에 "SHOULD"일 뿐 
      "MUST" 요구사항이 아닙니다. [[COMPUTABLE]])

      "HTML 유효성 검사기"라는 용어는 이 명세의 적절한 요구사항을 준수하는 적합성 검사기를 지칭하는데 
      사용될 수 있습니다.

      <div class="note">
        XML DTD는 이 명세의 모든 적합성 요구사항들을 나타낼 수 없습니다. 그러므로, 검증 XML 처리기와
        DTD는 적합성 검사기가 될 수 없습니다. 또한, 이 명세에 정의된 두 가지 작성 형식(format) 어느 
        것도 SGML 어플리케이션이 아니기 때문에 검증 SGML 시스템 역시 적합성 검사기가 될 수 없습니다.

        바꿔 말하면, 3가지 유형의 적합성 기준이 있습니다:

        1. DTD에 표현될 수 있는 기준.
        2. DTD에 표현될 수 없지만, 여전히 기계(machine)에 의해 검사 될 수 있는 기준.
        3. 사람에 의해서만 검사 될 수 있는 기준.

        적합성 검사기는 처음 두 가지에 대해 검사해야(must) 합니다. 간단한 DTD 기반 유효성 검사기는 
        첫 번째 등급의 오류에 대해서만 검사하고 그렇기 때문에 이 명세를 따르는 적합한 적합성 검사기가 
        아닙니다.
      </div>

  : 데이터 마이닝 도구
  :: 문서를 렌더링 하거나 적합성에 대해 검사를 하는 것 외에 다른 이유로 HTML과 XHTML 문서를 처리하는 
      어플리케이션과 도구들은 그들이 처리하는 문서의 의미에 부합하게 수행해야(should) 합니다.

      <p class="example">
        <a lt="outline">문서 아웃라인</a>을 생성하지만 각 문단에 대한 중첩 레벨을 증가시키고 각 
        섹션에 대한 중첩 레벨을 증가시키지 않는 도구는 부적합 할 것입니다.
      </p>

  : 작성 도구와 마크업 생성기
  :: 작성 도구와 마크업 생성기는 <a lt="conforming document">적합한 문서</a>를 생성해야(must) 합니다.
      작성자에게 적용되는 적합성 기준은 또한 작성 도구에 적용합니다.

      작성 도구는 오직 작성 도구가 아직 작성자 의도를 결정할 수 없는 정도에만, 명시된 목적에 대한 
      요소(element) 사용의 요구사항이 적용되지 않습니다. 하지만, 저작 도구는 자동으로 요소(element)를 
      오용하거나 사용자가 그렇게 하는 것을 권장해서는(must) 안됩니다.

      <p class="example">
        예를 들어, 임의의 연락 정보를 위해 <{address}> 요소(element)를 사용하는 것은 비적합합니다;
        그 요소(element)는 문서나 섹션의 작성자에 대한 연락 정보를 마크업 하는 용도로만 사용 
        가능합니다. 하지만, 작성 도구는 차이를 결정하는 것이 불가능 할 것이기 때문에, 작성 도구는 
        그 요구사항이 적용 되지 않습니다. 그러나 이것은 작성 도구가 임의의 이탤릭체 본문(예를 들어)을 
        위해 <{address}> 요소(element)를 사용할 수 있다는 것을 의미하지 않습니다; 사용자가 섹션이나
        다른 무언가에 대한 연락 정보를 삽입한다면, 그것은 단지 작성 도구가 검증할 필요가 없다는 것을 
        의미합니다.
      </p>

      <p class="note">
        적합성 검사의 측면에서, 편집기는 접근성 검사기가 검증하는 동일한 범위를 준수하는 문서를 
        출력해야 합니다.
      </p>

      작성 도구가 비적합한 문서를 편집하는데 사용되는 경우, 편집 세션 동안 편집되지 않은 문서의 섹션 
      내의 적합성 오류를 보존할 수 있습니다.(즉, 편집 도구는 잘못된 콘텐트 왕복을 허용합니다.) 그러나,
      저작 도구는 오류가 그렇게 보존된다면 출력이 준수하다고 주장해서는(must) 안됩니다.

      저작 도구는 두 개의 광범위한 종류로 제공 될 것으로 예상됩니다: 구조적 혹은 의미론적 데이터에서 
      동작하는 도구와, What-You-See-Is-What-You-Get 매체 특정 편집 기준에서 동작하는 도구(WYSIWYG)
      입니다.

      소스 정보의 구조는 어떤 HTML 요소(element)와 속성(attribute)가 가장 적절한지에 관하여 선택을 
      하는데 사용될 수 있기 때문에, 전자는 HTML을 작성하는 도구에 대한 선호된 메커니즘입니다.

      하지만, WYSIWYG 도구는 타당합니다. WYSIWYG 도구는 그것이 적절하다고 알고 있는 요소(element)들을 
      사용해야(should) 하고, 그것이 적절하다고 알지 못하는 요소(element)들을 사용해서는(should) 안됩니다.
      이것은 어떤 극단적인 경우에 플로우 요소(flow element)의 사용을 <{div}>, <{b}>, <{i}>, <{span}>과 
      같은 단지 몇 가지 요소(element)로 제한하는 것과 <{global/style}>를 자유롭게 사용하는 것을 
      의미할 수 있습니다.

      WYSIWYG 이든 아니든 모든 작성 도구는 사용자들이 잘 구조화 되고, 의미론적으로 풍부하며, 미디어 
      독립적인 콘텐트를 만드는 것이 가능하도록 최선의 노력을 기울여야(should) 합니다.

  <dfn lt="hardware limitations|practical concerns"></dfn>유저 에이전트는 그 외 자유로운 입력에 구현 
  특정(implementation-specific) 제한, 예를 들어 서비스 거부 공격을 막기 위한 제한, 또는 메모리 부족이 
  생기지 않도록 하기 위한 제한, 또는 플랫폼 특정 한계를 피하기 위한 제한을 부과할 수 있습니다.
  <a class="fingerprint" href="#fingerprinting-vector"><img height="21" src="images/fingerprint.png" width="15" alt="(이것은 지문 그림입니다.)" /></a>

  기존 콘텐트와 이전 명세와의 호환성을 위해, 이 명세는 두 가지 작성 형식을 설명합니다: 하나는 
  XML(<a href="#xhtml">XHTML 구문</a>으로 언급되는) 기반, 그리고 하나는 SGML 
  (<a href="#syntax">HTML 구문</a>으로 언급되는)에 영감을 받은 <a href="#writing-html-documents">사용자 정의 형식</a>입니다. 
  구현은 이 두가지 형식 중 적어도 하나를 지원해야(must) 하지만, 둘 모두를 지원하는 것이 권장됩니다.

  일부 적합성 요구사항은 요소(element), 속성(attribute), 메서드(method), 객체(object)의 요구사항으로 
  표현됩니다. 그러한 요구사항은 두 가지 범주로 나뉩니다: 콘텐츠 모델 제약사항을 기술하는 것과 구현
  동작을 기술하는 것. 전자의 범주의 것은 문서와 작성 도구의 요구사항입니다. 두 번째 범주의 것은 유저
  에이전트의 요구사항입니다. 비슷하게, 일부 적합성 요구사항은 저자에 대한 요구사항으로 표현됩니다;
  그러한 요구사항은 작성자가 생산한 문서에 대한 적합성 요구사항으로 해석되어야 합니다. (다시 말해, 
  이 명세는 저자에 대한 적합성 기준과 문서에 대한 적합성 기준을 구분하지 않습니다.)

<h4 id="conformance-requirements-dependencies">의존성</h4>

  이 명세는 몇 다른 기초적인 명세에 의존합니다.

  : 유니코드와 인코딩
  :: 유니코드 문자 집합은 텍스트 데이터를 나타내는데 사용되고, 인코딩 표준은 
      <a lt="character encodings">문자 인코딩</a> 요구사항을 정의합니다. [[!UNICODE]]
      <p class="note">
        이 명세는 앞서 설명된 대로, 그 명세에 정의된 용어에 기초하여 
        <a lt="character encoding">전문용어를 소개</a>합니다.
      </p>

      다음 용어들은 인코딩 표준에 정의된 대로 사용됩니다: [[!ENCODING]]

      * <dfn lt="Getting an encoding">인코딩 가져오기</dfn>
      * <dfn lt="getting an output encoding">출력 인코딩 가져오기</dfn>
      * 바이트 스트림과 인코딩을 가져오고 문자 스트림을 반환하는 일반 <a lt="decode">디코드</a> 
        알고리즘
      * 선두의 UTF-8 바이트 순서 표식(BOM)이 있다면 제거하여, 바이트 스트림을 가져오고 문자 스트림을 
        반환하는 <dfn lt="UTF-8 decode">UTF-8 디코드</dfn> 알고리즘
      * 선두의 UTF-8 바이트 순서 표식(BOM)을 제거하지 않는 것을 제외하고 
        <a lt="UTF-8 decode">UTF-8 디코드</a>와 동일한 <dfn lt="UTF-8 decode without BOM">BOM 없는 UTF-8 디코드</dfn> 알고리즘
      * 오류를 만날 때 실패가 반환되는 <a lt="UTF-8 decode without BOM">BOM 없는 UTF-8 디코드</a>와 동일한 
        <dfn lt="UTF-8 decode without BOM or fail">BOM 없는 UTF-8 디코드나 실패</dfn> 알고리즘
      * 문자 스트림과 인코딩을 가져오고 바이트 스트림을 반환하는 
        <a lt="encode code point">인코드</a> 알고리즘
      * 문자 스트림을 가져오고 바이트 스트림을 반환하는 <dfn lt="UTF-8 encode">UTF-8 인코드</dfn> 알고리즘

  : XML 그리고 관련된 명세
  :: <a href="#xhtml">XHTML 구문</a>을 지원하는 구현은 XML의 여러 버전뿐 아니라, 그 구문이 
      네임스페이스를 가진 XML 직렬화를 사용하기 때문에, 해당하는 네임스페이스 명세를 지원해야(must) 
      합니다. [[!XML]] [[!XML-NAMES]]

      <a lt="XML namespace">XML 네임스페이스</a>에서 <a lt="xml:space"><code>xml:space</code></a> 
      태그 이름을 가진 속성(attribute)은 XML 명세에 의해 정의되어 있습니다. [[!XML]]

      이 명세는 또한, <cite lt="Associating Style Sheets with XML documents">스타일 시트와 XML 문서를 연관짓기</cite> 
      명세에 정의된, <a><code>&lt;?xml-stylesheet?></code></a> 처리 명령을 
      참조합니다. [[!XML-STYLESHEET]]

      이 명세는 또한 비규범적으로 <dfn interface lt="XSLTProcessor"><code>XSLTProcessor</code></dfn> 
      인터페이스와 그것의 <dfn method for="XSLTProcessor" lt="transformToFragment()"><code>transformToFragment()</code></dfn>와 
      <dfn method for="XSLTProcessor" lt="transformToDocument()"><code>transformToDocument()</code></dfn> 메서드를 언급합니다.
  : URLs
  :: 다음 용어들은 WHATWG URL 표준에 정의되어 있습니다: [[!URL]]

      * <a for="host-concept" lt="host">host</a>
      * <a for="url" lt="domain">domain</a>
      * <a for="url" lt="URL">URL</a>
      * URL의 <a for="url" lt="Origin">Origin</a>
      * <a lt="absolute URL">절대 URL</a>
      * <a lt="relative URL">상대 URL</a>
      * <a lt="relative schemes">상대 스키마</a>
      * <a lt="URL parser">URL 해석기</a>와 <a lt="basic URL parser">기본 URL 해석기</a>, 그리고 이 해석기 단계:
         * <a lt="scheme start state">스키마 시작 단계</a>
         * <a lt="host state">host 단계</a>
         * <a lt="hostname state">hostname 단계</a>
         * <a lt="port state">port 단계</a>
         * <a lt="path start state">path 시작 단계</a>
         * <a lt="query state">query 단계</a>
         * <a lt="fragment state">fragment 단계</a>
      * <a lt="URL record">URL 레코드</a>, 그리고 그것의 각 구성 요소:
         * <a for="url" lt="scheme">스키마(scheme)</a>
         * <a lt="username">사용자 이름</a>
         * <a lt="password">비밀번호</a>
         * <a for="url" lt="host">호스트</a>
         * <a for="url" lt="port">포트</a>
         * <a lt="path">경로</a>
         * <a for="url" lt="query">쿼리</a>
         * <a for="url" lt="fragment">프래그먼트(fragment)</a>
      * <a lt="network scheme">네트워크 스키마</a>
      * <a lt="URL serializer">URL 직렬 변환기</a>
      * <a lt="host parser">호스트 해석기</a>
      * <a lt="host serializer">호스트 직렬 변환기</a>
      * <a lt="Host equals">호스트 동등성</a>
      * <a lt="serialize an integer">정수 직렬화</a>
      * <a lt="Default encode set">기본 인코드 세트</a>
      * <a lt="Percent encode">퍼센트 인코드</a>
      * <a lt="UTF-8 percent encode">UTF-8 퍼센트 인코드</a>
      * <a lt="Percent decode">퍼센트 디코드</a>
      * <a lt="set the username">사용자 이름 설정</a>
      * <a lt="set the password">비밀번호 설정</a>
      * <a lt="domain to ASCII">도메인을 ASCII로 변환</a> 알고리즘
      * <a lt="domain to Unicode">도메인을 유니코드로 변환</a> 알고리즘
      * <a lt="non-relative flag">non-relative 플래그</a>
      * <a lt="URL parser">URL 해석기</a>에서 <a for="url" lt="Parse errors">해석 오류</a>

      몇 가지 스키마와 프로토콜들은 또한 이 명세에 의해 참조됩니다:

      * <dfn scheme lt="about:|about:blank"><a scheme><code>about:</code></a></dfn> 스키마 [[!RFC6694]]
      * <dfn scheme><a scheme><code>blob:</code></a></dfn> 스키마 [[!FILEAPI]]
      * <dfn scheme lt="data: url|data:|data url"><code>data:</code></dfn> 스키마 [[!RFC2397]]
      * <dfn scheme><code>http:</code></dfn> 스키마 [[!HTTP]]
      * <dfn scheme><code>https:</code></dfn> 스키마 [[!HTTP]]
      * <dfn scheme><code>mailto:</code></dfn> 스키마 [[!RFC6068]]
      * <dfn scheme><code>sms:</code></dfn> 스키마 [[!RFC5724]]
      * <dfn scheme><code>urn:</code></dfn> 스키마 [[!URN]]

  : HTTP 그리고 관련된 명세
  :: 다음 용어들은 HTTP 명세에 정의되어 있습니다: [[!HTTP]]

      * <a><code>Accept</code></a> 헤더
      * <a><code>Accept-Language</code></a> 헤더
      * <a><code>Cache-Control</code></a> 헤더
      * <a><code>Content-Disposition</code></a> 헤더
      * <a><code>Content-Language</code></a> 헤더
      * <a><code>Content-Length</code></a> 헤더
      * <a><code>Last-Modified</code></a> 헤더
      * <a><code>Referer</code></a> 헤더

      다음 용어들은 쿠키(Cookie) 명세에 정의되어 있습니다: [[!COOKIES]]

      * <dfn lt="cookie-string">쿠키 문자열</dfn>
      * <a lt="receives a set-cookie-string">쿠키 설정 문자열 수신</a>
      * <a lt="Cookie header"><code>Cookie</code> 헤더</a>

      다음 용어들은 웹 링크하기(Web Linking) 명세에 정의되어 있습니다: [[!RFC5988]]

      * <a lt="Link header"><code>Link</code> 헤더</a>

  : 가져오기(Fetch)
  :: 다음 용어들은 WHATWG Fetch 표준에 정의되어 있습니다: [[!FETCH]]

      * <a scheme><code>about:blank</code></a>
      * <a lt="HTTPS state value">HTTPS 상태 값</a>
      * <a lt="referrer policy">리퍼러(referrer) 정책</a>
      * <a lt="CORS protocol">CORS 프로토콜</a>
      * <a lt="default User-Agent value">기본 <code>User-Agent</code> 값</a>
      * <a lt="extract a MIME type">MIME 타입 추출</a>
      * <a lt="fetch">가져오기(fetch)</a>
      * <a lt="ok status">ok 상태</a>
      * <a lt="Origin header"><code>Origin</code> 헤더</a>
      * <a lt="process response">응답 처리</a>
      * <a for="header list" lt="set">설정</a>
      * <a lt="terminate">종료</a>
      * <a><code>RequestCredentials</code></a> 열거
      * <a lt="response">응답</a>과 그와 연관된:
        * <a for="response" lt="type">유형</a>
        * <a for="response">url</a>
        * <a for="response" lt="url list">url 목록</a>
        * <a lt="status">상태</a>
        * <a for="response" lt="header list">헤더 목록</a>
        * <a for="response" lt="body">몸체</a>
        * <a lt="internal response">내부 응답</a>
        * <a for="response" lt="CSP list">CSP 목록</a>
        * <a for="response" lt="HTTPS state">HTTPS 상태</a>
      * <a lt="request">요청</a>과 그와 연관된:
        * <a for="request">url</a>
        * <a for="request" lt="method">메서드</a>
        * <a for="request" lt="header list">헤더 목록</a>
        * <a for="request" lt="body">몸체</a>
        * <a for="request" lt="client">클라이언트(client)</a>
        * <a for="request" lt="target browsing context">타겟 브라우징 컨텍스트</a>
        * <a for="request" lt="initiator">개시자</a>
        * <a for="request" lt="type">유형</a>
        * <a for="request" lt="destination">목적지</a>
        * <a for="request" lt="Origin">origin</a>
        * <a lt="omit-Origin-header flag">omit-<code>Origin</code>-header 플래그</a>
        * <a lt="same-origin data-URL flag">same-origin data-URL 플래그</a>
        * <a for="request" lt="referrer">리퍼러(referrer)</a>
        * <a lt="synchronous flag">synchronous 플래그</a>
        * <a for="request" lt="mode">모드(mode)</a>
        * <a for="request" lt="credentials mode">자격 증명 모드</a>
        * <a for="request" lt="use-URL-credentials flag">use-URL-credentials 플래그</a>
        * <a lt="unsafe-request flag">unsafe-request 플래그</a>
        * <a for="request" lt="cache mode">캐시 모드</a>
        * <a for="request" lt="redirect mode">리다이렉트(redirect) 모드</a>
        * <a lt="cryptographic nonce metadata">암호용 넌스 메타데이터</a>
        * <a lt="parser metadata">해석기 메타 데이터</a>

  : 웹 IDL
  :: 이 명세에서 IDL 코드 조각은 웹 IDL 명세에 정의된 대로, IDL 코드 조각에 적합하도록 요구된 대로 
      해석되어야(must) 합니다. [[!WEBIDL]]

      다음 용어들은 Web IDL 명세에 정의되어 있습니다:

      * <a lt="array index property name">배열 인덱스 속성(property) 이름</a>
      * <a lt="supported property indices">지원되는 속성(property) 인덱스</a>
      * <a lt="Determine the value of an indexed property">인덱싱 된 속성(property)의 값 측정</a>
      * <a lt="Support named properties">명명된 속성(property) 지원</a>
      * <a lt="Supported property names">지원되는 속성(property) 이름</a>
      * <a lt="Determine the value of a named property">명명된 속성(property)의 값 측정</a>
      * <a lt="perform a security check">보안 검사 수행</a>
      * <a lt="Platform object">플랫폼 객체</a>
      * 플랫폼 객체와 <a lt="Global environment associated with">연관된 전역 환경</a>
      * <a lt="Read only">읽기 전용</a> (배열에 적용될 경우)
      * <a lt="Callback this value">이 값을 콜백</a>
      * 웹 IDL과 JS 유형 사이 <a lt="Converting">전환하기</a>
      * <a lt="invoke the Web IDL callback function">웹 IDL 콜백 함수 호출</a>

      웹 IDL 명세는 또한 이 명세의 웹 IDL 코드 조각에 사용된 다음 유형들을 정의합니다:

      * <a><code>ArrayBufferView</code></a>
      * <a type><code>boolean</code></a>
      * <a type><code>DOMString</code></a>
      * <a type><code>USVString</code></a>
      * <a type><code>double</code></a>
      * <a type><code>Error</code></a>
      * <a><code>Function</code></a>
      * <a type><code>long</code></a>
      * <a><code>object</code></a>
      * <a type><code>unrestricted double</code></a>
      * <a type><code>unsigned long</code></a>

      이 명세에서 <dfn lt="throw">던지다(throw)</dfn>라는 용어는 WebIDL 명세에 정의된 대로 사용됩니다. 
      다음 예외 이름들은 WebIDL에서 정의되고 이 명세에서 사용됩니다:

      * <a><code>IndexSizeError</code></a>
      * <a><code>HierarchyRequestError</code></a>
      * <a><code>InvalidCharacterError</code></a>
      * <a><code>NotFoundError</code></a>
      * <a><code>NotSupportedError</code></a>
      * <a><code>InvalidStateError</code></a>
      * <a><code>SyntaxError</code></a>
      * <a><code>InvalidAccessError</code></a>
      * <a><code>SecurityError</code></a>
      * <a><code>NetworkError</code></a>
      * <a><code>QuotaExceededError</code></a>
      * <a><code>TimeoutError</code></a>
      * <a><code>DataCloneError</code></a>

      이 명세가 유저 에이전트가 특정 시간(특별한 값 Not-a-Number이 될 수 있는)을 나타내는 
      <dfn lt="date object|a new date object">{{Date}} 객체 생성</dfn>을 요구하는 경우, 그 시간의
      밀리초 요소가 있다면 이는 정수로 잘라내져야(must) 하고, 새롭게 생성된 {{Date}} 객체의 시간 값은 
      결과적으로 잘라낸 시간을 나타내야(must) 합니다.

      <p class="example">
        예를 들어, 2000년 1월 1일 01:00 UTC 이후 100만분의 23045초, 즉 2000-01-01T00:00:00.023045Z가 
        주어진 경우, 100만분의 45초 빠른, 2000-01-01T00:00:00.023Z를 나타내도록 생성된 {{Date}} 객체와 
        동일한 시간을 나타내는 {{Date}} 객체가 생성됩니다. 주어진 시간이 NaN이라면, 결과는 시간 값 
        NaN을 나타내는 (객체가 특정 시간을 나타내지 않는 것을 보여주는) {{Date}} 객체입니다. 
      </p>

  : 자바스크립트
  :: 이 명세에 의해 설명되는 언어의 일부분은 오직 기본 스크립팅 언어로 자바스크립트를 지원합니다.
      [[!ECMA-262]]

      <p class="note">
        "자바스크립트"라는 용어는 공식적인 ECMAScript라는 용어보다 자바스크립트라는 용어가 좀 더 
        널리 알려져있기 때문에 ECMA262를 지칭하는데 사용됩니다. 비슷하게, 이 명세에서 자바스크립트를 
        지칭하는데 사용된 <a lt="MIME type">MIME 타입</a>은 <code>text/javascript</code>이 거의 보통 
        사용되는 유형이기 때문에, RFC 4329에 따라 <a lt="willful violation">공식적으로 폐기된
        유형임에도 불구하고</a> <code>text/javascript</code>입니다. [[RFC4329]]
      </p>

      다음 용어들은 자바스크립트 명세에 정의 되고 이 명세에서 사용됩니다 [[!ECMA-262]]:

       * <a lt="automatic semicolon insertion">자동 세미콜론 삽입</a>
       * <a lt="early error">조기 오류</a>
       * <a lt="Directive Prologue">지시어 프롤로그</a>
       * <a lt="JavaScript execution context">자바스크립트 실행 컨텍스트</a>
       * <a lt="JavaScript execution context stack">자바스크립트 실행 컨텍스트 스택</a>
       * <a lt="running JavaScript execution context">자바스크립트 실행 컨텍스트 수행</a>
       * <a lt="JavaScript realm">자바스크립트 범위</a>
       * <a lt="current Realm Record">현재 범위 레코드</a>
       * <a lt="Use Strict Directive">엄격한 규칙 사용(use strict) 지시어</a>
       * 다음을 포함하는 <a lt="Well-Known Symbols">잘 알려진 기호</a>:
          * <dfn dfn>@@hasInstance</dfn>
          * <dfn dfn>@@isConcatSpreadable</dfn>
          * <dfn dfn>@@toPrimitive</dfn>
          * <dfn dfn>@@toStringTag</dfn>
       * 다음을 포함하는 <a lt="Well-Known Intrinsic Objects">잘 알려진 고유한 객체들</a>:
          * <a>%ArrayBuffer%</a>
          * <a>%ArrayPrototype%</a>
          * <a>%ObjProto_toString%</a>
          * <a>%ObjProto_valueOf%</a>
       * <a lt="FunctionBody">함수 몸체</a> 산출물
       * <a lt="Pattern">패턴</a> 산출물
       * <a for="ecma" lt="Script">스크립트</a> 산출물
       * <a for="ecma" lt="Type">형(type)</a> 표기법
       * <a for="ecma" lt="List">리스트</a>와 <a lt="Record">레코드</a> 명세 유형
       * <a lt="Property Descriptor">속성(property) 서술자</a> 명세 유형
       * <a>ArrayCreate</a> 추상적 연산
       * <a>Call</a> 추상적 연산
       * <a>CloneArrayBuffer</a> 추상적 연산
       * <a>Construct</a> 추상적 연산
       * <a>CreateDataProperty</a> 추상적 연산
       * <a>DetachArrayBuffer</a> 추상적 연산
       * <a>EnqueueJob</a> 추상적 연산
       * <a>FunctionCreate</a> 추상적 연산
       * <a for="ecma">Get</a> 추상적 연산
       * <a>GetActiveScriptOrModule</a> 추상적 연산
       * <a>GetFunctionRealm</a> 추상적 연산
       * <a>HasOwnProperty</a> 추상적 연산
       * <a>HostEnsureCanCompileStrings</a> 추상적 연산
       * <a>HostPromiseRejectionTracker</a> 추상적 연산
       * <a>InitializeHostDefinedRealm</a> 추상적 연산
       * <a>IsAccessorDescriptor</a> 추상적 연산
       * <a>IsCallable</a> 추상적 연산
       * <a>IsConstructor</a> 추상적 연산
       * <a>IsDataDescriptor</a> 추상적 연산
       * <a>IsDetachedBuffer</a> 추상적 연산
       * <a>NewObjectEnvironment</a> 추상적 연산
       * <a>OrdinaryGetPrototypeOf</a> 추상적 연산
       * <a>OrdinarySetPrototypeOf</a> 추상적 연산
       * <a>OrdinaryIsExtensible</a> 추상적 연산
       * <a>OrdinaryPreventExtensions</a> 추상적 연산
       * <a>OrdinaryGetOwnProperty</a> 추상적 연산
       * <a>OrdinaryDefineOwnProperty</a> 추상적 연산
       * <a>OrdinaryGet</a> 추상적 연산
       * <a>OrdinarySet</a> 추상적 연산
       * <a>OrdinaryDelete</a> 추상적 연산
       * <a>OrdinaryOwnPropertyKeys</a> 추상적 연산
       * <a>ParseScript</a> 추상적 연산
       * <a>RunJobs</a> 추상적 연산
       * <a>SameValue</a> 추상적 연산
       * <a>ScriptEvaluation</a> 추상적 연산
       * <a>ToBoolean</a> 추상적 연산
       * <a>ToString</a> 추상적 연산
       * <a>ToUint32</a> 추상적 연산
       * <a>TypedArrayCreate</a> 추상적 연산
       * <a lt="Abstract Equality Comparison">관념적 동일 비교</a> 알고리즘
       * <a lt="Strict Equality Comparison">엄격한 동일 비교</a> 알고리즘
       * {{ArrayBuffer}} 객체
       * {{Date}} 객체
       * {{SyntaxError}} 객체
       * {{TypeError}} 객체
       * {{RangeError}} 객체
       * {{RegExp}} 객체
       * <a lt="typeof">typeof</a> 연산자
       * <a lt="The TypedArray Constructors">형색화 배열 생성자</a> 표

  : DOM
  :: 문서 객체 모델(DOM)은 문서와 그것의 콘텐트의 표현 &mdash; 모델 &mdash;입니다.
      DOM은 단지 API가 아닙니다; HTML 구현의 적합성 기준은 DOM에서의 작업의 관점에서 이 명세에 
      정의되어 있습니다. [[!DOM]]

      구현은 이 명세가 DOM과 DOM 인터페이스로의 확장으로 정의되는 몇 가지 기능의 관점에서 정의되기 
      때문에 DOM과 UI 이벤트에 정의된 이벤트를 지원해야(must) 합니다. [[!DOM]] [[!UIEVENTS]]

      특히, 다음 기능들은 DOM 명세에 정의되어 있습니다: [[!DOM]]

      * {{Attr}} 인터페이스
      * {{Comment}} 인터페이스
      * {{DOMImplementation}} 인터페이스
      * {{Document}} 인터페이스
      * {{XMLDocument}} 인터페이스
      * {{DocumentFragment}} 인터페이스
      * {{DocumentType}} 인터페이스
      * {{DOMException}} 인터페이스
      * {{ChildNode}} 인터페이스
      * {{Element}} 인터페이스
      * {{Node}} 인터페이스
      * {{NodeList}} 인터페이스
      * {{ProcessingInstruction}} 인터페이스
      * {{Text}} 인터페이스
      * {{HTMLCollection}} 인터페이스
      * {{NodeList/item()}} 메서드
      * <a lt="collection">컬렉션</a>과 <a lt="represented by the collection">컬렉션에 의해 표현되는</a>이라는 용어
      * {{DOMTokenList}} 인터페이스
      * {{createDocument()}} 메서드
      * {{createHTMLDocument()}} 메서드
      * {{createElement()}} 메서드
      * {{createElementNS()}} 메서드
      * {{getElementById()}} 메서드
      * {{Element/getElementsByClassName()}} 메서드
      * {{insertBefore()}} 메서드
      * {{appendChild()}} 메서드
      * {{cloneNode()}} 메서드
      * {{importNode()}} 메서드
      * {{childNodes}} 속성(attribute)
      * {{Element/localName}} 속성(attribute)
      * {{parentNode}} 속성(attribute)
      * {{Element/namespaceURI}} 속성(attribute)
      * {{tagName}} 속성(attribute)
      * {{Element/id}} 속성(attribute)
      * {{Node/textContent}} 속성(attribute)
      * 노드에 대한 <a for="Node">insert</a>, <a for="Node">append</a>, <a for="Node">remove</a>, 
        <a for="Node">replace</a>, <a for="Node">adopt</a> 알고리즘
      * <a for="Node" lt="insert">insertion 단계</a>, <a for="Node" lt="remove">removing 단계</a>, 
        <a for="Node" lt="adopt">adopting 단계</a> 훅(hook)
      * <a lt="element attribute">속성(attirbute) 목록</a> 개념.
      * 텍스트 노드의 <a lt="cd data">data</a>.
      * {{Event}} 인터페이스
      * {{EventTarget}} 인터페이스
      * {{EventInit}} 사전형
      * {{Event/target}} 속성(attribute)
      * {{currentTarget}} 속성(attribute)
      * {{isTrusted}} 속성(attribute)
      * {{initEvent()}} 메서드
      * {{addEventListener()}} 메서드
      * 이벤트의 {{Event/type}} 
      * <a lt="event listener">이벤트 리스너</a>의 개념과 <code>EventTarget</code>과 연관된 
        <a lt="event listener">이벤트 리스너</a>.
      * <dfn lt="target override">타겟 재정의</dfn>의 개념
      * 일반 <dfn lt="event parent">이벤트 부모</dfn>의 개념과 <dfn lt="cross-boundary event parent">교차방식의 이벤트 부모</dfn>
      * <a lt="encoding">인코딩</a> (여기에서 <i>문자 인코딩</i>)과 {{Document}}dml <a lt="content type">콘텐트 유형</a>
      * <a lt="XML documents">XML 문서</a>와 <a lt="HTML documents">HTML 문서</a> 사이의 차이
      * <dfn lt="quirks mode">쿽크 모드</dfn>, <dfn lt="limited-quirks mode">제한된 쿼크 모드</dfn>, 
        <dfn>비쿼크 모드</dfn>라는 용어
      * {{Node}}를 <a for="Node" lt="clone">복제</a>하기 위한 알고리즘과, 그 알고리즘에 의해 사용되는 
        <a for="Node" lt="clone">복제 단계</a>의 개념
      * <dfn lt="base URL change steps">기본 URL 변경 단계</dfn>의 개념과 요소(element)가 
        <dfn lt="affected by a base URL change">기본 URL 변경에 의해 영향을 받는</dfn> 경우 발생하는 것의 정의
      * 요소의 <a lt="id">고유 식별자 (ID)</a>의 개념
      * <dfn lt="supported tokens|supported token">지원되는 토큰</dfn>이라는 용어
      * DOM <a lt="range">범위</a>의 개념과, 범위에 적용되는 <a lt="range start">시작</a>, 
        <a lt="range end">끝</a>, <a lt="range bp">경계점</a>이라는 용어.
      * {{MutationObserver}} 인터페이스와 일반 <dfn lt="mutation observers">변경 관찰자</dfn>

      이 명세에서 <a lt="throw">던지다</a>라는 용어는 DOM 명세에 정의된 대로 사용됩니다. 다음 
      <a>DOMException</a> 유형들은 DOM 명세에 정의되어 있습니다: [[!DOM]]

      * {{IndexSizeError}}
      * {{HierarchyRequestError}}
      * {{WrongDocumentError}}
      * {{InvalidCharacterError}}
      * {{NoModificationAllowedError}}
      * {{NotFoundError}}
      * {{NotSupportedError}}
      * {{InvalidStateError}}
      * {{SyntaxError}}
      * {{InvalidModificationError}}
      * {{NamespaceError}}
      * {{InvalidAccessError}}
      * {{SecurityError}}
      * {{NetworkError}}
      * {{AbortError}}
      * {{URLMismatchError}}
      * {{QuotaExceededError}}
      * {{TimeoutError}}
      * {{InvalidNodeTypeError}}
      * {{DataCloneError}}

      <p class="example">
        예를 들어, <i>throw a {{TimeoutError}} 예외를 던지기</i> 위해, 유저 에이전트는 유형이 문자열 
        "<code>TimeoutError</code>"이고(그리고 레거시 이유로, 코드가 23번인) 실제로 예외로 그 객체를 
        던지는 <a>DOMException</a> 객체를 구성할 것입니다.
      </p>

      다음 기능들은 UI 이벤트 명세에 정의되어 있습니다: [[!UIEVENTS]]

      * {{MouseEvent}} 인터페이스와 다음 인터페이스 멤버:
         * {{MouseEvent/relatedTarget}} 속성(attribute)
         * {{MouseEvent/button}} 속성(attribute)
         * {{MouseEvent/ctrlKey}} 속성(attribute)
         * {{MouseEvent/shiftKey}} 속성(attribute)
         * {{MouseEvent/altKey}} 속성(attribute)
         * {{MouseEvent/metaKey}} 속성(attribute)
         * {{MouseEvent/getModifierState()}} 메서드
      * {{MouseEventInit}} 사전형
      * {{FocusEvent}} 인터페이스와 그것의 {{FocusEvent/relatedTarget}} 속성(attribute)
      * {{UIEvent}} 인터페이스의 {{UIEvent/view}}와 {{UIEvent/detail}} 속성(attribute)
      * <a event>click</a> 이벤트
      * <a event>dblclick</a> 이벤트
      * <a event>mousedown</a> 이벤트
      * <a event>mouseenter</a> 이벤트
      * <a event>mouseleave</a> 이벤트
      * <a event>mousemove</a> 이벤트
      * <a event>mouseout</a> 이벤트
      * <a event>mouseover</a> 이벤트
      * <a event>mouseup</a> 이벤트
      * <a event>wheel</a> 이벤트
      * <a event>keydown</a> 이벤트
      * <a event>keyup</a> 이벤트
      * <a event>keypress</a> 이벤트

      다음 기능들은 터치 이벤트 명세에 정의되어 있습니다: [[!TOUCH-EVENTS]]

      * {{Touch}} 인터페이스
      * <a lt="Touch point">터치 포인트</a> 개념

      이 명세는 때때로 이벤트의 <code>type</code>을 지칭하기 위해, "<code>click</code>이라고 명명된 
      이벤트"나 "이벤트 이름이 <code>keypress</code>라면"의 경우와 같이,  
      <dfn event for="global" lt="name">이름</dfn>이라는 용어를 사용합니다. 이벤트에 대한 "이름"과
      "타입"이라는 용어는 동의어입니다.

      다음 기능들은 DOM 해석과 직렬화 명세에 정의되어 있습니다:
      [[!DOM-Parsing]]

      * {{Element/innerHTML}}
      * {{Element/outerHTML}}

      {{Selection}} 인터페이스는 <cite>선택 API</cite> 명세에 정의되어 있습니다. [[SELECTION-API]]

      <p class="note">
        유저 에이전트는 또한 <cite>HTML 편집 API들</cite>과 <cite><code>UndoManager</code>와 DOM 처리</cite> 
        명세에 설명된 기능들을 구현하도록 권장됩니다. [[EDITING]] [[UNDO]]
      </p>

      풀스크린 명세의 다음 부분들은, 풀스크린 API가 HTML에서 샌드박싱 기능과 상호작용하는 방법을 
      정의하기 위한 부분에서, 이 명세에서 참조됩니다: [[!FULLSCREEN]]

      * <a lt="top layer">최상위 레이어</a> 개념
      * {{Element/requestFullscreen()}}
      * <a lt="fullscreen enabled flag">fullscreen enabled 플래그</a>
      * <a lt="fully exit fullscreen">풀스크린을 완전히 나가는</a> 알고리즘

      <cite>고분해능 시간</cite> 명세는 {{DOMHighResTimeStamp}} 형식 정의와 {{Performance}} 객체의 
      {{Performance/now()}} 메서드를 제공합니다. [[!HR-TIME-2]]

  : 파일 API
  :: 이 명세는 파일 API 명세에 정의된 다음 기능들을 사용합니다:
      [[!FILEAPI]]

      * {{Blob}} 인터페이스
      * {{File}} 인터페이스
      * {{FileList}} 인터페이스
      * <a for="Blob" lt="closed">closed</a>의 개념 {{Blob}}
      * <a attribute for="Blob" lt="type"><code>Blob.type</code></a>
      * <dfn lt="error occurs during reading of the object|read errors">읽기 오류</dfn>의 개념

  : 미디어 소스 확장
  :: 다음 용어들은 미디어 소스 확장 명세에 정의되어 있습니다: [[!MEDIA-SOURCE]]

      * <dfn lt="detach from a media element">미디어 요소(element)로부터 분리</dfn>
      * {{MediaSource}} [[!MEDIA-SOURCE]]

  : 미디어 캡쳐와 스트림
  :: 다음 용어는 미디어 캡쳐와 스트림 명세에 정의되어 있습니다: [[!MEDIACAPTURE-STREAMS]]

      * {{MediaStream}} [[!MEDIACAPTURE-STREAMS]]

  : XMLHttpRequest
  :: 이 명세는 두 명세가 상호 작용하는 방법을 설명하기 위해 XMLHttpRequest 명세를 참조합니다. 다음 
      기능들과 용어들은 XMLHttpRequest 명세에 정의되어 있습니다: [[XHR]]

      * {{XMLHttpRequest}} 인터페이스
      * {{XMLHttpRequest/responseXML|XMLHttpRequest.responseXML}} 속성(attribute)

  : {{ProgressEvent}}
  :: 이 명세는 두 명세가 상호작용하는 방법과 그것의 {{ProgressEvent}} 기능을 사용하는 방법을 설명하기 
      위해 프로그레스 이벤트(Progress Events) 명세를 참조합니다. 다음 기능은 프로그레스 이벤트 명세에 
      정의되어 있습니다: [[PROGRESS-EVENTS]]

      * {{ProgressEvent}} 인터페이스
      * <a attribute lt="lengthcomputable"><code>ProgressEvent.lengthComputable</code></a> 속성(attribute)
      * <a attribute lt="loaded"><code>ProgressEvent.loaded</code></a> 속성(attribute)
      * <a attribute lt="total"><code>ProgressEvent.total</code></a> 속성(attribute)
      * <a lt="Fire a progress event named e"><var>e</var>로 명명된 프로그레스 이벤트를 발생</a>

  : 서버 발송 이벤트(Server-Sent Events)
  :: 이 명세는 서버 발송 이벤트 명세에 명시된 {{EventSource}}를 참조합니다. [[!EVENTSOURCE]]

  : 미디어 쿼리(Media Queries)
  :: 구현은 미디어 쿼리 언어를 지원해야(must) 합니다. [[!MEDIAQ]]

  : CSS 모듈(modules)
  :: CSS를 전체적으로 지원하는 것은 이 명세의 구현에 필요하지 않지만(권장되기는 하지만, 웹 브라우저에
      대해 최소한), 일부 기능들은 CSS 특정 요구사항의 관점에서 정의되어 있습니다. 

      특히, 일부 기능은 문자열이 <dfn lt="parsed as a CSS &lt;color&gt; value">CSS &lt;color&gt; 값으로 해석</dfn>
      되는 것을 요구합니다. CSS 값을 해석하는 경우, 유저 에이전트는 CSS 명세에 의해 일부 오류 처리 
      규칙이 적용되도록 요구됩니다. 이것들은 이 명세에도 적용됩니다. [[!CSS3COLOR]] [[!CSS-2015]]

      <p class="example">
        예를 들어, 유저 에이전트는 스타일 시트의 끝을 찾자마자 모든 열려진 구성을 닫도록 요구됩니다.
        따라서, 색상 값에 대한 문자열 "<code>rgb(0,0,0</code>" (닫는 괄호가 누락된)을 해석하는 경우,
        이 오류 처리 규칙에 의해 닫는 괄호가 암묵적이 되고, 값이 얻어집니다 (색상 ''검정''). 하지만,
        비슷한 구성 "<code>rgb(0,0,</code>"는 (괄호와 "blue" 값이 모두 누락된) 열려진 구성을 닫는 
        것이 실행 가능한 값이 되지 않기 때문에 해석될 수 없습니다.
      </p>

      다음 용어들과 기능들은 CSS 명세에 정의되어 있습니다: [[!CSS-2015]]

      * <dfn lt="viewport">뷰포트(viewport)</dfn>
      * <dfn lt="replaced element">대체 요소(element)</dfn>
      * <dfn lt="intrinsic dimensions">고유 치수</dfn>

      <dfn lt="named color|named colors">명명된 색상</dfn>이라는 용어는 CSS 색상 명세에 정의되어 
      있습니다. [[!CSS3COLOR]]

      <dfn for="css" lt="intrinsic width">고유 너비</dfn>와 <dfn for="css" lt="intrinsic height">고유 높이</dfn>라는 
      용어는 각각 <a lt="intrinsic dimensions">고유 치수</a>의 너비 치수와 높이 치수를 지칭합니다.

      <dfn lt="provides a paint source">페인트 소스를 제공한다</dfn>는 용어는 CSS 'element()' 함수와 
      특정 HTML 요소(element)의 상호작용을 정의하기 위해 <cite>CSS 이미지 값과 대체 콘텐트</cite> 
      명세에 정의된 대로 사용됩니다. [[!CSS3-IMAGES]]

      <dfn lt="default object size">기본 객체 사이즈</dfn>라는 용어 역시 
      <cite>CSS 이미지 값과 대체 콘텐트</cite> 명세에 정의되어 있습니다. [[!CSS3-IMAGES]]

      스크립팅을 지원하는 구현은 CSS 객체 모델을 지원해야 합니다. 다음 기능들과 용어들은 CSSOM 명세에
      정의되어 있습니다: [[!CSSOM]] [[!CSSOM-VIEW]]

      * <a interface><code>Screen</code></a>
      * <a interface><code>LinkStyle</code></a>
      * <a interface><code>CSSStyleDeclaration</code></a>
      * <a interface><code>CSSStyleDeclaration</code></a>의 <a attribute for="CSSStyleDeclaration"><code>cssText</code></a> 속성(attribute)
      * <a interface><code>StyleSheet</code></a>
      * <a spec="cssom" lt="create a CSS style sheet">CSS 스타일 시트 생성</a>
      * <a spec="cssom" lt="remove a CSS style sheet">CSS 스타일 시트 제거</a>
      * <a spec="cssom" lt="associated CSS style sheet">연관된 CSS 스타일 시트</a>
      * <a lt="CSS style sheets">CSS 스타일 시트</a>와 프로퍼티(propetry)들:
            <a for="stylesheet" lt="type">type</a>,
            <a spec="cssom">location</a>,
            <a lt="parent CSS style sheet">부모 CSS 스타일 시트</a>,
            <a lt="owner node">소유자 노드</a>,
            <a lt="owner CSS rule">소유자 CSS 규칙</a>,
            <a>media</a>,
            <a>title</a>,
            <a lt="alternate flag">alternate 플래그</a>,
            <a lt="disabled flag">disabled 플래그</a>,
            <a lt="CSS rules">CSS 규칙</a>,
            <a lt="origin-clean flag">origin-clean 플래그</a>
      * <a lt="Alternative style sheet sets">대체 스타일 시트 세트</a>와 <a lt="preferred style sheet set">우선되는 스타일 시트 세트</a>
      * <a lt="Serializing a CSS value">CSS 값 직렬화</a>
      * <a lt="run the resize steps">크기 조정 단계 수행</a>
      * <a lt="run the scroll steps">스크롤 단계 수행</a>
      * <a lt="evaluate media queries and report changes">미디어쿼리 평가와 변경 보고</a>
      * <a spec="cssom-view" lt="Scroll an element into view">뷰(view) 안으로 요소(element)를 스크롤</a>
      * <a spec="cssom-view" lt="Scroll to the beginning of the document">문서의 시작 부분으로 스크롤</a>
      * <a event><code>resize</code></a> 이벤트
      * <a event><code>scroll</code></a> 이벤트
      * <a lt="The features argument of window.open"><code>window.open</code>의 <em>특징</em> 인자(argument)</a>

      다음 기능들과 용어들은 <cite>CSS 구문</cite> 명세에 정의되어 있습니다:
      [[!CSS-SYNTAX-3]]

      * <a lt="consume a component value">구성 값들의 콤마로 구분된 목록 해석</a>
      * <a lt="component value">구성 값</a>
      * <a lt="environment encoding">환경 인코딩</a>
      * <a type lt="whitespace">&lt;whitespace-token></a>

      <a>&lt;length></a> 특성은 <cite>CSS 값과 단위</cite> 명세에 정의되어 있습니다. [[!CSS-VALUES]]

      <a lt="CSS styling attribute">CSS 스타일링 속성(attribute)</a>라는 용어는 
      <cite>CSS Style 속성(attribute)</cite> 명세에 정의되어 있습니다. [[!CSS-STYLE-ATTR]]

      <code>CanvasRenderingContext2D</code> 객체의 폰트 사용은 CSS <cite>폰트</cite>와 
      <cite>폰트 로딩</cite> 명세에 설명된 기능에 따라, 특히 <a interface><code>FontFace</code></a> 
      객체와 <a spec="css-font-loading-3" lt="font source">폰트 소스</a> 개념을 포함하여, 달라집니다. 
      [[!CSS-FONTS-3]] [[CSS-FONT-LOADING-3]]

      다음 인터페이스는 외형 인터페이스 모듈(Geometry Interfaces Module) 명세에 정의되어 있습니다:
      [[!GEOMETRY-1]]

      * {{DOMMatrix}} 인터페이스

  : SVG
  :: <code>CanvasRenderingContext2D</code> 객체의 폰트 사용은 CSS <cite>폰트</cite>와
      <cite>폰트 로딩</cite> 명세에 설명된 기능에 따라, 특히 <a interface><code>FontFace</code></a> 
      객체와 <a spec="css-font-loading-3" lt="font source">폰트 소스</a> 개념을 포함하여, 달라집니다. 
      [[!CSS-FONTS-3]] [[CSS-FONT-LOADING-3]]

      다음 인터페이스는 SVG 명세에 정의되어 있습니다: [[!SVG11]]

      * {{SVGMatrix}}

  : WebGL
  :: 다음 인터페이스는 WebGL 명세에 정의되어 있습니다: [[!WEBGL]]

      * {{WebGLRenderingContext}}

  : WebVTT
  :: 구현은 미디어 리소스에 대한 자막(subtitle), 캡션(caption), 챕터 제목, 메타데이터 등으로서 
      <dfn>WebVTT</dfn>를 지원할 수 있습니다. [[WEBVTT]]

      이 명세에 사용된 다음 용어들은 WebVTT 명세에 정의되어 있습니다:

      * <dfn lt="WebVTT file">WebVTT 파일</dfn>
      * <dfn lt="WebVTT file using cue text">큐 텍스트를 사용하는 WebVTT 파일</dfn>
      * <dfn lt="WebVTT file using chapter title text">챕터 제목 텍스트를 사용하는 WebVTT 파일</dfn>
      * <dfn lt="WebVTT file using only nested cues">중첩된 큐만을 사용하는 WebVTT 파일</dfn>
      * <dfn lt="WebVTT parser">WebVTT 해석기</dfn>
      * <dfn lt="rules for updating the display of WebVTT text tracks">WebVTT 텍스트 트랙의 표시 갱신을 위한 규칙</dfn>
      * <dfn lt="rules for interpreting WebVTT cue text">WebVTT 큐 텍스트 해석을 위한 규칙</dfn>
      * WebVTT <dfn lt="text track cue writing direction">텍스트 트랙 큐 쓰기 방향</dfn>

  : 웹소켓 프로토콜
  :: 다음 용어들은 웹소켓 프로토콜 명세에 정의되어 있습니다: [[!RFC6455]]

      * <dfn lt="establish a WebSocket connection">웹 소켓 연결 수립</dfn>
      * <dfn lt="the WebSocket connection is established">웹 소켓 연결 수립됨</dfn>
      * <dfn lt="validate the server's response">서버 응답 검증</dfn>
      * <dfn lt="extensions in use">쓰이고 있는 확장</dfn>
      * <dfn lt="subprotocol in use">쓰이고 있는 서브프로토콜</dfn>
      * <dfn lt="headers to send appropriate cookies">적절한 쿠키를 보내기 위한 헤더</dfn>
      * <dfn lt="cookies set during the server's opening handshake">서버의 여는 핸드쉐이크(opening handshake) 동안 쿠키 설정</dfn>
      * <dfn lt="a WebSocket message has been received">웹소켓 메세지가 수신되었습니다</dfn>
      * <dfn lt="send a WebSocket Message">웹소켓 메시지 전송</dfn>
      * <dfn lt="fail the WebSocket connection">웹소켓 연결 실패</dfn>
      * <dfn lt="close the WebSocket connection">웹소켓 연결 종료</dfn>
      * <dfn lt="start the WebSocket closing handshake">웹소켓 닫는 핸드쉐이크(closing handshake) 시작</dfn>
      * <dfn lt="the WebSocket closing handshake is started">웹소켓 닫는 핸드쉐이크(closing handshake)가 시작되었습니다</dfn>
      * <dfn lt="the WebSocket connection is closed">웹소켓 연결이 종료되었습니다</dfn> (아마도 <i>완전히</i>)
      * <dfn lt="the WebSocket connection close code">웹소켓 연결 종료 코드</dfn>
      * <dfn lt="the WebSocket connection close reason">웹소켓 연결 종료 사유</dfn>
      * <dfn><code>Sec-WebSocket-Protocol</code></dfn> 필드

  : ARIA
  :: <dfn element-attr for="global"><code>role</code></dfn> 속성(attirbute)는 다음 역할(role)들과 
      같이 ARIA 명세에 정의되어 있습니다: [[!WAI-ARIA]]

      * <a value for="role"><code>alert</code></a>
      * <a value for="role"><code>alertdialog</code></a>
      * <a value for="role"><code>application</code></a>
      * <a value for="role"><code>article</code></a>
      * <a value for="role"><code>banner</code></a>
      * <a value for="role"><code>button</code></a>
      * <a value for="role"><code>checkbox</code></a>
      * <a value for="role"><code>columnheader</code></a>
      * <a value for="role"><code>combobox</code></a>
      * <a value for="role"><code>complementary</code></a>
      * <a value for="role"><code>contentinfo</code></a>
      * <a value for="role"><code>dialog</code></a>
      * <a value for="role"><code>directory</code></a>
      * <a value for="role"><code>document</code></a>
      * <a value for="role"><code>grid</code></a>
      * <a value for="role"><code>gridcell</code></a>
      * <a value for="role"><code>group</code></a>
      * <a value for="role"><code>heading</code></a>
      * <a value for="role"><code>img</code></a>
      * <a value for="role"><code>link</code></a>
      * <a value for="role"><code>list</code></a>
      * <a value for="role"><code>listbox</code></a>
      * <a value for="role"><code>listitem</code></a>
      * <a value for="role"><code>log</code></a>
      * <a value for="role"><code>main</code></a>
      * <a value for="role"><code>marquee</code></a>
      * <a value for="role"><code>menu</code></a>
      * <a value for="role"><code>menubar</code></a>
      * <a value for="role"><code>menuitem</code></a>
      * <a value for="role"><code>menuitemcheckbox</code></a>
      * <a value for="role"><code>menuitemradio</code></a>
      * <a value for="role"><code>navigation</code></a>
      * <a value for="role"><code>note</code></a>
      * <a value for="role"><code>option</code></a>
      * <a value for="role"><code>presentation</code></a>
      * <a value for="role"><code>progressbar</code></a>
      * <a value for="role"><code>radio</code></a>
      * <a value for="role"><code>region</code></a>
      * <a value for="role"><code>row</code></a>
      * <a value for="role"><code>rowgroup</code></a>
      * <a value for="role"><code>rowheader</code></a>
      * <a value for="role"><code>search</code></a>
      * <a value for="role"><code>separator</code></a>
      * <a value for="role"><code>slider</code></a>
      * <a value for="role"><code>spinbutton</code></a>
      * <a value for="role"><code>status</code></a>
      * <a value for="role"><code>tab</code></a>
      * <a value for="role"><code>tablist</code></a>
      * <a value for="role"><code>textbox</code></a>
      * <a value for="role"><code>toolbar</code></a>
      * <a value for="role"><code>tree</code></a>
      * <a value for="role"><code>treeitem</code></a>

      게다가, 다음 <dfn element-attr for="global"><code>aria-*</code></dfn> 콘텐트 속성(attribute)는 
      ARIA 명세에 정의되어 있습니다: [[!WAI-ARIA]]

      * <dfn element-attr for="global"><code>aria-checked</code></dfn>
      * <dfn element-attr for="global"><code>aria-describedby</code></dfn>
      * <dfn element-attr for="global"><code>aria-disabled</code></dfn>
      * <dfn element-attr for="global"><code>aria-expanded</code></dfn>
      * <dfn element-attr for="global"><code>aria-hidden</code></dfn>
      * <dfn element-attr for="global"><code>aria-invalid</code></dfn>
      * <dfn element-attr for="global"><code>aria-label</code></dfn>
      * <dfn element-attr for="global"><code>aria-level</code></dfn>
      * <dfn element-attr for="global"><code>aria-multiline</code></dfn>
      * <dfn element-attr for="global"><code>aria-multiselectable</code></dfn>
      * <dfn element-attr for="global"><code>aria-owns</code></dfn>
      * <dfn element-attr for="global"><code>aria-readonly</code></dfn>
      * <dfn element-attr for="global"><code>aria-required</code></dfn>
      * <dfn element-attr for="global"><code>aria-selected</code></dfn>
      * <dfn element-attr for="global"><code>aria-sort</code></dfn>
      * <dfn element-attr for="global"><code>aria-valuemax</code></dfn>
      * <dfn element-attr for="global"><code>aria-valuemin</code></dfn>
      * <dfn element-attr for="global"><code>aria-valuenow</code></dfn>

  : 콘텐트 보안 정책
  :: 다음 용어들은 <cite>콘텐트 보안 정책</cite>에 정의되어 있습니다: [[!CSP3]]

      * <a lt="Content Security Policy">콘텐트 보안 정책</a>
      * <a lt="Content Security Policy directive">콘텐트 보안 정책 지시어</a>
      * <a lt="Content Security Policy syntax">콘텐트 보안 정책 구문</a>
      * <a lt="enforce the policy">정책 시행</a>
      * <a lt="parse a serialized Content Security Policy">직렬화된 콘텐트 보안 정책 해석</a> 알고리즘
      * <a lt="Initialize a global object's CSP list">전역 객체의 CSP 목록 초기화</a> 알고리즘
      * <a lt="Initialize a Document's CSP list">문서의 CSP 목록 초기화</a> 알고리즘
      * <a lt="Should element's inline behavior be blocked by Content Security Policy?">요소(element)의 인라인 동작은 콘텐트 보안 정책에 의해 차단되어야(should) 하는가?</a> 알고리즘
      * <a><code>report-uri</code></a>, <a><code>frame-ancestors</code></a>,
         <a><code>sandbox</code></a> <a lt="directives">지시어</a>
      * <a lt="EnsureCSPDoesNotBlockStringCompilation">EnsureCSPDoesNotBlockStringCompilation</a> 추상화 알고리즘
      * <a lt="Is base allowed for Document?">문서에 대해 허용된 base인가?</a> 알고리즘
  :: 다음 용어들은 <cite>콘텐트 보안 정책: 문서 특징</cite>에 정의되어 있습니다. <!-- [[!CSPDOCUMENT]] when published -->

      * <a lt="frame-ancestors directive"><code>frame-ancestors</code> 지시어</a>
      * <a lt="sandbox directive"><code>sandbox</code> 지시어</a>

  : 서비스 워커
  :: 다음 용어들은 <cite>서비스 워커</cite>에 정의되어 있습니다: [[!SERVICE-WORKERS]]

      * <dfn lt="match service worker registration">서비스 워커 등록 매칭</dfn>

  이 명세는 임의의 특정 네트워크 프로토콜, 스타일 시트 언어, 스크립팅 언어, 위 목록에 요구된 것들을 
  넘어선 임의의 DOM 명세의 지원을 <em>요구</em>하지 않습니다. 하지만, 이 명세에 설명된 언어는 
  스타일 언어로 CSS에, 스크립트 언어로 자바스크립트에, 네트워크 프로토콜에 HTTP에 관심을 두고 있고,
  몇가지 기능들은 그 언어와 프로토콜들이 사용되고 있는 것으로 추정됩니다.

  HTTP 프로토콜을 구현하는 유저 에이전트는 웹 출처 개념(Web Origin Concept) 명세와 HTTP 상태 관리 
  메커니즘 명세(쿠키) 역시 구현해야(must) 합니다.  [[!HTTP]] [[!ORIGIN]] [[!COOKIES]]

  <p class="note">
    이 명세는 각각의 섹션에서 문자 인코딩, 이미지 형식, 오디오 형식, 비디오 형식에 대한 추가적인 
    요구사항을 가질 수 있습니다.
  </p>

<h4 id="conformance-requirements-extensibility">확장성</h4>

  벤더 특정 소유 유저 에이전트가 이 명세를 확장하는 것은 강력하게 지양됩니다. 
  문서는 사용자의 특정 유저 에이전트만이 문제의 콘텐트를 접근하는 것을 허용하여 상호 운용성을 줄이고 
  사용자 기반을 파편화하기 때문에 그러한 확장을 사용해서는(must) 안됩니다. 

  그러한 확장이 그렇더라도 필요하다면, 예를 들어 실험적인 목적으로, 벤더들은 다음 확장 메커니즘의 
  사용이 강력히 권장됩니다:

  * XML 직렬화에 제한될 수 없고 HTML 직렬화에 지원될 필요가 없는 마크업 레벨 기능에 대해, 벤더들은 
    비표준 요소(element)와 속성(attribute)가 지원되는 사용자 정의 네임스페이스를 정의하기 위한 
    네임스페이스 메커니즘을 사용해야(should) 합니다.

  * <a href="#syntax">HTML 구문</a>을 사용하도록 의도된 마크업 레벨 기능에 대해, 확장은 
    <var>vendor</var>가 확장에 대한 벤더 책임을 확인하는 짧은 문자열이고 <var>feature</var>가 기능의 
    이름인"<code>x-<var>vendor</var>-<var>feature</var></code>" 형식의 새로운 속성(attirbute)로  
    제한되어야(should) 합니다. 새로운 요소(element) 이름은 생성되어서는(should) 안됩니다. 그러한 
    확장을 위한 속성(attribute) 사용은 독점적으로 여러 벤더로부터의 확장이 동일한 요소(element)에 
    공존하는 것을 허용하고, 이 요소는 요소로 가능하지 않습니다. 
    "<code>x-<var>vendor</var>-<var>feature</var></code>" 형식을 사용하는 것은 확장이 향후 명세에 
    추가 사항과 충돌하는 위험성 없이 되는 허용합니다.

    <div class="example">
      예를 들어, "FerretBrowser"라는 브라우저는 벤더 프리픽스(prefix)로 "ferret"를 사용할 수 있고,
      반면 "Mellblom Browser"라는 브라우저는 "mb"를 사용할 수 있습니다. 이 브라우저들 모두 
      요소(element)를 scratch-and-sniff 영역으로 설정하는 확장을 고안한다면, 이 기능을 실험하는 
      작성자는 다음과 같이 작성할 수 있습니다:

      <pre highlight="html">
        &lt;p>이것은 레몬 냄새가 납니다!
        &lt;span x-ferret-smellovision x-ferret-smellcode="LEM01"
        x-mb-outputsmell x-mb-smell="lemon juice">&lt;/span>&lt;/p>
      </pre>
    </div>

  두 문자 <code>x-</code>"로 시작하는 속성(attribute)이름은 유저 에이전트가 사용하기 위해 예약 
  되었고 HTML 언에어 결코 공식적으로 추가되지 않을 것이 확실합니다. 유연성을 위해, 
  밑줄(U+005F LOW LINE 문자)을 포함하는 속성(attribute)이름 역시 실험적인 목적을 위해 예약 되었고 
  HTML 언어에 결코 공식적으로 추가되지 않을 것이 확실합니다.

  <p class="note">그러한 속성(attribute)을 사용하는 페이지는 비 규범적 정의에 의합니다.</p>

  DOM 확장을 위해, 예를 들어 새로운 메서드와 IDL 속성(attribute), 새로운 멤버들은 이 명세의 미래 
  버전과 충돌하는 것을 방지하기 위해 벤더 특정 문자열이 앞에 붙어야(should) 합니다. 

  이벤트를 위해, 실험적인 이벤트 유형은 벤더 특정 문자열이 앞에 붙어야(should) 합니다.

  <div class="example">
    예를 들어, 사용자가 엘레베이터에서 올라갈 때 보여주기 위한 이벤트 "Pleasold"를 호출했다면,
    "<code>pleasold</code>" 접두어를 사용할 수 있고 따라서 이벤트를 아마 "<code>onpleasoldgoingup</code>"라고 
    명명된 이벤트 핸들러가 있는 "<code>pleasoldgoingup</code>"로 명명합니다.
  </div>

  모든 확장들은 확장의 사용이 모순되거나 명세에 정의된 기능성의 비적합이 야기되지 않도록 정의되어야 
  합니다

  <div class="example">
    예를 들어, 그렇게 하는 것이 강하게 지양되는 동안, "Foo Browser" 구현은 새로운 IDL 속성(attribute)
    "<code>fooTypeTime</code>"를 사용자가 컨트롤의 현재 값을 선택한 시간이 반환되는 컨트롤의 DOM 
    인터페이스에 추가할 수 있습니다(일례로). 다른 한편으로, 양식(form)의 <code>elements</code> 
    배열에 나타나는 새로운 컨트롤을 정의하는 것은 이 명세에 주어진 <code>elements</code>의 정의를 
    위반할 것이기 때문에 위 요구사항을 위반할 것입니다.
  </div>

  "<code>x-<var>vendor</var>-<var>feature</var></code>" 형식의 콘텐트 속성에 상응하는 새로운  
  <a lt="reflecting">반영하는</a> IDL 속성(attribute)을 추가하는 경우, IDL 속성(attribute)은 
  "<code><var>vendor</var><var>Feature</var></code>"라고 명명되어야(should) 합니다(즉, 
  "<code>x</code>"는 IDL 속성(attribute)의 이름에서 빠집니다).

<hr />

  벤더 중립적인 확장이 이 명세에 필요한 경우, 이 명세가 그에 맞춰 업데이트 되거나, 확장 명세가 이 
  명세의 요구사항을 재정의하는 것이 기록될 수 있습니다. 이 명세를 그들의 액티비티에 적용하는 사람이
  그러한 확장 명세의 요구사항을 인식할 것을 결정할 경우, 이 명세의 적합성 요구사항의 목적에 대해
  <a lt="applicable specification">적절한 명세</a>가 됩니다.

  <p class="note">
    누군가 임의의 적합한 바이트 스트림을 정의하는 명세를 작성하고, 이후 그들의 무작위 쓰레기가
    적합하다고 주장할 수 있습니다. 하지만, 그것이 그들의 무작위 쓰레기가 실제로 모두의 목적에 대해 
    적합하다는 것을 의미하지 않습니다: 다른 누군가 명세가 그들의 작업에 적용하지 않는다고 결정한다면,
    그들은 앞서 언급한 임의의 쓰레기가 단지 쓰레기이고 전혀 적합하지 않다고 꽤 정당하게 말할 수 
    있습니다. 적합성에 관한 한, 특정 커뮤니티에서 중요한 것은 그 커뮤니티가 <em>동의하는</em> 것이
    적용된다는 것이다.
  </p>

  <dfn lt="applicable specification">적용 가능한 명세</dfn>.

  문서에 대한 적합성 용어는 그러한 적용 가능한 명세에 의해 도입된 변경 사항과 문서의 콘텐트와 
  의도된 해석에 따라 달라집니다.
  적용 가능한 명세는 새로운 문서 콘텐트(예를 들어 foobar 요소)를 정의하거나, 다른 특정 적합한 
  콘텐트를 금지하거나(예를 들어, &lt;table>s의 사용을 금지), 의미, DOM 매핑, 이 명세에 정의된 
  콘텐트에 대한 처리 규칙을 변경할 수도 있습니다. 문서가 
  <a lt="conforming document">적합한 HTML 문서</a>인지 아닌지는 적용 가능한 명세의 사용에 따르지 
  않습니다: 주어진 <a lt="conforming document">적합한 HTML 문서</a>의 구문과 의미가 적용 가능한 
  명세(들)의 사용에 의해 변경되지 않는다면, 그 문서는 여전히 <a lt="conforming document">적합한 HTML 문서</a>
  입니다. 주어진 (다른 적합한) 문서의 의미와 처리가 적용 가능한 명세(들)의 사용에 의해 변경된다면, 
  그것은 <a lt="conforming document">적합한 HTML 문서</a>가 아닙니다. 그러한 경우에 대해, 적용 가능한
  명세는 적합성 용어를 정의해야(SHOULD) 합니다.

  <p class="note">
    제안되었지만 요구된 규정이 아니기 때문에, 그러한 명세는 XXX가 적용 가능한 명세에 대한 짧은 이름
    인 "적합한 HTML+XXX 문서"와 같은 적합성 용어를 정의 할 수 있습니다. (예: "적합한
    HTML+AutomotiveExtensions 문서")
  </p>

  <p class="note">위에 주어진 규칙의 결과는 특정한 구문상으로 옳은 HTML 문서가 적용 가능한 명세가 
    있는 곳에서 <a lt="conforming document">적합한 HTML 문서</a>가 아닐 수 있다는 것입니다. (예: 
    적용 가능한 명세는 &lt;table>을 하나의 내용으로 정의합니다 &#8212; 그 명세에 작성되고 &lt;table>
    요소(element)를 포함하는 문서는 요소(element)가 구문적으로 옳은 HTML으로 되어 있더라도 
    <a lt="conforming document">적합한 HTML 문서</a>가 아닙니다.)
  </p>

  <hr />

  유저 에이전트는 구문적으로 중립적인 것으로 이해할 수 없는 요소(element)와 속성(attribute)를 
  처리해야(must) 합니다; DOM에 그것들을 두고(DOM 처리기에 대해), CSS를 따라 스타일링 하지만 (CSS
  처리기에 대해), 그것들로부터 어떠한 의미도 끌어내지 않습니다.

  기능에 대한 지원이 비활성 된 경우 (예를 들어, 보안 문제를 완화시키기 위해, 혹은 개발 지원을 위해, 
  혹은 성능 이유로 긴급한 조치로서), 유저 에이전트는 어떤 기능에 대해서도 지원이 없었던 것 처럼, 
  그리고 기능이 이 명세에 언급지 않은 것 처럼 수행해야(must) 합니다. 예를 들어, 특정 기능이 웹 IDL
  인터페이스에서 속성(attribute)를 통해 접근된다면, 속성(attribute) 자체는 그 인터페이스를 구현하는 
  &mdash; 객체에 속성(attribute)를 두지만 null을 반환하거나 예외를 던지는(throw) 것을 불충분하게 하여
  , 객체로부터 생략될 것입니다.

<h4 id="interactions-with-xpath-and-xslt">XPath와 XSLT와의 상호작용</h4>

  이 명세에 설명된 방법으로(예를 들어, <code>document.evaluate()</code> API의 일부로) 해석되거나 
  생성된 <a lt="HTML documents">HTML 문서</a>에서 운용되는 XPath 1.0의 구현은 마치 다음 편집이 XPath
  1.0 명세에 적용된 것처럼 수행해야(must) 합니다.

  먼저, 이 문단을 제거합니다:

  <blockquote cite="https://www.w3.org/TR/1999/REC-xpath-19991116#node-tests">
    노드 테스트의 <a lt="QName">QName</a>이 표현 맥락에서 네임스페이스 선언을 사용하여 
    <a lt="expanded-name">확장된 이름</a>으로 확장됩니다. 이것은 <code>xmlns</code>로 선언된 
    기본 네임스페이스가 사용되지 않는 것을 제외하고 시작 태그와 종료 태그의 요소 유형 이름에 대해 
    확장이 수행된 것과 같은 방식입니다: <a lt="QName">QName</a>이 접두어를 가지지 않는다면, 
    네임스페이스 URI는 null입니다(이것은 속성 이름이 확장되는 것과 같은 방식 입니다). <a lt="QName">QName</a>이 
    표현 맥락에 네임스페이스 선언이 없는 접두어를 가진다면 이것은 오류입니다.
  </blockquote>

  그 후, 다음을 그 자리에 삽입합니다:

  <blockquote cite="https://www.w3.org/Bugs/Public/show_bug.cgi?id=7059#c37">
    노드 테스트의 QName이 표현 맥락에서 네임스페이스 선언을 사용하여 확장된 이름으로 확장됩니다.
    QName이 접두어를 가진다면, 표현 맥락에 이 접두어에 대한 네임스페이스 선언이 존해해야(must) 하고,
    해당하는 네임스페이스 URI는 이 접두어와 연관된 것이어야(must) 합니다. QName이 표현 맥락에 
    네임스페이스 선언이 없는 접두어를 가진다면 이것은 오류입니다.

    QName이 접두어를 가지지 않고 주축의 주요 노드 타입이 요소(element)라면, 기본 요소(element)
    네임스페이스가 사용됩니다. 그렇지 않고 QName이 접두어를 가지지 않는다면, 네임스페이스 URI는 null
    입니다. 기본 요소(element) 네임스페이스는 XPath 표현에 대한 맥락의 멤버입니다. XPath 표현을 
    DOM3 XPath API를 통해 실행할 때 기본 요소(element) 네임스페이스의 값은 다음 방법으로 결정됩니다:

    1. 컨텍스트 노드가 HTML DOM으로부터라면, 기본 요소(element) 네임스페이스는
        "https://www.w3.org/1999/xhtml" 입니다.
    2. 그렇지 않으면, 기본 요소(element) 네임스페이스 URI는 null입니다.

    <p class="note">
      이것은 XPath 2.0의 기본 요소(element) 네임스페이스 기능을 XPath 1.0에 추가하는 것과, HTML 문서에
      대한 기본 요소(element) 네임스페이스로서 HTML 네임스페이스를 사용하는 것과 동일합니다. 그것은
      이 명세가 HTML 요소(element)에 대해 사용된 네임스페이스에 대하여 HTML에 도입하는 변경사항을 
      여전히 지원하는 동안 구현이 레거시 HTML 콘텐트와 호환되도록 하고자 하는 바람과, XPath 2.0보다 
      XPath 1.0을 사용하고자 하는 바람에 기인합니다.
    </p>
  </blockquote>

  <p class="note">
    이 변경은 Xpath 1.0 명세의 <a lt="willful violation">고의적 위반</a>으로, 구현이 HTML 요소(element)에
    대해 사용되는 네임스페이스에 대해 이 명세가 HTML에 도입하는 변경 사항을 여전히 지원하면서 레거시
    콘텐트와 호환되도록 하고자 하는 바람에 기인합니다. [[!XPATH]]
  </p>

  <hr />

  출력 메서드가 "html"인 경우 DOM으로 출력하는 XSLT 1.0 처리기는 (명시적으로 혹은 XSLT 1.0 기본
  규칙을 통해) 다음과 같이 영향을 받습니다:

  변환 프로그램이 네임스페이스 없이 요소(element)를 출력한다면, 처리기는, 해당 DOM 요소(element)
  노드를 구성하기에 앞서, 요소(element)의 네임스페이스를 <a lt="HTML namespace">HTML 네임스페이스</a>,
  요소(element)의 <a lt="Converting a string to ASCII lowercase">ASCII-소문자</a> 로컬 이름, 
  요소(element)에 네임스페이스 없는 속성(attribute)들의 <a lt="Converting a string to ASCII lowercase">ASCII-소문자</a>
  이름으로 변경해야(must) 합니다.

  <p class="note">
    이; 요구사항은 XSLT 1.0 명세의 <a lt="willful violation">고의적 위반</a>으로, 이 명세가 DOM 기반 
    XML 변경과 호환되지 않는 방법으로 네임스페이스와 대소문자를 구별하는 HTML의 규칙을 변경하기
    때문입니다.(출력을 직렬화하는 처리기는 영향을 받지 않습니다.) [[XSLT]]
  </p>

  <hr />

  이 명세는 XSLT 처리가가 <a lt="HTML parser">HTML 해석기</a> 인프라와 상호작용 하는 방법을 정확하게
  명시하지 않습니다(예를 들어, XSLT 처리기가  <a lt="stack of open elements">열린 요소(element) 스택</a>에
  임의의 요소(element)를 밀어 넣는 것처럼 수행하는지 여부). 하지만, XSLT 처리기는 그것이 성공적으로
  완료되면 <a lt="stops parsing">해석을 중지</a>해야(must)하고, <a lt="current document readiness">현재 문서 준비상태</a>를
  먼저 "<code>interactive</code>"로 설정해야(must)하고 그 후 그것이 취소되면 "<code>complete</code>"로 
  설정해야(must)합니다.

  <hr />

  이 명세는 XSLT가 <a lt="navigation">탐색</a> 알고리즘과 상호작용하는 방법, <a lt="event loop">이벤트 루프</a>와
  맞추는 방법, 오류 페이지가 처리되는 방법(예를 들어, XSLT 오류가 누적된 XSLT 출력을 대체하는 것인지 
  또는 인라인으로 렌더링 되는지 등)을 지정하지 않습니다.

  <p class="note">
    <a href="#interaction-of-script-elements-and-xslt"><code>script</code> 요소(element) 섹션</a>에
    XSLT와 HTML의 상호작용, 그리고 <a href="#interaction-of-template-elements-with-xslt-and-xpath"><code>template</code>
    요소(element) 섹션</a>에 XSLT, XPath, HTML의 상호작용에 관한 추가적인 비규범적인 사족이 있습니다.
  </p>

<h3 id="case-sensitivity-and-string-comparison">대소문자 구별과 문자열 비교</h3>

  <dfn lt="case-sensitive">대소문자 구분</dfn> 방법으로 두 문자열을 비교하는 것은 코드 지점에 대해
  코드 지점을 정확하게 비교한다는 것을 의미합니다.

  <dfn lt="ASCII case-insensitive">ASCII 대소문자 비구분</dfn> 방법으로 두 문자열을 비교하는 것은 
  U+0041에서 U+005A까지 범위의 문자(즉, 라틴 대문자 A부터 라틴 대문자 Z까지)와 U+0061에서 U+007A까지 
  범위에 해당하는 문자(즉, 라틴 소문자 A부터 라틴 소문자 Z까지)들이 모두 일치하는 것으로 
  간주되는 것을 제외하고, 코드 지점에 대해 코드 지점을 정확하게 비교한다는 것을 의미합니다.

  <dfn lt="compatibility caseless">호환되는 대소문자 무(無)구별</dfn> 방법으로 두 문자열을 비교하는 
  것은 언어별 맞춤없이 두 문자열을 비교하기 위해 유니코드 <i lt="compatibility caseless match">호환되는 대소문자 무(無)구별 일치</i>
  연산을 사용하는 것을 의미합니다. [[!UNICODE]]

  달리 명시되지 않는 한, 문자열 비교는 <a lt="case-sensitive">대소문자 구분</A>방법으로 수행되어야(must)
  합니다.

  <dfn lt="Converting a string to ASCII uppercase">문자열을 ASCII 대문자로 변환</dfn>하는 것은 
  U+0061에서 U+007A 범위 (즉, 라틴 소문자 A부터 라틴 소문자 Z) 내 모든 문자를 U+0041에서 U+005A 범위
  (즉, 라틴 대문자 A부터 라틴 대문자 Z) 내 해당하는 문자로 바꾸는 것을 의미합니다.

  <dfn lt="Converting a string to ASCII lowercase">문자열을 ASCII 소문자로 변환</dfn>하는 것은
  U+0041에서 U+005A 범위 (즉, 라틴 대문자 A부터 라틴 대문자 Z) 내 모든 문자를 U+0061에서 U+007A 범위
  (즉, 라틴 소문자 A부터 라틴 소문자 Z) 내 해당하는 문자로 바꾸는 것을 의미합니다.

  문자열 <var>pattern</var>이 <var>s</var>보다 길지 않고 <var>s</var>를 <var>pattern</var>의 길이로 
  잘라내는 것이 두 문자열을 서로 일치하게 하는 경우 문자열 <var>pattern</var>은 문자열 <var>s</var>에 
  대한 <dfn lt="prefix match">접두어 일치</dfn>입니다.

<h3 id="common-microsyntaxes">공통 마이크로문법</h3>

  HTML에는 날짜나 숫자 같은, 특정한 데이터 유형을 허용하는 다양한 위치가 있습니다. 이 섹션은 그러한 
  형식의 콘텐트에 대한 적합성 기준과 그것들을 해석하는 방법을 기술합니다.

  <p class="note">
    구현자는 아래에 설명된 문법의 해석을 구현하기 위해 사용하는 것으로 간주될 수 있는 서드파티 
    라이브러리들을 주의 깊게 검토하도록 강력하게 권장됩니다. 예를 들어, 날짜 라이브러리는, 오류 처리
    동작이 종종 이 명세에 사용된 것과 유사항 날짜 구문을 기술하는 명세에 정의 되어 있지 않기 때문에, 
    이 명세에 요구된 것과 다른 오류 처리 동작을 구현할 수 있고, 따라서 구현자는 오류를 처리하는 
    방법에서 크게 달라지는 경향이 있습니다.
  </p>

<h4 id="common-parser-idioms">공통 해석기 표현</h4>

  <dfn lt="space characters">공백 문자</dfn>는 이 명세의 목적에 따라, U+0020 공백(space), U+0009 탭
  문자(tab), U+000A 라인피드 (LF), U+000C 서식 문자 (FF), and U+000D 캐리지 리턴 (CR)입니다.

  <dfn lt="white_space|white_space characters">여백 문자</dfn>는 유니코드 <code>PropList.txt</code> 
  데이터 파일에 있는 유니코드 속성(property) "White_Space"을 가지는 문자 입니다. [[!UNICODE]]

  <p class="note">
    이 문자는 <code>Unicode.txt</code> 데이터 파일에 "Bidi_Class" 속성(property)의 "White_Space" 값
    (약칭 "WS")과 혼동되지 않아야(should) 합니다.
  </p>

  <dfn lt="control characters">제어 문자</dfn>는 유니코드 "General_Category" 속성(property)이 유니코드 
  유니코드 <code>UnicodeData.txt</code> 데이터 파일의 "Cc" 값을 가지는 문자입니다. [[!UNICODE]]

  <dfn lt="uppercase ASCII letters">대문자 ASCII 글자</dfn>는 U+0041 라틴 대문자 A부터 U+005A 라틴
  대문자 Z까지 범위 내 문자입니다.

  <dfn lt="lowercase ASCII letters">소문자 ASCII 글자</dfn>는 U+0061 라틴 소문자 A부터 U+007A 라틴
  소문자 Z까지 범위 내 문자입니다.

  <dfn lt="ASCII digits">ASCII 숫자</dfn>는 U+0030 숫자 0에서 U+0039 숫자 9까지 범위 내 문자입니다.

  <dfn lt="alphanumeric ASCII characters">영숫자 ASCII 문자</dfn>는 <a lt="uppercase ASCII letters">대문자 ASCII 글자</a>,
  또는 <a lt="lowercase ASCII letters">소문자 ASCII 글자</a>, 또는 <a lt="ASCII digits">ASCII 숫자</a>입니다.

  <dfn lt="ASCII hex digits">ASCII 16진수</dfn>는 U+0030 숫자 0부터 U+0039 숫자9, U+0041 라틴 대문자
  A부터 U+0046 라틴 대문자 F, U+0061 라틴 소문자 A부터 U+0066 라틴 소문자 F 범위 내 문자입니다.

  <dfn lt="uppercase ASCII hex digits">대문자 ASCII 16 진수</dfn>는 U+0030 숫자 0부터 U+0039 숫자 9 
  그리고 U+0041 라틴 대문자 A부터 U+0046 라틴 대문자 F까지 범위 내 문자입니다.

  <dfn lt="lowercase ASCII hex digits">소문자 ASCII 16 진수</dfn>는 U+0030 숫자 0부터 U+0039 숫자 9
  그리고 U+0061 라틴 소문자 A부터 U+0066 라틴 소문자 F까지 범위 내 문자입니다.

  아래 설명된 일부 마이크로 해석기는 문자열이 해석되고 있도록 유지하고 있는 <var>input</var> 변수와 
  <var>input</var>에서 해석하기 위한 다음 문자를 가리키는 <var>position</var> 변수를 가지는 패턴을
  따릅니다.

  이 패턴을 기반으로하는 해석기의 경우, 유저 에이전트가 <dfn lt="collect a sequence of characters">일련의 문자를 수집</dfn>하도록
  요구하는 단계는, 수집될 수 있는 문자의 집합이 되는 <var>characters</var>를 가지고, 다음 알고리즘을 
  수행해야(must) 함을 의미합니다:

  1. <var>input</var>과 <var>position</var>를 이 단계들을 호출하는 알고리즘에 동일한 이름의 것들로서
      같은 변수가 되도록 합니다.
  2. <var>result</var>를 빈 문자열이 되게 합니다.
  3. <var>position</var>이 <var>input</var>의 끝을 지나치지 않고 <var>position</var>에 위치한 문자가
      <var>characters</var>의 하나인 경우, <var>result</var>의 끝에 문자를 추가하고 <var>input</var>
      내 다음 문자로 <var>position</var>을 전진시킵니다.
  4. <var>result</var>를 반환합니다.

  <dfn lt="skip whitespace">여백 문자 건너뛰기</dfn> 단계는 유저 에이전트가 <a lt="space characters">공백 문자</a>인
  <a lt="collect a sequence of characters">일련의 문자를 수집</a>해야(must) 한다는 것을 의미합니다. 
  수집 된 문자는 사용되지 않습니다.

  유저 에이전트가 문자열에서 <dfn lt="stripped line breaks|strip line breaks">줄 바꿈을 비워낼</dfn>
  경우, 유저 에이전트는 그 문자열에서 U+000A 라인피드 (LF)와 U+000D 캐리지 리턴 (CR)을 제거해야(must)
  합니다.

  유저 에이전트가 문자열에서 <dfn lt="strip leading and trailing whitespace|stripping leading and trailing whitespace|leading and trailing whitespace stripped">앞뒤 여백 문자를 비워낼</dfn> 
  경우, 유저 에이전트는 문자의 시작과 끝에 있는 모든 <a lt="space characters">공백 문자</a>를 제거해야(must) 
  합니다.

  유저 에이전트가 문자열 내 <dfn lt="stripping and collapsing whitespace|strip and collapse whitespace">여백 문자를 들어내고 병합하는</dfn> 경우,
  그 문자열 내 일련의 하나 이상의 연속적인 <a lt="space characters">공백 문자</a>를 단일 U+0020 공백 
  문자로 바꾸고, 그 후 그 문자열에서 <a lt="strip leading and trailing whitespace|stripping leading and trailing whitespace|leading and trailing whitespace stripped">앞뒤 여백 문자를 비워내</a>야(must) 합니다.

  유저 에이전트가 특정 구분 문자 <var>delimiter</var>로 <dfn lt="strictly splitting the string|strictly split a string|strictly split">문자열을 엄격하게 분할해</dfn>야
  하는 경우, 다음 알고리즘을 사용해야(must)합니다:

  1. <var>input</var>을 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <var>tokens</var>를 초기에 비어있는, 정렬된 토큰의 목록으로 둡니다.
  4. <var>position</var>가 <var>input</var>의 끝을 지나치지 않은 동안:
      1. <var>delimiter</var> 문자가 아닌 <a lt="Collect a sequence of characters">일련의 문자들을 수집</a>합니다.
      2. 이전 단계에서 수집된 문자를 <var>tokens</var>에 추가합니다.
      3. <var>input</var> 내 다음 문자로 <var>position</var>을 전진시킵니다.
  5. <var>tokens</var>을 반환합니다.

  <p class="note">
    <a lt="split a string on spaces">공백</a>과 <a lt="split a string on commas">쉼표</a> 문자로 분할하는 
    특수한 경우에 대해, 이 알고리즘은 적용되지 않습니다(그러한 알고리즘은 <a lt="strip leading and trailing whitespace">여백 트리밍</a> 
    역시 수행합니다).
  </p>

<h4 id="sec-boolean-attributes">불리언 속성(attribute)</h4>

  여러 속성(attribute)들이 <dfn lt="boolean attribute|boolean attributes">불리언 속성(attribute)</dfn>입니다.
  요소(element)에 불리언 속성(attribute)의 존재는 true 값을 나타내고, 속성(attribute)의 부재는 false 
  값을 나타냅니다.

  속성(attribute)이 존재한다면, 그 값은 빈 문자열 혹은 속성(attribute)의 정식 이름에 대해, 앞 뒤 여백
  없이 <a lt="ASCII case-insensitive">ASCII 대소문자 구분 없이</a> 일치하는 값이어야(must) 합니다.

  <p class="note">
    "true"와 "false" 값은 <a lt="boolean attributes">불리언 속성(attribute)</a>에 허용되지 않습니다.
    false 값을 나타내려면 속성을 모두 생략해야(has to) 합니다.
  </p>

  <div class="example">
    여기 checked와 disabled인 checkbox의 예가 있습니다. <code>checked</code>와 <code>disabled</code> 
    속성(attribute)은 <a lt="boolean attributes">불리언 속성(attribute)</a>입니다.

    <pre highlight="html">&lt;label>&lt;input type=checkbox checked name=cheese disabled> Cheese&lt;/label></pre>

    이것은 이렇게 동동하게 작성될 수 있습니다:

    <pre highlight="html">&lt;label>&lt;input type=checkbox checked=checked name=cheese disabled=disabled> Cheese&lt;/label></pre>

    또한 혼합 방식도 가능합니다; 다음은 여전히 동등합니다:

    <pre highlight="html">&lt;label>&lt;input type='checkbox' checked name=cheese disabled=""> Cheese&lt;/label></pre>
  </div>

<h4 id="keywords-and-enumerated-attributes">키워드와 열거 속성(attribute)</h4>

  일부 속성(attribute)은 키워드의 집합에서 하나를 취하는 것으로 정의됩니다. 그러한 속성(attribute)을
  <dfn lt="enumerated attributes">열거 속성</dfn>이라고 부릅니다. 키워드는 각각 특정 <em>상태</em>에
  매핑시키기 위해 정의됩니다 (몇몇 키워드는 동일한 상태로 매핑될 수 있고, 이 경우 일부 키워드는 서로의 
  유의어 입니다; 추가적으로, 일부 키워드는 부적합하다 불릴 수 있고, 전통적인 이유로 이 명세에만 존재합니다.)
  게다가, 두 기본 상태가 주어질 수 있습니다. 첫 번째는 <dfn lt="invalid value default"><i>유효하지 않은 기본 값</i></dfn>,
  두 번째는 <dfn lt="missing value default"><i>누락된 기본 값</i></dfn>입니다.

  열거 속성이 명시된다면, 속성의 값은 앞뒤 여백 없이, 부적합하다 불리지 않는 주어진 키워드 중 하나에 
  <a lt="ASCII case-insensitive">ASCII 대소문자 구분 없이</a> 일치 되어야(must) 합니다.

  속성이 명시되는 경우, 그 값이 주어진 키워드 중 하나에 <a>ASCII 대소문자 구분 없이</a> 일치한다면
  그 키워드의 상태는 속성(attribute)이 나타내는 상태입니다. 속성(attribute) 값이 주어진 키워드 중
  일치하는 것이 없고 속성이 <i>유효하지 않은 기본 값</i>을 가진다면, 속성(attribute)은 그 상태를
  나타냅니다. 그렇지 않고, 속성(attribute) 값이 키워드에 일치하는 것이 없고 정의된 <i>누락된 기본 값</i> 
  상태가 있다면, <em>그것</em>은 속성(attribute)에 의해 나타내어지는 상태 입니다. 그렇지 않으면,
  기본 값은 없고, 유효하지 않은 값은 어떤 상태도 나타내지 않음을 의미합니다.

  속성(attribute)이 명시되지 <em>않은</em> 경우, 정의된 <i>누락된 기본 값</i> 상태가 있다면, 그것은
  (누락된) 속성(attribute)에 의해 나타내어지는 상태입니다. 그렇지 않으면, 속성(attribute)의 부재는
  나타내어지는 상태가 없음을 의미합니다.

  <p class="note">빈 문자열은 유효한 키워드가 될 수 있습니다.</p>

<h4 id="numbers">숫자</h4>

<h5 id="signed-integers">부호있는 정수</h5>

  문자열이 하나 이상의 <a lt="ASCII digits">ASCII 숫자</a>로 구성되고, 선택적으로 U+002D HYPHEN-MINUS 
  문자 (-)가 접두어로 붙는다면, <dfn lt="valid integer|valid integers">유효한 정수</dfn>입니다.

  U+002D HYPHEN-MINUS (-) 접두어가 없는 <a lt="valid integer">유효한 정수</a>는 그 숫자의 문자열에 
  의한 10진수 숫자를 나타냅니다. U+002D HYPHEN-MINUS (-) 접두어가 <em>있는</em> <a lt="valid integer">유효한 정수</a>는
  0에서 뺀, U+002D HYPHEN-MINUS 다음에 있는 숫자의 문자열에 의한 10진수 숫자를 나타냅니다. 

  <dfn lt="parse token as an integer|parse it as an integer|rules for parsing integers|rules for parsing integer|rules for parsing signed integers">숫자 해석에 대한 규칙</dfn>은 다음 알고리즘에 주어진 것과 같습니다.
  이 알고리즘이 호출 될 때, 단계는 값을 반환하는 첫 번째 단계에서 취소하는, 주어진 순서에 따라야(must) 
  합니다. 이 알고리즘은 정수나 오류를 반환할 것입니다.

  1. <var>input</var>을 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키게 하여, <var>input</var>을 가리키게 합니다.
  3. <var>sign</var>이 "양" 값을 가지게 합니다.
  4. <a lt="Skip whitespace">여백을 건너뜁니다</a>.
  5. <var>position</var>이 <var>input</var>의 끝을 지났다면, 오류를 반환합니다.
  6. <var>position</var>에 의해 가리켜진 문자(첫번째 문자)가 U+002D HYPHEN-MINUS 문자 (-)라면:
      1. <var>sign</var>을 "음"으로 둡니다.
      2. <var>position</var>을 다음 문자로 전진시킵니다.
      3. <var>position</var>이 <var>input</var>의 끝을 지났다면, 오류를 반환합니다.

      그렇지 않고, <var>position</var>에 의해 가리켜진 문자(첫번째 문자)가 U+002B PLUS 부호 문자 (+)
      라면:

      1. <var>position</var>을 다음 문자로 전진시킵니다. ("<code>+</code>"는 무시되지만, 이는 부적합
          합니다.)
      2. <var>position</var>이 <var>input</var>의 끝을 지났다면, 오류를 반환합니다.
  7. <var>position</var>에 의해 가리켜진 문자가 <a lt="ASCII digits">ASCII 숫자</a>가 아니라면, 
      오류를 반환합니다.
  8. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>하고,
      10진수 정수로 결과로 나온 시퀀스를 해석합니다. <var>value</var>를 그 정수로 둡니다.
  9. <var>sign</var>이 "양"이라면, <var>value</var>를 반환하고, 그렇지 않으면 0에서 <var>value</var>를 
      뺀 결과를 반환합니다.


<h5 id="non-negative-integers">음이 아닌 정수</h5>

  문자열이 하나 이상의 <a lt="ASCII digits">ASCII 숫자</a>로 구성된다면 
  <dfn lt="valid non-negative integer">유효한 음이 아닌 정수</dfn>입니다.

  <a lt="valid non-negative integer">유효한 음이 아닌 정수</a>는 그 숫자의 문자열에 의해 10 진수로 
  나타내어지는 숫자를 나타냅니다.

  <dfn lt="parse that attribute's value|rules for parsing non-negative integers">음이 아닌 정수 해석에 대한 규칙</dfn>은 다음 알고리즘에 주어진 것과 같습니다.
  이 알고리즘이 호출될 때, 단계는 값을 반환하는 첫 번째 단계에서 중단하여, 주어진 순서에 따라야(must) 
  합니다. 이 알고리즘은 0이나 양의 정수, 혹은 오류를 반환할 것입니다.

  1. <var>input</var>을 해석된 문자열로 둡니다.
  2. <var>value</var>를 <a lt="rules for parsing integers">정수 해석에 대한 규칙</a>을 사용하여 
      <var>input</var>을 해석한 결과로 둡니다.
  3. <var>value</var>가 오류라면, 오류를 반환합니다.
  4. <var>value</var>가 0보다 작다면, 오류를 반환합니다.
  5. <var>value</var>를 반환합니다.

<h5 id="floating-point-numbers">부동 소수점 수</h5>

  문자열이 다음으로 구성된다면 <dfn lt="valid floating-point number">유효한 부동소수점 수</dfn>입니다:

  1. 선택적으로, U+002D HYPHEN-MINUS 문자 (-).
  2. 주어진 순서에 따라, 다음 중 하나 혹은 모두:
      1. 일련의 하나 이상의 <a lt="ASCII digits">ASCII 숫자</a>.
      2. 주어진 순서에 따라 다음 둘 모두:
          1. 단일 U+002E 마침표 문자 (.).
          2. 일련의 하나 이상의 <a lt="ASCII digits">ASCII 숫자</a>.
  3. 선택적으로:
      1. U+0065 라틴 소문자 E (e) 또는 U+0045 라틴 대문자 E (E).
      2. 선택적으로, U+002D HYPHEN-MINUS 문자 (-) 또는 U+002B PLUS 부호 문자 (+).
      3. 일련의 하나 이상의 <a lt="ASCII digits">ASCII 숫자</a>.

  <a lt="valid floating-point number">유효한 부동소수점 수</a>는 유효숫자에 10의 지수의 거듭 제곱과 
  곱하여 얻어진 숫자를 나타내고, 여기서 유효숫자는 10진수로 해석되는 (소수점과 소수점 이후 숫자가
  있다면 이를 포함하여, 그리고 전체 숫자가 U+002D HYPHEN-MINUS 문자 (-)로 시작하고 숫자가 0이 아니라면 
  음수로서 유효숫자를 해석하여) 첫번째 숫자이고, 지수는 E 이후 숫자가 있다면 그 숫자 (E와 숫자 사이에 
  U+002D HYPHEN-MINUS (-) 문자가 있고 숫자가 0이 아니라면 음수로 해석되거나, E와 숫자 사이에 U+002B
  PLUS 부호 문자가 있다면 이를 무시하여)입니다. E가 없다면 지수는 0으로 간주됩니다.

  <p class="note">Infinity와 Not-a-Number (NaN) 값은 <a lt="valid floating-point numbers">유효한 부동소수점 수</a>가 아닙니다.</p>

  <dfn lt="best floating-point number">부동 소수점 수로서 숫자 <var>n</var>의 가장 잘 표현된 표현</dfn>은 
  ToString(<var>n</var>)을 수행하여 얻어진 문자열입니다. 추상 연산 ToString은 고유하게 결정되지 않습니다.
  특정 값에 대해 ToString에서 얻어질 수 있는 가능한 여러 문자열이 있는 경우, 유저 에이전트는 항상 그
  값에 대한 동일한 문자열을(다른 유저 에이전트에 의해 사용될 수 있는 값과 다를 수 있지만) 반환해야(must) 
  합니다.

  <dfn lt="rules for parsing floating-point number values">부동 소수점 수 값 해석에 대한 규칙</dfn>은 다음 알고리즘에 주어진 것과 같습니다.
  이 알고리즘은 무언가를 반환하는 첫 번째 단계에서 중단되어야(must) 합니다. 이 알고리즘은 숫자나 
  오류를 반환할 것입니다.

   1. <var>input</var>을 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <var>value</var>가 값 1을 가지게 합니다.
  4. <var>divisor</var>가 값 1을 가지게 합니다.
  5. <var>exponent</var>가 값 1을 가지게 합니다.
  6. <a lt="Skip whitespace">여백을 건너뜁니다</a>.
  7. <var>position</var>이 <var>input</var>의 끝을 지났다면, 오류를 반환합니다.
  8. <var>position</var>에 의해 가리켜진 문자가 U+002D HYPHEN-MINUS 문자 (-) 라면:
      1. <var>value</var>와 <var>divisor</var>를 -1로 변경합니다.
      2. <var>position</var>을 다음 문자로 전진시킵니다.
      3. <var>position</var>이 <var>input</var>의 끝을 지났다면, 오류를 반환합니다.

      그렇지 않고, <var>position</var>에 의해 가리켜진 문자(첫 번째 문자)가 U+002B PLUS 부호 문자 (+)
      라면:

      1. <var>position</var>을 다음 문자로 전진시킵니다. ("<code>+</code>"는 무시되지만, 이는 부적합
          한 것입니다.)
      2. <var>position</var>이 <var>input</var>의 끝을 지났다면, 오류를 반환합니다.

  9. <var>position</var>에 의해 가리켜진 문자가 U+002E 마침표 문자 (.)이고, 그 문자가 <var>input</var>의
      마지막 문자가 아니며, <var>position</var>에 의해 가리켜진 문자 이후 문자가 
      <a lt="ASCII digit">ASCII 숫자</a>라면, <var>value</var>를 0으로 설정하고 <i>분수</i>로 라벨링
      된 단계로 건너뜁니다.
  10. <var>position</var>에 의해 가리켜진 문자가 <a lt="ASCII digit">ASCII 숫자</a>가 아니라면, 오류를
      반환합니다.
  11. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>하고,
      10 진수 정수로 결과로 나온 시퀀스를 해석합니다. 그 정수에 <var>value</var>를 곱합니다.
  12. <var>position</var>이 <var>input</var>의 끝을 지났다면, <i>변환</i>으로 라벨링 된 단계로 
      건너뜁니다.
  13. <i>분수 </i>: <var>position</var>에 의해 가리켜진 문자가 U+002E 마침표 문자 (.) 라면, 이 하위  
      단계들을 수행합니다:
      1. <var>position</var>을 다음 문자로 전진시킵니다.
      2. <var>position</var>이 <var>input</var>의 끝을 지났거나, <var>position</var>에 의해 가리켜진 
          문자가 <a lt="ASCII digit">ASCII 숫자</a>, 혹은 U+0065 라틴 소문자 E (e), 혹은 U+0045 라틴 
          대문자 E (E)가 아니라면, <i>변환</i>으로 라벨링 된 단계로 건너뜁니다.
      3.  <var>position</var>에 의해 가리켜진 문자가 U+0065 라틴 소문자 E (e) 또는 U+0045 라틴 대문자
          E (E)라면, 이 하위 단계들의 나머지를 건너뜁니다.
      4. <i>분수 반복</i>: <var>divisor</var>에 10을 곱합니다.
      5. <var>position</var>에 의해 가리켜진 문자의 값을 10진수 숫자 (0..9)로 해석하고 
          <var>divisor</var>로 나누어진 값을 <var>value</var>에 추가합니다.
      6. <var>position</var>을 다음 문자로 전진시킵니다.
      7. <var>position</var>이 <var>input</var>의 끝을 지났다면, <i>변환</i>으로 라벨링 된 단계로 
          건너뜁니다.
      8. <var>position</var>에 의해 가리켜진 문자가 <a lt="ASCII digit">ASCII 숫자</a>라면, 이 하위 
          단계 내의 <i>분수 반복</i>으로 라벨링 된 단계로 건너뜁니다.
  14. <var>position</var>에 의해 가리켜진 문자가 U+0065 라틴 소문자 E (e) 혹은 U+0045 라틴 대문자 E 
      (E)라면, 이 하위 단계들을 수행합니다:
      1. <var>position</var>을 다음 문자로 전진시킵니다.
      2. <var>position</var>이 <var>input</var>의 끝을 지났다면, <i>변환</i>으로 라벨링 된 단계로 
          건너뜁니다.
      3. <var>position</var>에 의해 가리켜진 문자가 U+002D HYPHEN-MINUS 문자 (-)라면:
          1. <var>exponent</var>를 -1로 바꿉니다.
          2. <var>position</var>을 다음 문자로 전진시킵니다.
          3. <var>position</var>이 <var>input</var>의 끝을 지났다면, <i>변환</i>으로 라벨링 된 단계로 
              건너뜁니다.

          그렇지 않고, <var>position</var>에 의해 가리켜진 문자가 U+002B PLUS 부호 문자(+) 라면:

          1. <var>position</var>을 다음 문자로 전진시킵니다.
          2. <var>position</var>이 <var>input</var>의 끝을 지났다면, <i>변환</i>으로 라벨링 된 단계로 
              건너뜁니다.
      4. <var>position</var>에 의해 가리켜진 문자가 <a lt="ASCII digit">ASCII 숫자</a>가 아니라면, 
          <i>변환</i>으로 라벨링 된 단계로 건너뜁니다.
      5. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>하고, and interpret the
          10 진수 정수로 결과로 나온 시퀀스를 해석합니다. 그 정수에  <var>exponent</var>를 곱합니다.
      6. 10의 <var>exponent</var>제곱에 <var>value</var>를 곱합니다.
  15. <i>변환</i>: <var>S</var>를 0을 제외한 64 비트 배정도 부동 소수점 값이고, 두 특별한 값 2<sup>1024</sup>과
      -2<sup>1024</sup>를 포함한 IEEE 754의 집합으로 둡니다.
  16. <var>rounded-value</var>를, 두 개의 동일하게 가까운 값이 있다면 짝수 유효숫자를 선택하여, 
      <var>value</var>에 가장 가까운 <var>S</var> 내의 숫자로 둡니다. (이 목적에 대해 두 개의 특별한 
      값 2<sup>1024</sup>과 -2<sup>1024</sup>는 짝수 값을 가지는 것으로 간주됩니다.)
  17. <var>rounded-value</var>가 2<sup>1024</sup>나 -2<sup>1024</sup>라면, 오류를 반환합니다.
  18. <var>rounded-value</var>를 반환합니다.

<h5 id="percentages-and-dimensions">백분율과 길이</h5>

  <dfn lt="rules for parsing dimension values">치수 값 해석에 대한 규칙</dfn>은 다음 알고리즘에 
  주어진 것과 같습니다. 이 알고리즘이 호출 될 때, 단계는 값을 반환하는 첫 번째 단계에서 중단하여, 
  주어진 순서에 따라야(must) 합니다. 이 알고리즘은 0.0 이상의 숫자나 오류를 반환할 것입니다.
  수가 반환된다면, 백분율이나 길이와 같이 좀 더 세분화 됩니다.

  1. <var>input</var>을 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <a lt="Skip whitespace">여백을 건너뜁니다</a>.
  4. <var>position</var>이 <var>input</var>의 끝을 지났다면, 오류를 반환합니다.
  5. <var>position</var>에 의해 가리켜진 문자가 U+002B PLUS 부호 문자 (+)라면, <var>position</var>을
      다음 문자로 전진시킵니다.
  6. <var>position</var>이 <var>input</var>의 끝을 지났다면, 오류를 반환합니다.
  7. <var>position</var>에 의해 가리켜진 문자가 <a lt="ASCII digit">ASCII 숫자</a>가 아니라면, 오류를
      반환합니다.
  8. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>하고,
      10 진수 정수로 결과로 나온 시퀀스를 해석합니다. <var>value</var>를 그 수로 둡니다.
  9. <var>position</var>이 <var>input</var>의 끝을 지났다면, 길이로서 <var>value</var>를 반환합니다.
  10. <var>position</var>에 의해 가리켜진 문자가 U+002E 마침표 문자 (.)라면:
      1. <var>position</var>를 다음 문자로 전진시킵니다.
      2. <var>position</var>이 <var>input</var>의 끝을 지났거나, <var>position</var>에 의해 가리켜진
          문자가 <a lt="ASCII digits">ASCII 숫자</a>가 아니라면, 길이로서 <var>value</var>를 반환합니다.
      3. <var>divisor</var>가 값 1을 가지게 합니다.
      4. <i>분수 반복</i>: <var>divisor</var>에 10을 곱합니다.
      5. <var>position</var>에 의해 가리켜진 문자의 값을 10진수 숫자 (0..9)로 해석하고 
          <var>divisor</var>로 나누어진 값을 <var>value</var>에 추가합니다.
      6. <var>position</var>을 다음 문자로 전진시킵니다.
      7. <var>position</var>이 <var>input</var>의 끝을 지났다면, 길이로서 <var>value</var>를 반환합니다.
      8. <var>position</var>에 의해 가리켜진 문자가 <a lt="ASCII digits">ASCII 숫자</a>라면, 이 하위 
          단계 내의 <i>분수 반복</i>으로 라벨링 된 단계로 건너뜁니다.
  11. <var>position</var>이 <var>input</var>의 끝을 지났다면, 길이로서 <var>value</var>를 반환합니다.
  12. <var>position</var>에 의해 가리켜진 문자가 U+0025 PERCENT 부호 문자 (%)라면, 백분율로서 
      <var>value</var>를 반환합니다.
  13. 길이로서 <var>value</var>를 반환합니다.

<h5 id="non-zero-percentages-and-lengths">0이 아닌 백분율과 길이</h5>

  <dfn lt="rules for parsing non-zero dimension values">0이 아닌 치수 값 해석에 대한 규칙</dfn>은 다음 알고리즘에 주어진 것과 같습니다.
  이 알고리즘이 호출 될 때, 단계는 값을 반환하는 첫 번째 단계에서 중단하여, 주어진 순서에 따라야(must) 
  합니다. 이 알고리즘은 0.0 이상의 숫자나 오류를 반환할 것입니다. 수가 반환된다면, 백분율이나 길이와 
  같이 좀 더 세분화 됩니다.

  1. <var>input</var>을 해석되는 문자열로 둡니다.
  2. <var>value</var>를 <a lt="rules for parsing dimension values">치수 값 해석에 대한 규칙</a>을
      사용하여 <var>input</var>을 해석한 결과로 둡니다.
  3. <var>value</var>가 오류라면, 오류를 반환합니다.
  4. <var>value</var>가 0이라면, 오류를 반환합니다.
  5. <var>value</var>가 백분율이라면, <var>value</var>를 백분율로서 반환합니다.
  6. <var>value</var>를 길이로서 반환합니다.

<h5 id="lists-of-floating-point-numbers">부동 소수점 수 목록</h5>

  <dfn lt="valid list of floating-point numbers">부동 소수점 수의 유효한 목록</dfn>은 다른 문자(예를
  들어 <a lt="space characters">공백 문자</a>없이), U+002C 콤마 문자로 분리된 약간의 
  <a lt="valid floating-point numbers">유효한 부동 소수점 수</a>입니다. 또한, 주어질 수 있는 부동 
  소수점 수의 개수 혹은 허용된 값의 범위에 제한이 있을 수 있습니다.

  <dfn lt="rules for parsing a list of floating-point numbers">부동 소수점 수 목록 해석에 대한 규칙</dfn>은 다음과 같습니다:

  1. <var>input</var>을 해석되는 문자열로 둡니다
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <var>numbers</var>를 초기에 빈 부동 소수점 수 목록으로 둡니다. 이 목록은 이 알고리즘의 결과가
      될 것입니다.
  4. <a lt="space characters">공백 문자</a>, U+002C 콤마, U+003B 세미콜론 문자 인
      <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다. 이것은 앞선 선행 구분자를 
      건너뜁니다.
  5. <var>position</var>이 <var>input</var>의 끝을 지나지 않은 경우:
      1. <a lt="space characters">공백 문자</a>, U+002C 콤마, U+003B 세미콜론, <a lt="ASCII digits">ASCII 숫자</a>,
          U+002E 마침표, U+002D HYPHEN-MINUS 문자가 아닌 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다. 
          이것은 앞선 선행 선행 가비지를 건너뜁니다.
      2. <a lt="space characters">공백 문자</a>, U+002C 콤마, U+003B 세미콜론 문자가 아닌
          <a lt="Collect a sequence of characters">일련의 문자를 수집</a>하고, <var>unparsed number</var>를 
          결과로 둡니다.
      3. <var>number</var>를 <a lt="rules for parsing floating-point number values">부동 소수점 수 값 해석에 대한 규칙</a>을 
          사용하여 <var>unparsed number</var>를 해석한 결과로 둡니다.
      4. <var>number</var>가 오류라면, <var>number</var>을 0으로 설정합니다.
      5. <var>number</var>을 <var>numbers</var>에 첨부합니다.
      6. <a lt="space characters">공백 문자</a>, U+002C 콤마, U+003B 세미콜론 문자 인
          <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다. 이것은 앞선 선행 구분자를 
          건너뜁니다.
  6. <var>numbers</var>를 반환합니다.

<h5 id="lists-of-dimensions">치수 목록</h5>

  <dfn lt="rules for parsing a list of dimensions">치수 목록 해석에 대한 규칙</dfn>은 다음과 같습니다.
  이 규칙들은 숫자와 단위로 구성된 0개 이상의 목록을 반환하고, 단위는 <i>percentage</i>, <i>relative</i>,
  <i>absolute</i>입니다.

  1. <var>raw input</var>을 해석될 문자열로 둡니다.
  2. <var>raw input</var> 내 마지막 문자가 U+002C 콤마 문자 (,) 라면, <var>raw input</var>에서 그 
      문자를 제거합니다.
  3. <a lt="split a string on commas">콤마로 문자열 <var>raw input</var>를 분할</a>합니다. 
      <var>raw tokens</var>를 결과 토큰 목록으로 둡니다.
  4. <var>result</var>을 숫자/단위 쌍의 빈 목록으로 둡니다.
  5. <var>raw tokens</var> 내 각 토큰에 대해, 다음 하위 단계들을 수행합니다:
      1. <var>input</var>을 토큰으로 둡니다.
      2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
      3. <var>value</var>를 숫자 0으로 둡니다.
      4. <var>unit</var>을 <i>absolute</i>로 둡니다.
      5. <var>position</var>이 <var>input</var>의 끝을 지났다면, 단위를 <i>relative</i>로 설정하고 
          마지막 하위단계로 건너뜁니다.
      6. <var>position</var>에 있는 문자가 <a lt="ASCII digits">ASCII 숫자</a>라면, <a lt="ASCII digits">ASCII 숫자</a>인
          <a lt="Collect a sequence of characters">일련의 문자를 수집</a>하고, 10진수 정수로서 결과로 
          나온 시퀀스를 해석하고, <var>value</var>를 그 정수만큼 증가시킵니다.
      7. <var>position</var>에 있는 문자가 U+002E 마침표 문자 (.) 라면, 이 하위 단계들을 수행합니다:
          1. <a lt="space characters">공백 문자</a>와 <a lt="ASCII digits">ASCII 숫자</a>로 구성된 
              <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다. 
              <var>s</var>를 결과 시퀀스로 둡니다.
          2. <var>s</var> 내 모든 <a lt="space characters">공백 문자</a>를 제거합니다.
          3. <var>s</var>가 빈 문자열이 아니라면, 이 하위 단계들을 수행합니다:
              1. <var>length</var>를 <var>s</var> 내 문자(공백이 제거된 이후)의 수로 둡니다.
              2. <var>fraction</var>을 10 진수 정수로 <var>s</var>를 해석하고, 그 수를 
                  10<sup><var>length</var></sup>로 나눈 결과로 둡니다.
              3. <var>value</var>를 <var>fraction</var> 만큼 증가시킵니다.
      8. <a lt="Skip whitespace">여백을 건너뜁니다</a>.
      9. <var>position</var>에 있는 문자가 U+0025 PERCENT 부호 문자 (%)라면, <var>unit</var>을 
          <i>percentage</i>로 설정합니다.

          그렇지 않고, <var>position</var>에 있는 문자가 U+002A ASTERISK 문자 (*)라면, <var>unit</var>을
          <i>relative</i>로 설정합니다.

      10. <var>value</var>에 의해 주어진 수와 <var>unit</var>에 의해 주어진 단위로 구성된 
          <var>result</var>에 항목을 추가합니다.
  6. <var>result</var> 목록을 반환합니다.

<h4 id="dates-and-times">날짜와 시간</h4>

  <div class="note">
    이 명세는 날짜에 대한 [[ISO8601]] 표준의 공통 부분 집합에 따라 날짜와 시간을 <em>부호화</em>합니다.

    이는 부호화 된 날짜는 1582-03-01, 0033-03-27, 2016-03-01 와 같이 보이고, 날짜-시간은 1929-11-13T19:00Z,
    0325-06-03T00:21+10:30와 같이 보이는 것을 의미합니다. 형식은, 비록 일부분은 예를 들어 생일의 월과 
    일, 표준 시간대 정보가 없는 시간 등과 같이 표현하기 위해 선택적이기는 하지만, 대략 
    YYYY-MM-DDTHH:MM:SS.DD±HH:MM 입니다.

    시간은 24시간제를 사용하여 표현되고, 윤초를 표현하는 것은 오류입니다.

    날짜는 역산 0000년과 9999년 사이의 <a lt="proleptic Gregorian calendar">역산 그레고리력</a>으로 
    표현됩니다. 다른 해는 부호화될 수 없습니다.

    <a lt="proleptic Gregorian calendar">역산 그레고리력</a>은 1950년 이후로 전 세계적으로 가장 
    일반적인 달력이고, 1950년과 9999년 사이 날짜의 모든 사람들, 그리고 지난 수십 년 또는 수세기 동안 
    많은 사람들이 이해할 수 있습니다.

    그레고리력은 교황 그레고리 13세에 의해 율리우스력에 대한 대체로서 제안된 1582년과 중국 인민 
    공화국에 의해 채택된 1947년 사이에, 다른 나라, 다른 시간에 공식적으로 채택되었습니다.

    현재, 가까운 과거, 다음 몇 천년을 다루는, 대부분의 현실적인 목적을 위해, 이것은 문제없이 작동 할
    것입니다. 그레고리력 채택 전 날짜에 대해 - 예를 들어 러시아나 터키에서 1917년에 앞선, 영국 혹은 
    이후 아메리카 영국 식민지에서 1752년에 앞선, 스페인, 아메리카 스페인 식민지, 세계 나머지에서
    1582년에 앞선, 날짜는 그 때 쓰여진 것들과 일치하지 않을 것입니다.

    그레고리력을 기본 부호화로 사용하는 것은 다소 임의적인 선택입니다. 많은 다른 달력이 사용 되었거나
    사용되고 있고, 관심있는 독자는 웹에 대한 정보를 찾아야(should) 합니다.

    (작성자를 위한) 형식에서 <a href="#date-time-and-number-formats">날짜, 시간, 숫자 형식</a>의 논의,
    <a href="#implementation-notes-regarding-localization-of-form-controls">폼 컨트롤의 지역화에 관한 
    구현 노트</a>, <{time}> 요소(element) 또한 참고하세요.
  </div>

  다음 알고리즘에서, 
  <dfn lt="number of days in month month of year year"><var>year</var></dfn>년의 <var>month</var>월 내 날짜</dfn>는: 
  <var>month</var>가 1, 3, 5, 7, 8, 10, 12라면 <em>31</em>; <var>month</var>가 4, 6, 9, 11이라면 <em>30</em>;
  <var>month</var>가 2이고 <var>year</var>가 400으로 나누어지는 수이거나 혹은 <var>year</var>가
  4로 나누어지지만 100으로는 나누어지지 않는 수라면 <em>29</em>; 그렇지 않으면 <em>28</em> 입니다. 
  이것은 그레고리력에서 윤년을 고려합니다. [[GREGORIAN]]

  <a lt="ASCII digits">ASCII 숫자</a>가 이 섹션에서 정의된 날짜와 시간 구문에 사용되는 경우, 그것들은
  10진수 숫자로 표현됩니다.

  <p class="note">
    여기에 설명된 형식은 해당하는 ISO8601의 하위 집합이 되도록 의도된 것이지만, 이 명세는 ISO8601보다
    훨씬 더 자세히 해석 규칙을 정의합니다.
    따라서 구현자는 아래 설명된 해석 규칙을 구현하기 위해 날짜 해석 라이브러리들을 사용하기 전에 
    신중하게 검토할 것이 권장됩니다; ISO8601 라이브러리는 정확히 동일한 방식으로 날짜와 시간을 해석하지
    않을 수 있습니다. [[ISO8601]]
  </p>

  이 명세가 <dfn lt="proleptic Gregorian calendar">역산 그레고리력</dfn>을 언급하는 경우, 그것은 
  거꾸로 1년까지 추론한, 현대 그레고리력을 의미합니다. <a lt="proleptic Gregorian calendar">역산 그레고리력</a>에서
  날짜는, 때때로 명시적으로 <dfn lt="proleptic-Gregorian date">역산 그레고리 날짜</dfn>로 언급되는,
  그 달력이 해당 시간(혹은 장소)에서 사용 중이지 않은 경우에도, 그 달력을 사용하여 설명되는 것입니다.
  [[GREGORIAN]]

<h5 id="months">월</h5>

  <dfn lt="month">월</dfn>은 표준시간대 정보가 없고 연, 월을 초과하는 날짜 정보가 없는 
  특정한 <a lt="proleptic-Gregorian date">역산 그레고리 날짜</a>로 구성됩니다. [[GREGORIAN]]

  문자열은 주어진 순서에 따라 다음 구성요소로 구성된다면 <var>year</var>년과 <var>month</var>월을 
  나타내는 <dfn lt="valid month string">유효한 월 문자열</dfn>입니다.:

  1. <var>year</var>&nbsp;&gt;&nbsp;0 인 경우, <var>year</var>를 나타내는, 4개 이상의 
      <a lt="ASCII digits">ASCII 숫자</a>
  2. U+002D HYPHEN-MINUS 문자 (-)
  3. 1&nbsp;&le;&nbsp;<var>month</var>&nbsp;&le;&nbsp;12 범위에서, <var>month</var>월을 나타내는
      2개의 <a lt="ASCII digits">ASCII 숫자</a>.

  <p class="example">
    예를 들어, 2005년 2월은 2005-02로 부호화 되고, 33AD년 3월은(역산 그레고리 날짜로) 
    <code>0033-03</code>로 부호화 됩니다. <code>325-03</code> 표현은 325년 3월을 의미하지 <em>않고</em>,
    그것은 연도에 대해 4자리 숫자를 가지지 않기 때문에 오류입니다.
  </p>

  <dfn lt="parsing a month string|parse a month string|parsing a month">월 문자열을 해석</dfn>하기 위한 규칙은 다음과 같습니다. 
  이것은 연도와 월을 반환하거나 혹은 아무 것도 반환하지 않을 것입니다. 어느 시점에 알고리즘이 
  "실패"라고 말한다면, 이것은 그 시점에 중단되고 아무 것도 반환하지 않음을 의미합니다.

  1. <var>input</var>을 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <var>year</var>와 <var>month</var>를 얻기 위해 <a lt="parse a month component">월 컴포넌트를 해석</a>합니다.
      이것이 아무 것도 반환하지 않는다면, 실패입니다.
  4. <var>position</var>이 <var>input</var>의 끝을 지나지 <em>않으</em>면, 실패입니다.
  5. <var>year</var>와 <var>month</var>를 반환합니다.

  <var>input</var> 문자열, <var>position</var>이 주어진 <dfn lt="parse a month component">월 컴포넌트를 해석</dfn>하기
  위한 규칙은 다음과 같습니다. 이것은 연도와 월을 반환하거나 아무 것도 반환하지 않을 것입니다. 어느 
  시점에 알고리즘이 "실패"라고 말한다면, 이것은 그 시점에 중단되고 아무 것도 반환하지 않음을 의미합니다.

  1. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다.
      수집된 시퀀스가 최소 4 글자가 아니라면 실패입니다. 그렇지 않으면, 10 진수 정수로 결과 시퀀스를
      해석합니다. 그 숫자를 <var>year</var>로 둡니다.
  2. <var>year</var>가 0보다 큰 수가 아니면, 실패입니다.
  3. <var>position</var>이 <var>input</var>의 끝을 지났거나 <var>position</var>에 있는 문자가 U+002D 
      HYPHEN-MINUS 문자가 아니라면, 실패입니다. 그렇지 않으면, <var>position</var>를 한 글자 앞으로 
      이동합니다.
  4. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다.
      수집된 시퀀스가 정확히 2글자가 아니라면 실패입니다. 그렇지 않으면, 10 진수 정수로 결과 시퀀스를
      해석합니다. 그 숫자를 <var>month</var>로 둡니다.
  5. <var>month</var>가 1&nbsp;&le;&nbsp;<var>month</var>&nbsp;&le;&nbsp;12 범위의 숫자가 아니라면,
      실패입니다.
  6. <var>year</var>과 <var>month</var>를 반환합니다.

<h5 id="sec-dates">날짜</h5>

  <dfn for="dates" lt="date|dates">날짜</dfn>는 연, 월, 일로 구성되는 표준시간대가 없는 특정한 
  <a lt="proleptic-Gregorian date">역산 그레고리 날짜</a>로 구성됩니다. [[GREGORIAN]]

  문자열은 나타내는 주어진 순서에 따라 다음 구성요소로 구성된다면, <var>year</var>년, 
  <var>month</var>월, <var>day</var>일을 나타내는 
  <dfn lt="valid date string">유효한 날짜 문자열</dfn>입니다:

  1. <var>year</var>과 <var>month</var>를 나타내는 <a lt="valid month string">유효한 월 문자열</a>
  2. U+002D HYPHEN-MINUS 문자 (-)
  3. 1&nbsp;&le;&nbsp;<var>day</var>&nbsp;&le;&nbsp;<var>maxday</var>범위 내의 <var>day</var>를 
      나타내는 두 개의 <a lt="ASCII digits">ASCII 숫자</a>로, <var>maxday</var>는 
      <a lt="number of days in month month of year year"><var>year</var>년 <var>month</var>월의
      날짜의 수</a>.

  <p class="example">
    예를 들어, 2016 2월 29일은 2016-02-29로 부호화 되고, 33AD년 3월 3일(역산 그레고리 날짜 같은)은
    <code>0033-03-03</code>로 부호화 됩니다. <code>325-03-03</code> 표현은 325년 3월 3일을 의미하지
    <em>않고</em>, 이는 연도가 4자리 숫자를 가지지 않기 때문에 오류입니다.
  </p>

  <dfn lt="parsing a date string|parse a date string|parsing a date">날짜 문자열을 해석</dfn>하기 위한 규칙은 다음과 같습니다. 
  이것은 날짜를 반환하거나, 아무 것도 반환하지 않을 것입니다. 어느 시점에 알고리즘이 "실패"라고
  말한다면, 이것은 그 시점에 중단되고 아무 것도 반환하지 않음을 의미합니다. 

  1. <var>input</var>을 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <var>year</var>, <var>month</var>, <var>day</var>를 얻기 위해 <a lt="Parse a date component">날짜 컴포넌트를 해석</a>합니다.
      이것이 아무 것도 반환하지 않는다면, 실패입니다.
  4. <var>position</var>이 <var>input</var>의 끝을 지나지 <em>않으</em>면, 실패입니다.
  5. <var>date</var>를 <var>year</var>년, <var>month</var>월, <var>day</var>일을 가지고 날짜로 둡니다.
  6. <var>date</var>를 반환합니다.

  <var>input</var> 문자열과 <var>position</var>가 주어진 <dfn lt="parse a date component">날짜 컴포넌트를 해석</dfn>하기 
  위한 규칙은 다음과 같습니다. 이것은 연도, 월, 일을 반환하거나 아무 것도 반환하지 않을 것입니다.
  어느 시점에 알고리즘이 "실패"라고 말한다면, 이것은 그 시점에 중단되고 아무 것도 반환하지 않음을 
  의미합니다.

  1. <var>year</var>와 <var>month</var>를 얻기 위해 <a lt="Parse a month component">월 컴포넌트를 해석</a>합니다. 
      이것이 아무 것도 반환하지 않는다면, 실패입니다.
  2. <var>maxday</var>를 <a><var>year</var>년 <var>month</var>월의 날짜의 수</a>로 둡니다.
  3. <var>position</var>이 <var>input</var>의 끝을 지나거나 <var>position</var>에 있는 문자가 U+002D
      HYPHEN-MINUS 문자가 아니라면, 실패입니다. 그렇지 않으면, <var>position</var>를 한 글자 앞으로 
      옮깁니다.
  4. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다. 
      수집된 시퀀스가 정확히 두 글자가 아니라면, 실패입니다. 그렇지 않으면, 10 진수 정수로 결과 
      시퀀스를 해석합니다. 그 숫자를 <var>day</var>로 둡니다.
  5. <var>day</var>가 1&nbsp;&le;&nbsp;<var>day</var>&nbsp;&le;&nbsp;<var>maxday</var> 내 범위의 
      숫자가 아니라면, 실패입니다.
  6. <var>year</var>, <var>month</var>, <var>day</var>를 반환합니다.

<h5 id="yearless-dates">연도 없는 날짜</h5>

  <dfn lt="yearless date">연도 없는 날짜</dfn>는 그레고리 월과 그 월 내의 날짜로 구성되지만, 연관된
  연도는 없습니다. [[GREGORIAN]]

  문자열이 주어진 순서에 따라 다음 컴포넌트로 구성된다면, <var>month</var>월과 <var>day</var>일을  
  나타내는 <dfn lt="valid yearless date string">유효한 연도 없는 날짜 문자열</dfn>입니다:

  1. 선택적으로, 두 U+002D HYPHEN-MINUS 문자 (-)
  2. 1&nbsp;&le;&nbsp;<var>month</var>&nbsp;&le;&nbsp;12 범위에서 <var>month</var>월을 나타내는 두 
      <a lt="ASCII digits">ASCII 숫자</a>
  3. U+002D HYPHEN-MINUS 문자 (-)
  4. <var>maxday</var>가 <var>month</var>월과 임의의 윤년(예를 들어, 4나 2000)의 
      <a lt="number of days in month month of year year">날짜의 수</a>인, 
      1&nbsp;&le;&nbsp;<var>day</var>&nbsp;&le;&nbsp;<var>maxday</var> 범위에서 <var>day</var>를 
      나타내는 두 <a lt="ASCII digits">ASCII 숫자</a>

  <p class="note">
    바꿔 말하면, <var>month</var>이 2월을 의미하는 "<code>02</code>"라면, 날짜는 해가 윤년이었던 것처럼,
    29가 될 수 있습니다.
  </p>

  <p class="example">
  예를 들어, 2월 29일은 <code>02-29</code>로 부호화 되고, 3월 3일은 <code>03-03</code>로 부호화 됩니다.
  </p>


  <dfn lt="parsing a yearless date string|parse a yearless date string">연도 없는 날짜 문자열을 해석</dfn>하기 위한 규칙은 다음과 같습니다. 
  이것은 월과 날짜를 반환하거나 아무 것도 반환하지 않을 것입니다. 어느 시점에 알고리즘이 "실패"라고 
  말한다면, 이것은 그 시점에 중단되고 아무 것도 반환하지 않음을 의미합니다.

  1. <var>input</var>을 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <var>month</var>와 <var>day</var>를 얻기 위해 <a lt="parse a yearless date component">연도 없는 날짜 컴포넌트를 해석</a>합니다. 
      이것이 아무 것도 반환하지 않는다면 실패입니다.
  4. <var>position</var>이 <var>input</var>의 끝을 지나지 <em>않으</em>면, 실패입니다.
  5. <var>month</var>와 <var>day</var>를 반환합니다.

  <var>input</var> 문자열과 <var>position</var>이 주어진 <dfn lt="parse a yearless date component">연도 없는 날짜 컴포넌트를 해석</dfn>하기 위한 규칙은 다음과 같습니다.
  이것은 월과 날짜를 반환하거나 아무 것도 반환하지 않을 것입니다. 어느 시점에 알고리즘이 "실패"라고 
  말한다면, 이것은 그 시점에 중단되고 아무 것도 반환하지 않음을 의미합니다.

  1. U+002D HYPHEN-MINUS 문자 (-)인 <a lt="collect a sequence of characters">일련의 문자를 수집</a>합니다.
      수집된 시퀀스가 정확히 0개 혹은 두 개 글자가 아니라면, 실패입니다.
  2. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다. 
      수집된 시퀀스가 정확히 두 글자가 아니라면, 실패입니다. 그렇지 않으면, 10 진수 정수로 결과
      시퀀스를 해석합니다. 그 숫자를 <var>month</var>로 둡니다.
  3. <var>month</var>가 1&nbsp;&le;&nbsp;<var>month</var>&nbsp;&le;&nbsp;12 범위 내 숫자가 아니라면
      실패입니다.
  4. <var>maxday</var>를 임의의 윤년(예를 들어, 4 또는 2000)의 <var>month</var>월의 
      <a lt="number of days in month month of year year">날짜의 수</a>로 둡니다.
  5. <var>position</var>이 <var>input</var>의 끝을 지나거나 <var>position</var>에 있는 문자가 U+002D
      U+002D HYPHEN-MINUS 문자가 아니라면 실패입니다. 그렇지 않으면, <var>position</var>를 한 글자 
      앞으로 이동합니다.
  6. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다.
      수집된 시퀀스가 정확히 두 글자가 아니라면, 실패입니다. 그렇지 않으면 10 진수 정수로 결과
      시퀀스를 해석합니다. 그 숫자를 <var>day</var>로 둡니다.
  7. <var>day</var>가 1&nbsp;&le;&nbsp;<var>day</var>&nbsp;&le;&nbsp;<var>maxday</var> 범위 내 숫자가
      아니라면 실패입니다.
  8. <var>month</var>와 <var>day</var>를 반환합니다.

<h5 id="times">시간</h5>

  <dfn lt="time">time</dfn>은 시, 분, 초, 소수점 초로 구성되는, 표준 시간대 정보가 없는 특정한
  시간으로 구성됩니다.

  문자열이 주어진 순서에 따라 다음 컴포넌트로 구성된다면, <var>hour</var>시 <var>minute</var>분 
  <var>second</var>를 나타내는  <dfn lt="valid time string">유효한 시간 문자열</dfn>입니다:

  1. 0&nbsp;&le;&nbsp;<var>hour</var>&nbsp;&le;&nbsp;23 범위의 <var>hour</var>을 나타내는 두 
      <a lt="ASCII digits">ASCII 숫자</a>
  2. U+003A 콜론 문자 (:)
  3. 0&nbsp;&le;&nbsp;<var>minute</var>&nbsp;&le;&nbsp;59 범위의 <var>minute</var>을 나타내는 두 
      <a lt="ASCII digits">ASCII 숫자</a>
  4. <var>second</var>가 0가 아니거나, 선택적으로 <var>second</var>가 0이라면:
      1. U+003A 콜론 문자 (:)
      2. 0&nbsp;&le;&nbsp;<var>s</var>&nbsp;&le;&nbsp;59 범위의 <var>second</var>의 정수부를 나타내는
          두 <a lt="ASCII digits">ASCII 숫자</a>
      3. <var>second</var>가 정수가 아니거나, 선택적으로 <var>second</var>가 정수라면:
          1. 002E 마침표 문자 (.)
          2. 소수점 초 <var>second</var>를 나타내는 하나, 둘, 혹은 세 개의 <a lt="ASCII digits">ASCII 숫자</a>

  <p class="note">
    <var>second</var> 컴포넌트는 60이나 61이 될 수 없습니다; 윤초는 표현될 수 없습니다.
  </p>

  <p class="example">
  시간은, 선택적으로 초, 그리고 선택적으로 십진수 소수점 초를 가지고, 24시간제를 사용하여 부호화 
  됩니다. 따라서 7.45pm은 <code>19:45</code>로 부호화 됩니다. 그 시간 해석이 19:45:00 또는 7.45pm 
  0초를 반환 할 것이라는 것을 주목하세요. <code>19:45:45.456</code>는 7.45pm 45초 이후 456 천분의 
  1초 입니다.
  </p>

  <dfn lt="parsing a time string|parse a time string|parsing a time">시간 문자열을 해석</dfn>하기 위한 규칙은 다음과 같습니다. 
  이것은 시간을 반환하거나 아무 것도 반환하지 않을 것입니다. 어느 시점에 알고리즘이 "실패"라고 
  말한다면, 이것은 그 시점에 중단되고 아무 것도 반환하지 않음을 의미합니다.

  1. <var>input</var>을 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <var>hour</var>, <var>minute</var>, <var>second</var>를 얻기 위해 <a lt="parse a time component">시간 컴포넌트를 해석</a>합니다.
      이것이 아무 것도 반환하지 않는다면 실패입니다.
  4. <var>position</var>이 <var>input</var>의 끝을 지나지 <em>않으</em>면, 실패입니다.
  5. <var>time</var>을 <var>hour</var> 시, <var>minute</var> 분, <var>second</var> 초를 가진 시간으로
      둡니다
  6. <var>time</var>을 반환합니다.

  <var>input</var>과 <var>position</var>이 주어진 <dfn lt="parse a time component">시간 컴포넌트를 해석</dfn>를
  해석하기 위한 규칙은 다음고 같습니다. 이것은 시, 분, 초를 반환하거나 아무 것도 반환하지 않을 것입니다.
  어느 시점에 알고리즘이 "실패"라고 말한다면, 이것은 그 시점에 중단되고 아무 것도 반환하지 않음을 의미합니다.

  1. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다.
      수집된 시퀀스가 정확히 두 글자가 아니라면 실패입니다. 그렇지 않으면, 10진 수 정수로 결과 시퀀스를
      해석합니다. 그 숫자를 <var>hour</var>로 둡니다.
  2. <var>hour</var>가 0&nbsp;&le;&nbsp;<var>hour</var>&nbsp;&le;&nbsp;23 범위의 숫자가 아니라면
      실패입니다.
  3. <var>position</var>이 <var>input</var>의 끝을 지나거나 <var>position</var>에 있는 문자가 U+003A
      콜론 문자가 아니라면 실패입니다. 그렇지 않으면, <var>position</var>를 한 글자 앞으로 이동합니다.
  4. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다. 
      수집된 시퀀스가 정확히 두 글자가 아니라면 실패입니다. 그렇지 않으면, 10진수 정수로 결과 시퀀스를
      해석합니다. 그 숫자를 <var>minute</var>으로 둡니다.
  5. <var>minute</var>이 0&nbsp;&le;&nbsp;<var>minute</var>&nbsp;&le;&nbsp;59 범위의 숫자가 아니라면
      실패입니다.
  6. <var>second</var>를 "0" 값을 가진 문자열로 둡니다.
  7. <var>position</var>이 <var>input</var>의 끝을 지나지 않았고 <var>position</var>에 있는 문자가
      U+003A 콜론 이라면, 이 하위 단계들을 수행합니다:
      1. <var>position</var>을 <var>input</var> 내 다음 문자로 전진시킵니다.
      2. <var>position</var>이 <var>input</var>의 끝 혹은 <var>input</var> 내 마지막 문자를 지나거나, 
          <var>position</var>에서 시작하는 <var>input</var> 내 다음 <em>두</em> 문자가 모두
          <a lt="ASCII digits">ASCII 숫자</a>가 아니라면, 실패입니다.
      3. <a lt="ASCII digits">ASCII 숫자</a> 혹은 U+002E 마침표 문자인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다.
          수집된 시퀀스가 3개 문자거나, 3개 문자보다 길고 3번째 문자가 U+002E 마침표 문자가 아니거나,
          하나보다 많은 U+002E 마침표 문자를 가진다면, 실패입니다. 그렇지 않으면, <var>second</var>를
          수집된 문자열로 둡니다.

  8. <var>second</var>를 10진수(아마도 소수부를 가진) 수로 해석합니다. <var>second</var>를 문자열 
      버전 대신에 그 숫자로 둡니다.
  9. <var>second</var>가 0&nbsp;&le;&nbsp;<var>second</var>&nbsp;&lt;&nbsp;60 범위의 숫자가 아니라면,
      실패입니다.
  10. <var>hour</var>, <var>minute</var>, <var>second</var>를 반환합니다.

<h5 id="floating-dates-and-times">변동 날짜와 시간</h5>

  <dfn lt="floating date and time">변동 날짜와 시간</dfn>은 연, 월, 일 그리고 시, 분, 초, 소수점 초로 ,
  구성되는 시간으로 구성되는 특정한 <a lt="proleptic-Gregorian date">역산 그레고리 날짜</a>로 구성되지만
  표준시간대 없이 표현됩니다. [[GREGORIAN]]

  문자열이 주어진 순서에 따라 다음 컴포넌트들로 구성된다면 날짜와 시간을 나타내는 
  <dfn lt="valid-floating-date-and-time-string">유효한 변동 날짜와 시간 문자열</dfn>입니다:

  1. 날짜를 나타내는 <a lt="valid date string">유효한 날짜 문자열</a>
  2. U+0054 라틴 대문자 T (T) 혹은 U+0020 공백 문자
  3. 시간을 나타내는 <a lt="valid time string">유효한 시간 문자열</a>

  문자열이 주어진 순서에 따라 다음 컴포넌트로 구성된다면 날짜와 시간을 나타내는 
  <dfn lt="valid normalized floating date and time string">유효한 정규화된 변동 날짜와 시간 문자열</dfn>입니다:

  1. 날짜를 나타내는 <a lt="valid date string">유효한 날짜 문자열</a>
  2. U+0054 라틴 대문자 T (T)
  3. 주어진 시간에 대해 가능한 가장 짧은 문자열로(예를 들어, 주어진 시간이 분 이후 0초라면 초 컴포넌트를 
      완전히 생략하여) 표현된 시간을 나타내는 <a lt="valid time string">유효한 시간 문자열</a>

  <dfn lt="parsing a floating date and time string|parse a floating date and time string|parsing a floating date and time">변동 날짜와 시간 문자열을 해석</dfn>하기 위한 규칙은 다음과 같습니다. 
  이것은 날짜와 시간을 반환하거나 아무 것도 반환하지 않을 것입니다. 어느 시점에 알고리즘이 "실패"라고 
  말한다면, 이것은 그 시점에 중단되고 아무 것도 반환하지 않음을 의미합니다.

  1. <var>input</var>을 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <var>year</var>, <var>month</var>, <var>day</var>를 얻기 위해 <a lt="Parse a date component">날짜 컴포넌트를 해석</a>합니다.
      이것이 아무 것도 반환하지 않는다면, 실패입니다.
  4. <var>position</var>이 <var>input</var>의 끝을 지났거나 <var>position</var>에 있는 문자가
      U+0054 라틴 대문자 T (T)나 U+0020 공백 문자가 아니라면, 실패입니다.
      그렇지 않으면, <var>position</var>를 한 글자 앞으로 이동합니다.
  5. <var>hour</var>, <var>minute</var>, <var>second</var>를 얻기 위해 <a lt="parse a time component">시간 컴포넌트를 해석</a>합니다.
      이것이 아무 것도 반환하지 않는다면, 실패입니다.
  6. <var>position</var>이 <var>input</var>의 끝을 지나지 <em>않으</em>면, 실패입니다.
  7. <var>date</var>를 <var>year</var>년, <var>month</var>월, <var>day</var>일을 가진 날짜로 둡니다.
  8. <var>time</var>를 <var>hour</var>시, <var>minute</var>분, <var>second</var>초를 가진 시간으로 
      둡니다.
  9. <var>date</var>와 <var>time</var>을 반환합니다.

<h5 id="time-zones">표준 시간대</h5>

  <dfn lt="time zone|time-zone offset">표준 시간대 편차</dfn>는 시간과 분의 부호 달린 숫자로 구성됩니다.

  문자열이 다음으로 구성된다면, 표준 시간대 편차를 나타내는 
  <dfn lt="valid time-zone offset string">유효한 표준 시간대 편차 문자열</dfn>입니다:

  * 시간대가 UTC인 경우에함 허용되는, U+005A 라틴 대문자 Z (Z)
  * 혹은, 주어진 순서에 따라 다음 컴포넌트로 구성:
    1. 표준 시간대 편차의 부호를 나타내는, U+002B PLUS 부호 문자 (+), 혹은 표준 시간대 편차가 0이 
        아닌 경우 U+002D HYPHEN-MINUS 문자 (-)
    2. 0&nbsp;&le;&nbsp;<var>hour</var>&nbsp;&le;&nbsp;23 범위의 표준 시간대 편차의 시간 컴포넌트 
        <var>hour</var>를 나타내는 두 <a lt="ASCII digits">ASCII 숫자</a>
    3. 선택적으로, U+003A 콜론 문자 (:)
    4. 0&nbsp;&le;&nbsp;<var>minute</var>&nbsp;&le;&nbsp;59 범위의 표준 시간대 편차의 분 컴포넌트 
        <var>minute</var> 나타내는 두 <a lt="ASCII digits">ASCII 숫자</a>

  <p class="note">
    이 형식은 표준 시간대 편차에 대해 -23:59에서부터 +23:59까지 허용합니다. 하지만, 실제로는, 현재
    실제 표준 시간대의 편차의 범위는 -12:00에서 +14:00, 그리고 실제 표준 시간대의 편차의 분 컴포넌트는
    항상 00, 또는 30, 또는 45입니다. 하지만, 이것이 영원히 지속될 것이라는 보장은 없습니다; 표준
    시간대는 국가에 의해 변경되고 표준을 따르지 않습니다.
  </p>

  <p class="note">
    공식적인 표준 시간대의 형성에 앞선 역사적인 시간을 가진 표준 시간대 편차를 사용하는 데에 대한 
    자세한 내용은 아래 <a lt="global date and time">세계 날짜와 시간</a>섹션의 사용법과 예제 또한 
    참고하세요.
  </p>

  <dfn lt="parsing a time-zone offset string|parse a time-zone offset string">표준 시간대 편차 문자열을 해석</dfn>하기 위한 규칙은 다음과 같습니다. 
  이것은 표준 시간대 편차를 반환하거나, 아무 것도 반환하지 않을 것입니다. 어느 시점에 알고리즘이 
  "실패"라고 말한다면, 이것은 그 시점에 중단되고 아무 것도 반환하지 않음을 의미합니다.

  1. <var>input</var>을 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <var>timezone<sub>hours</sub></var>와 <var>timezone<sub>minutes</sub></var>를 얻기 위해 
      <a lt="Parse a time-zone offset component">표준 시간대 편차 컴포넌트를 해석</a>합니다.
      이것이 아무 것도 반환하지 않는다면, 실패입니다.
  4. <var>position</var>이 <var>input</var>의 끝을 지나지 <em>않으</em>면, 실패입니다.
  5. UTC로부터 <var>timezone<sub>hours</sub></var> 시간 <var>timezone<sub>minutes</sub></var> 
      분인 표준 시간대 편차를 반환합니다.

  <var>input</var> 문자열과 <var>position</var>이 주어진 <dfn lt="parse a time-zone offset component">표준 시간대 편차 컴포넌트를 해석</dfn>하기 위한 규칙은 다음과 같습니다.
  이것은 표진 시간대 시간과 표준 시간대 분을 반환하거나, 아무 것도 반환하지 않을 것입니다.
  어느 시점에 알고리즘이 "실패"라고 말한다면, 이것은 그 시점에 중단되고 아무 것도 반환하지 않음을 
  의미합니다.

  1. <var>position</var>에 있는 문자가 U+005A 라틴 대문자 Z (Z)라면:
      1. <var>timezone<sub>hours</sub></var>를 0으로 둡니다.
      2. <var>timezone<sub>minutes</sub></var>를 0으로 둡니다.
      3. <var>position</var>을 <var>input</var> 내 다음 문자로 전진시킵니다.

      그렇지 않고, <var>position</var>에 있는 문자가 U+002B PLUS 부호 (+)나 U+002D HYPHEN-MINUS (-)라면:

      1. <var>position</var>에 있는 문자가 U+002B PLUS 부호 (+)라면, <var>sign</var>를 "양"으로 둡니다.
          그렇지 않고, 그것이 U+002D HYPHEN-MINUS (-)라면; <var>sign</var>을 "음"으로 둡니다.
      2. <var>position</var>을 <var>input</var> 내 다음 문자로 전진시킵니다.
      3. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다. 
          <var>s</var>를 수집된 시퀀스로 둡니다.
      4. <var>s</var>가 정확히 두 글자라면, 이 하위 단계들을 수행합니다:
          1. <var>s</var>를 10진수 정수로 해석합니다. 그 숫자를 <var>timezone<sub>hours</sub></var>로 
              둡니다.
          2. <var>position</var>이 <var>input</var>의 끝을 지났거나, <var>position</var>에 있는 문자가
              U+003A 콜론 문자가 아니라면 실패입니다. 그렇지 않으면, <var>position</var>를 한 글자
              앞으로 이동합니다.
          3. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다. 
              수집된 시퀀스가 정확히 두 글자가 아니라면 실패입니다. 그렇지 않으면, 10진 정수로 결과 
              시퀀스를 해석합니다. 그 수를 <var>timezone<sub>minutes</sub></var>로 둡니다.

          <var>s</var>가 정확히 4 글자가 아니라면, 이 하위 단계들을 수행합니다:

          1. <var>s</var>의 첫 번째 두 글자를 10진 정수로 해석합니다. 그 수를 <var>timezone<sub>hours</sub></var>로 둡니다.
          2. <var>s</var>의 마지막 두 글자를 10진 정수로 해석합니다. 그 수를 <var>timezone<sub>minutes</sub></var>로 둡니다.

          그렇지 않으면 실패입니다.

      5. <var>timezone<sub>hours</sub></var>가 0&nbsp;&le;&nbsp;<var>timezone<sub>hours</sub></var>&nbsp;&le;&nbsp;23 
          범위의 숫자가 아니라면 실패입니다.
      6. <var>sign</var>가 "음"이라면, <var>timezone<sub>hours</sub></var>를 무효화합니다.
      7. <var>timezone<sub>minutes</sub></var>가 0&nbsp;&le;&nbsp;<var>timezone<sub>minutes</sub></var>&nbsp;&le;&nbsp;59
          범위의 숫자가 아니라면 실패입니다.
      8. <var>sign</var>이 "음"이라면, <var>timezone<sub>minutes</sub></var>를 무효화합니다.

      그렇지 않으면 실패입니다.

  2. <var>timezone<sub>hours</sub></var>과 <var>timezone<sub>minutes</sub></var>를 반환합니다.

<h5 id="global-dates-and-times">세계 날짜와 시간</h5>

  <dfn lt="global date and time">세계 날짜와 시간</dfn>은 시간과 분의 부호 달린 숫자로 구성되는, 
  표준 시간대 편차로 표현된, 연, 월, 일, 그리고 시, 분, 초, 소수점 초로 구성되는 시간으로 구성되는 
  특정한 <a lt="proleptic-Gregorian date">역산 그레고리 날짜</a>로 구성됩니다. [[GREGORIAN]]

  문자열이 주어진 순서에 따라 다음 컴포넌트로 구성된다면 날짜, 시간, 표준 시간대 편차를 나타내는 
  <dfn lt="valid global date and time string">유효한 세계 날짜와 시간 문자열</dfn>입니다:

  1. 날짜를 나타내는 <a lt="valid date string">유효한 날짜 문자열</a>
  2. U+0054 라틴 대문자 T (T) 혹은 U+0020 공백 문자
  3. 시간을 나타내는 <a lt="valid time string">유효한 시간 문자열</a>
  4. 표준 시간대 편차를 나타내는 <a lt="valid time-zone offset string">유효한 표준 시간대 편차 문자열</a>

  20 세기 중반의 UTC 형성 이전 날짜의 시간은 UTC(SI초 단위로 측정한 UT1의 근사치)가 아니라, UT1 
  (경도 0&deg;에서의 현대 지구 평균 태양시)으로 표현되고 해석되어야(must)합니다. 표준 시간대의 형성
  이전 시간은 적절한 현지 시간과 런던 그리니치 지역에서 관찰된 시간 사이의 차이에 가까운 명시적인 
  표준 시간대를 가진 UT1 시간으로 표현되고 해석되어야(must)합니다.

  <div class="example">
    다음은 <a lt="valid global date and time strings">유효한 세계 날짜와 시간 문자열</a>로 작성된 
    날짜의 몇 가지 예입니다.

    : "<code>0037-12-13 00:00Z</code>"
    :: 런던 시간 사용하는 지역에서 네로(로마 황제)의 생일의 자정. 이것이 실제로 어느 날짜에 해당하는지에 
        대한 자세한 설명은 아래를 참고하세요.

    : "<code>1979-10-14T12:00:00.001-04:00</code>"
    :: 일광 절약 시간제 동안 미국 동부 해안에서 사용하는 표준 시간대에서, 1979년 10월 14일 정오 이후
        1밀리 초.

    : "<code>8592-01-01T02:09+02:09</code>"
    :: 8598년 1월 1일 자정 UTC. 그 시간과 관련된 표준 시간대는 현재 실제 표준 시간대가 아닌, UTC보다 
        2시간 9분 빠르지만, 그렇더라도 허용됩니다.

    이 날짜들에 대해 몇 가지 주목할 만한 것들이 있습니다:

    * 4자리 숫자 이하의 연도는 0으로 채워져야(have to) 합니다. "37-12-13" 날짜는 유효한 날짜가 되지 
        않을 것입니다.
    * "<code>T</code>"가 공백으로 대체된다면, 이것은 하나의 공백 문자여야(must) 합니다. 
        "<code>2001-12-21&nbsp;&nbsp;12:00Z</code>" (컴포넌트 사이에 2개의 공백이 있는) 문자열은
        성공적으로 해석되지 않을 것입니다.
    * 그레고리 달력의 도입에 앞선 시간의 때를 분명하게 확인하기 위해 (UTC 형성 이전 시간의 때가  
        분명하게 식별될 수 있는 한), 날짜는 그 때 사용되는 달력으로부터(예를 들어 율리우스력으로부터) 
        그레고리력으로 먼저 변환되어야(has to) 합니다. 네로의 생일 날짜는 율리우스력으로 37년 12월 15일이고,
        <a lt="proleptic Gregorian calendar">역산 그레고리력</a>으로는 37년 12월 13일입니다.
    * 시간과 표준 시간대 편차 컴포넌트는 선택 사항이 아닙니다.
    * 1년 이전의 날짜는 HTML의 이 버전에서 일시(datetime)로 나타낼 수 없습니다.
    * 시간은 상대적으로 최근 수십 년까지 잘 조정되거나 측정되지 않았기 때문에, 고대의 특정 사건의 
        시간은 잘해야 근사치입니다.
    * 표준 시간대 편차는 일광 절약 시간제에 따라 달라집니다.
  </div>

  <p class="note">
    지역 편차는 완전한 표준 시간대 명세가 아닙니다. 실제 날짜와 시간 값으로 작업하는 경우, 아마도
    INA 시간대 ID를 사용하여, 표준 시간대에 대한 별도의 필드를 사용하는 것을 고려하세요.
    [[TIMEZONE]]
  </p>

  문자열이 주어진 순서에 따라 다음 컴포넌트로 구성된다면, 날짜, 시간, 표준 시간대를 나타내는 
  <dfn lt="valid normalized global date and time string">유효한 정규화 된 세계 날짜와 시간 문자열</dfn>입니다:

  1. UTC 표준 시간대로 변환된 날짜를 나타내는 <a lt="valid date string">유효한 날짜 문자열</a>
  2. U+0054 라틴 대문자 T (T)
  3.  UTC 표준 시간대로 변환되고 주어진 시간에 대해 가능한 가장 짧은 문자열로(예를 들어, 주어진
      시간이 분 이후 0초라면 초 컴포넌트를 완전히 생략하여) 표현된 시간을 나타내는 
      <a lt="valid time string">유효한 시간 문자열</a>
  4. U+005A 라틴 대문자 Z (Z)

  <dfn lt="parse a global date and time string|parsing a date and time">세계 날짜와 시간 문자열을 해석</dfn>하기 위한 규칙은 다음과 같습니다. 
  이것은 라운드 트립 혹은 표시 목적을 위해 연관된 표준 시간대 정보를 가진 UTC 시간을 반환하거나 
  아무 것도 반환하지 않을 것입니다. 어느 시점에 알고리즘이 "실패"라고 말한다면, 이것은 그 시점에 
  중단되고 아무 것도 반환하지 않음을 의미합니다.

  1. <var>input</var>을 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <var>year</var>, <var>month</var>, <var>day</var>을 얻기 위해 <a lt="parse a date component">날짜 컴포넌트를 해석</a>합니다.
      이것이 아무 것도 반환하지 않는다면, 실패입니다.
  4. <var>position</var>이 <var>input</var>의 끝을 지나거나 <var>position</var>에 위치한 문자가
      U+0054 라틴 대문자 T 나 U+0020 공백문자가 아니라면, 실패입니다. 그렇지 않으면, <var>position</var>을
      한 글자 앞으로 이동합니다.
  5. <var>hour</var>, <var>minute</var>, <var>second</var>를 얻기 위해 <a lt="parse a time component">시간 컴포넌트를 해석</a>합니다.
      이것이 아무 것도 반환하지 않는다면, 실패입니다.
  6. <var>position</var>이 <var>input</var>의 끝을 지났다면 실패입니다.
  7. <var>timezone<sub>hours</sub></var>와 <var>timezone<sub>minutes</sub></var>를 얻기 위해 
      <a lt="Parse a time-zone offset component">표준 시간대 컴포넌트를 해석</a>합니다. 이것이 아무 
      것도 반환하지 않는다면, 실패입니다.
  8. <var>position</var>이 <var>input</var>의 끝을 지나지 <em>않으</em>면, 실패입니다.
  9. <var>time</var>을 <var>timezone<sub>hours</sub></var>시간 <var>timezone<sub>minutes</sub></var>분을 
      뺀, <var>year</var>년 <var>month</var>월 <var>day</var>일 <var>hour</var>시 <var>minute</var>분 
      <var>second</var>초 시간의 시점으로 둡니다. 그 시간의 시점은 UTC 표준 시간대의 시점입니다.
  10. <var>timezone</var>을 UTC로부터 <var>timezone<sub>hours</sub></var> 시간 
      <var>timezone<sub>minutes</sub></var>분 입니다.
  11. <var>time</var>과 <var>timezone</var>를 반환합니다.

<h5 id="weeks">주(weeks)</h5>

  <dfn lt="week">주</dfn>는 주-해(week-year) 수와 월요일에서 시작하여 7일 주기를 나타내는 주차 수로 구성됩니다. 
  아래 정의된 바와 같이, 이 달력 시스템에서의 각 주차-연도는 52 혹은 53개의 7일 주기를 가집니다.
  그레고리 날짜 1969년 12월 29일 월요일((1969-12-29))에서 시작하는 7일 주기는 1970 주-해(week-year)에서의 
  1 주차로 정의됩니다. 연속 주차는 순차적으로 숫자가 매겨집니다. 주-해(week-year)에서의 1 주차의 이전 주는
  이전 주-해(week-year)에서의 마지막 주이고, 반대도 같습니다. [[GREGORIAN]]

  <var>year</var> 수를 가진 주-해(week-year)는 첫 날(1월 1일)로 목요일을 가지는
  <a lt="proleptic Gregorian calendar">역산 그레고리력</a>의 <var>year</var>년에 해당하거나 첫 날(1월 1일)로
  수요일을 가지고 <var>year</var>가 400으로 나눌 수 있는 수이거나 4로 나눌 수 있지만 100으로 나눌 수
  없는 수를 가지는 <a lt="proleptic Gregorian calendar">역산 그레고리력</a>의 <var>year</var>년에
  해당한다면 53주를 가집니다. 모든 다른 주-해(week-year)들은 52 주를 가집니다.

  53주를 가진 주-해(week-year)의 <dfn lt="week number of the last day">마지막 날의 주차 수</dfn>는 
  53입니다; 52주를 가진 주-해(week-year)의 마지막 날의 주차 수는 52입니다.

  <p class="note">
    특정 일의 주-해(week-year) 수는 <a lt="역산 그레고리력">proleptic Gregorian calendar</a>으로
    그 날짜를 포함하는 해의 수와 다를 수 있습니다. <var>y</var> 주-해(week-year)의 첫 주는 
    그레고리 <var>y</var>년의 첫 번째 목요일을 포함하는 주입니다.

  <p class="note">
    현대적인 목적을 위해, 여기 정의된 <a>week</a>는 ISO 8601에 정의된 대로 ISO 주와 동등합니다.
    [[ISO8601]]

    문자열이 주어진 순서에 따라 다음 컴포넌트로 구성된다면 주-해(week-year) <var>year</var>와 
    <var>week</var> 주를 나타내는 <dfn lt="valid week string">유효한 주 문자열</dfn>입니다:
  </p>

  1. <var>year</var>&nbsp;&gt;&nbsp;0인, <var>year</var>를 나타내는 4개 이상의 <a lt="ASCII digits">ASCII 숫자</a>
  2. U+002D HYPHEN-MINUS 문자 (-)
  3. U+0057 라틴 대문자 W (W)
  4. <var>maxweek</var>가 주-해(week-year) <var>year</var>의 <a lt="week number of the last day">마지막 주의 주차 수</a>인 
      1&nbsp;&le;&nbsp;<var>week</var>&nbsp;&le;&nbsp;<var>maxweek</var> 내 범위의 <var>week</var> 
      주를 나타내는 두 <a lt="ASCII digits">ASCII 숫자</a>

  <dfn lt="parsing a week string|parse a week string|parsing a week">주 문자열을 해석</dfn>하기 위한 
  규칙은 다음과 같습니다. 이것은 주-해(week-year) 수나 주차 수를 반환하거나, 아무 것도 반환하지 않을 
  것 입니다. 어느 시점에 알고리즘이 "실패"라고 말한다면, 이것은 그 시점에 중단되고 아무 것도 반환하지
  않음을 의미합니다.

  1. <var>input</var>를 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다. 
      수집된 시퀀스가 적어도 4 글자가 아니라면 실패입니다. 그렇지 않으면, 10진수 정수로 결과 시퀀스를 
      해석합니다. 그 숫자를 <var>year</var>로 둡니다.
  4. <var>year</var>가 0보다 큰 수가 아니라면, 실패입니다.
  5. <var>position</var>이 <var>input</var>의 끝을 지나거나 <var>position</var>에 위치한 문자가
      U+002D HYPHEN-MINUS 문자가 아니라면 실패입니다. 그렇지 않으면, <var>position</var>을 한 글자
      앞으로 이동합니다.
  6. <var>position</var>이 <var>input</var>의 끝을 지나거나 <var>position</var>에 위치한 문자가
      U+0057 라틴 대문자 W (W)라면, 실패입니다. 그렇지 않으면 <var>position</var>을 한 글자 앞으로
      이동합니다.
  7. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다.
      수집된 시퀀스가 적어도 2 글자가 아니라면 실패입니다. 그렇지 않으면, 10진수 정수로 결과 시퀀스를 
      해석합니다. 그 숫자를 <var>week</var>로 둡니다.
  8. <var>maxweek</var>를 <var>year</var>년의 <a lt="week number of the last day">마지막 날의 주차 수</a>로 둡니다.
  9. <var>week</var>가 1&nbsp;&le;&nbsp;<var>week</var>&nbsp;&le;&nbsp;<var>maxweek</var> 범위의 숫자가 
      아니라면, 실패입니다.
  10. <var>position</var>이 <var>input</var>의 끝을 지나지 <em>않으</em>면, 실패입니다.
  11. 주-해(week-year) 수 <var>year</var>와 주차 수<var>week</var>를 반환합니다.

<h5 id="durations">기간</h5>

  <dfn lt="duration">기간</dfn>은 약간의 초로 구성됩니다.

  <p class="note">
    월과 초는 비교할 수 없기 때문에 (1 개월은 정확한 수의 초가 아니고, 대신 측정된 정확한 날짜에 따른 정확한
    길이가 정해지는 주기입니다) 이 명세에 정의된 <a lt="duration">기간</a>은 월(혹은 12월과 동일한 년)
    을 포함할 수 없습니다. 특정한 수의 초를 기술하는 기간만이 기술 될 수 있습니다.
  </p>

  문자열이 다음 중 하나로 구성된다면 <a lt="duration">기간</a> <var>t</var>를 나타내는 
  <dfn lt="valid duration string">유효한 기간 문자열</dfn>입니다:

  * 일, 시, 분, 초의 수가 <var>t</var>에서와 같은 초의 동일한 수에 해당하는, 주어진 순서에 따라 다음 
    하위 컴포넌트가 하나 이상 따르는 리터럴 U+0050 라틴 대문자 P :

    1. 일 숫자를 나타내는, U+0044 라틴 대문자 D가 뒤따르는 하나 이상의 <a lt="ASCII digits">ASCII 숫자</a>.
    2. 주어진 순서에 따라 다음 하위 컴포넌트들이 하나 이상 뒤따르는 U+0054 라틴 대문자 T:
        1. 시 숫자를 나타내는, U+0048 라틴 대문자 H가 뒤따르는 하나 이상의 <a lt="ASCII digits">ASCII 숫자</a>.
        2. 분 숫자를 나타내는, U+004D 라틴 대문자 M이 뒤따르는 하나 이상의 <a lt="ASCII digits">ASCII 숫자</a>.
        3. 다음 컴포넌트:
            1. 초 숫자를 나타내는 하나 이상의 <a lt="ASCII digits">ASCII 숫자</a>.
            2. 선택적으로, 소수점 초를 나타내는 하나 혹은 둘, 혹은 세 개의 <a lt="ASCII digits">ASCII 숫자</a>가 
                뒤따르는 U+002E 마침표 문자 (.).
            3. U+0053 라틴 대문자 S.

    <p class="note">
      이것은, 이 명세에 정의된 날짜와 시간과 연관된 약간의 마이크로문법과 같이, ISO 8601에 정의된
      형식의 하나에 기반 합니다. [[ISO8601]]
    </p>

  * 순서에 상관 없이, 각각 다른 <a lt="duration time component scale">기간 시간 컴포넌트 크기</a>를 
    가지는 하나 이상의 <a lt="duration time components">기간 시간 컴포넌트</a>; <var>t</var>에서 초의 
    숫자와 동일하게 표현된 초의 합계.

    A <dfn lt="duration time component">기간 시간 컴포넌트</dfn>는 다음 컴포넌트로 구성되는 문자열입니다:

      1. 0개 이상의 <a lt="space characters">공백 문자</a>.
      2. 약간의 초를 나타내기 위해 명시된 (아래 참고) <a lt="duration time component scale">기간 시간 
          컴포넌트 크기</a>에 의해 크기가 조정된 약간의 시간 단위를 나타내는 하나 이상의 
          <a lt="ASCII digits">ASCII 숫자</a>.
      3. <a lt="duration time component scale">기간 시간 컴포넌트 크기</a>가 1로 명시되었다면(즉, 
         단위가 초), 선택적으로 소수점 초를 나타내는 하나 혹은 둘, 혹은 세 개의 <a lt="ASCII digits">ASCII 숫자</a>가 
         뒤따르는 U+002E 마침표 문자 (.).
      4. 0개 이상의 <a lt="space characters">공백 문자</a>.
      5. <a lt="duration time component">기간 시간 컴포넌트</a>의 숫자 부분에 사용된 시간 단위의 
          <dfn lt="duration time component scale">기간 시간 컴포넌트 크기</dfn>를 나타내는 다음 문자 
          중 하나:

          : U+0057 라틴 대문자 W
          : U+0077 라틴 소문자 W
          :: 주. 크기는 604800 입니다.

          : U+0044 라틴 대문자 D
          : U+0064 라틴 소문자 D
          :: 일. 크기는 86400 입니다.

          : U+0048 라틴 대문자 H
          : U+0068 라틴 소문자 H
          :: 시. 크기는 3600 입니다.

          : U+004D 라틴 대문자 M
          : U+006D 라틴 소문자 M
          :: 분. 크기는 60 입니다.

          : U+0053 라틴 대문자 S
          : U+0073 라틴 소문자 S
          :: 초. 크기는 1 입니다.

      6. 0개 이상의 <a lt="space characters">공백 문자</a>.

      <p class="note">
        이것은 ISO 8601에 있는 형식에 기반되지 않습니다. 이것은 ISO 기간 형식에 대해 사람이 읽을 수 
        있는 대안으로 의도되었습니다.
      </p>

  <dfn lt="parsing a duration string|parse a duration string">기간 문자열을 해석</dfn>하기 위한 규칙은 다음과 같습니다. 
  이것은 <a lt="duration">기간</a>을 반환하거나 아무 것도 반환하지 않을 것입니다. 어느 시점에 
  알고리즘이 "실패"라고 말한다면, 이것은 그 시점에 중단되고 아무 것도 반환하지 않음을 의미합니다.

  1. <var>input</var>을 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <var>months</var>, <var>seconds</var>, <var>component count</var>을 모두 0으로 둡니다.
  4. <var>M-disambiguator</var>을 <i>minutes</i>로 둡니다.
      <p class="note">
        이 플래그의 다른 값은 <i>months</i>입니다. 이것은 ISO8601 기간에서 월과 분에 대해 동일한 
        단위로 사용되는 "M" 단위를 명확하게 하기 위해 사용됩니다. 월은 허용되지 않지만, 향후 호환성을 
        위해 해석되고 다른 컨텍스트에서 유효할 수 있는 ISO8601 기간을 잘못 해석하는 것을 방지합니다.
      </p>
  5. <a lt="Skip whitespace">여백을 건너뜁니다</a>.
  6. <var>position</var>이 <var>input</var>의 끝을 지났다면, 실패입니다.
  7. <var>position</var>에 의해 가리켜진 <var>input</var> 내의 문자가 U+0050 라틴 대문자 P라면, 
      <var>position</var>을 다음 문자로 전진시키고, <var>M-disambiguator</var>를 <i>months</i>로 설정하고,
      <a lt="Skip whitespace">여백을 건너뜁니다</a>.
  8. 요구되는 반복이 끊어지거나 전체 알고리즘이 실패에 이를 때까지, 반복에서 다음 하위 단계들을 수행합니다:
      1. <var>units</var>를 undefined로 둡니다. 그것은 다음 값들 중 하나가 할당 될 것입니다:
          <i>years</i>, <i>months</i>, <i>weeks</i>, <i>days</i>, <i>hours</i>, <i>minutes</i>,
          <i>seconds</i>.
      2. <var>next character</var>를 undefined로 둡니다. 그것은 <var>input</var>로부터 문자를 가공하는데
          사용됩니다.
      3. <var>position</var>이 <var>input</var>의 끝을 지났다면, 반복을 중단합니다.
      4. <var>position</var>에 의해 가리켜진 <var>input</var> 내의 문자가 U+0054 라틴 대문자 T라면,
          <var>position</var>을 다음 문자로 전진시키고, <var>M-disambiguator</var>를 <i>minutes</i>으로
          설정하고, <a lt="Skip whitespace">여백을 건너뛰고</a>, 반복의 처음으로 돌아갑니다.
      5. <var>next character</var>를 <var>position</var>에 의해 가리켜진 <var>input</var> 내의 문자로
          둡니다.
      6. <var>next character</var>가 U+002E 마침표 문자 (.)라면, <var>N</var>를 0으로 둡니다.
          (<var>position</var>를 전진시키지 않습니다. 그것은 아래에서 다루어집니다.)

          그렇지 않고, <var>next character</var>가 <a lt="ASCII digits">ASCII 숫자</a>라면, <a lt="ASCII digits">ASCII 숫자</a>인
          <a lt="Collect a sequence of characters">일련의 문자를 수집</a>하고 10진수 정수로 결과 시퀀스를 
          해석하고, <var>N</var>을 그 숫자로 둡니다.

          그렇지 않으면 <var>next character</var>가 숫자 부분이 아닙니다; 실패입니다.

      7. <var>position</var>이 <var>input</var>의 끝을 지났다면, 실패입니다.
      8. <var>next character</var>를 <var>position</var>에 의해 가리켜진 <var>input</var> 내의 문자로
          설정하고, 이번에는 <var>position</var>을 다음 문자로 전진시킵니다. (<var>next character</var>가
          이전에 U+002E 마침표 문자가 아니었다면, 이번에는 여전히 그 문자가 될 것입니다.)
      9. <var>next character</var>가 U+002E 마침표 문자 (.)라면, 이 하위 단계들을 수행합니다:
          1. <a lt="ASCII digits">ASCII 숫자</a>인 <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다. 
              <var>s</var>를 결과 시퀀스로 둡니다.
          2. <var>s</var>가 빈 문자열이라면 실패입니다.
          3. <var>length</var>를 <var>s</var>내 문자의 개수로 둡니다.
          4. <var>fraction</var>을 10진수 정수로 <var>s</var>를 해석한 후, 그 숫자를 
              10<sup><var>length</var></sup>로 나눈 결과로 둡니다.
          5. <var>N</var>을 <var>fraction</var>만큼 증가시킵니다.
          6. <a lt="Skip whitespace">여백을 건너뜁니다</a>.
          7. <var>position</var>이 <var>input</var>의 끝을 지났다면, 실패입니다.
          8. <var>next character</var>를 <var>position</var>에 의해 가리켜진 <var>input</var> 내의 
              문자로 설정하고, <var>position</var>을 다음 문자로 전진시킵니다.
          9. <var>next character</var>가  U+0053 라틴 대문자 S나 U+0073 라틴 소문자 S 모두 아니라면,
              실패입니다.
          10. <var>units</var>를 <i>seconds</i>로 설정합니다.

          그렇지 않으면, 이 하위 단계들을 수행합니다:

          1. <var>next character</var>가 <a lt="space characters">공백 문자</a>라면, <a lt="Skip whitespace">여백을 건너뛰고</a>,
              <var>next character</var>를 <var>position</var>에 의해 가리켜진 <var>input</var> 내의 
              문자로 설정하고, <var>position</var>을 다음 문자로 전진시킵니다.
          2. <var>next character</var>가 U+0059 라틴 대문자 Y나 U+0079 라틴 소문자 Y라면, <var>units</var>을
              <i>years</i>로 설정하고 <var>M-disambiguator</var>를 <i>months</i>로 설정합니다.

              <var>next character</var>가 U+004D 라틴 대문자 M이거나 U+006D 라틴 소문자 M이라면,
              <var>M-disambiguator</var>는 <i>months</i>이고, <var>units</var>를 <i>months</i>로
              설정합니다.

              <var>next character</var>가 U+0057 라틴 대문자 W이거나 U+0077 라틴 소문자 W라면,
              <var>units</var>를 <i>weeks</i>로 설정하고 <var>M-disambiguator</var>를 <i>minutes</i>로
              설정합니다.

              <var>next character</var>가 U+0044 라틴 대문자 D이거나 U+0064 라틴 소문자 D라면,
              <var>units</var>를 <i>days</i>로 설정하고 <var>M-disambiguator</var>를 <i>minutes</i>로
              설정합니다.

              <var>next character</var>가 U+0048 라틴 대문자 H이거나 U+0068 라틴 소문자 H라면,
              <var>units</var>를 <i>hours</i>로 설정하고 <var>M-disambiguator</var>를 <i>minutes</i>로
              설정합니다.

              <var>next character</var>가 U+004D 라틴 대문자 M이거나 U+006D 라틴 소문자 M이라면,
              <var>M-disambiguator</var>를 <i>minutes</i>로 설정하고 <var>units</var>를 <i>minutes</i>로
              설정합니다.

              <var>next character</var>가 U+0053 라틴 대문자 S이거나 U+0073 라틴 소문자 S라면,
              <var>units</var>를 <i>seconds</i>로 설정하고 <var>M-disambiguator</var>를 <i>minutes</i>로
              설정합니다.

              그렇지 않고 <var>next character</var>가 위 문자 중 어떠한 것도 아니라면, 실패입니다.

      10. <var>component count</var>를 증가시킵니다.
      11. <var>multiplier</var>를 1로 둡니다.
      12. <var>units</var>가 <i>years</i>라면, <var>multiplier</var>에 12를 곱하고 <var>units</var>를
          <i>months</i>로 설정합니다.
      13. <var>units</var>가 <i>months</i>라면, <var>N</var>과 <var>multiplier</var>의 곱을
          <var>months</var>에 더합니다.

          그렇지 않으면, 이 하위 단계들을 수행합니다:

          1. <var>units</var>가 <i>weeks</i>라면, <var>multiplier</var>에 7을 곱하고 <var>units</var>를
              <i>days</i>로 설정합니다.
          2. <var>units</var>가 <i>days</i>라면, <var>multiplier</var>에 24를 곱하고 <var>units</var>를
              <i>hours</i>로 설정합니다.
          3. <var>units</var>가 <i>hours</i>라면, <var>multiplier</var>에 60을 곱하고 <var>units</var>를
              <i>minutes</i>로 설정합니다.
          4. <var>units</var>가 <i>minutes</i>라면, <var>multiplier</var>에 60을 곱하고 <var>units</var>를
              <i>seconds</i>로 설정합니다.
          5. 강제적으로, <var>units</var>는 이제 <i>seconds</i>입니다. <var>N</var>과 <var>multiplier</var>의
              곱을 <var>seconds</var>에 더합니다.
      14. <a lt="Skip whitespace">여백을 건너뜁니다</a>.

  9. <var>component count</var>가 0이라면, 실패입니다.
  10. <var>months</var>가 0이라면, 실패입니다.
  11. <var>seconds</var> 초로 구성된 <a lt="duration">기간</a>을 반환합니다.

<h5 id="vaguer-moments-in-time">시간의 모호한 때</h5>

  문자열이 다음 중 하나라면 <dfn lt="valid date string with optional time">선택적인 시간을 가진 유효한 날짜 문자열</dfn>입니다:

  * <a lt="valid date string">유효한 날짜 문자열</a>
  * <a lt="valid global date and time string">유효한 세계 날짜와 시간 문자열</a>

  <hr />

  <dfn lt="parse a date or time string">날짜나 시간 문자열을 해석</dfn>하기 위한 규칙은 다음과 같습니다. 
  이 알고리즘은 <a for="dates" lt="date">날짜</a>, <a lt="time">시간</a>, <a lt="global date and time">세계 날짜와 시간</a>을
  반환하거나, 아무 것도 반환하지 않을 것입니다. 어느 시점에 알고리즘이 "실패"라고 말한다면, 이것은 
  그 시점에 중단되고 아무 것도 반환하지 않음을 의미합니다.

  1. <var>input</var>를 해석되는 문자열로 둡니다.
  2. <var>position</var>을 초기에 문자열의 시작을 가리키는, <var>input</var>에 대한 포인터로 둡니다.
  3. <var>start position</var>를 <var>position</var>과 동일한 위치로 둡니다.
  4. <var>date present</var>와 <var>time present</var> 플래그를 true로 둡니다.
  5. <var>year</var>, <var>month</var>, <var>day</var>를 얻기 위해 <a lt="parse a date component">날짜 컴포넌트를 해석</a>합니다.
      이것이 실패한다면, <var>date present</var> 플래그를 false로 설정합니다.
  6. <var>date present</var>이 true이고, <var>position</var>이 <var>input</var>의 끝을 지나지 않았고,
      <var>position</var>에 있는 문자가 U+0054 라틴 대문자 T나 U+0020 공백 문자라면, <var>position</var>을
      <var>input</var>내 다음 문자로 전진시킵니다.

      그렇지 않고, <var>date present</var>가 true이고, <var>position</var>이 <var>input</var>의 끝을
      지났거나 <var>position</var>에 있는 문자가 U+0054 라틴 대문자 T나 U+0020 공백 문자가 모두 아니라면,
      <var>time present</var>를 false로 둡니다.

      그렇지 않고, <var>date present</var>가 false라면, <var>position</var>를 <var>start position</var>과 
      동일한 위치로 돌립니다.

  7. <var>time present</var> 플래그가 true라면, <var>hour</var>, <var>minute</var>, <var>second</var>를 
      얻기 위해 <a lt="parse a time component">시간 컴포넌트를 해석</a>합니다. 이것이 아무 것도 반환하지 
      않는다면, 실패입니다.
  8. <var>date present</var>과 <var>time present</var> 플래그가 모두 true이지만, <var>position</var>이
      <var>input</var>의 끝을 지났다면, 실패입니다.
  9. <var>date present</var>와 <var>time present</var>플래그가 모두 true라면, <var>timezone<sub>hours</sub></var>과
      <var>timezone<sub>minutes</sub></var>를 얻기 위해 <a lt="parse a time-zone offset component">표준 시간대 편차 컴포넌트를 해석</a>합니다.
      이것이 아무 것도 반환하지 않는다면, 실패입니다.
  10. <var>position</var>이 <var>input</var>의 끝을 지나지 <em>않으</em>면, 실패입니다.
  11. <var>date present</var> 플래그가 true이고 <var>time present</var> 플래그가 false라면,
      <var>date</var>를 <var>year</var>년, <var>month</var>월, <var>day</var>일을 가진 날짜로 두고,
      <var>date</var>를 반환합니다.

      그렇지 않고, <var>time present</var> 플래그가 true이고 <var>date present</var> 플래그가 false라면,
      <var>time</var>을 <var>hour</var>시, <var>minute</var>분, <var>second</var>초를 가진 시간으로 두고
      <var>time</var>을 반환합니다.

      그렇지 않으면, <var>time</var>을 UTC 표준 시간대 순간이 되는 시간의 순간인 
      <var>timezone<sub>hours</sub></var>시간 <var>timezone<sub>minutes</sub></var>분을 뺀 
      <var>year</var>년, <var>month</var>월, <var>day</var>일, <var>hour</var>시, <var>minute</var>분,
      <var>second</var>초의 순간으로 둡니다;
      <var>timezone</var>을 UTC로부터 <var>timezone<sub>hours</sub></var> 시
      <var>timezone<sub>minutes</sub></var> 분으로 두고; <var>time</var>과 <var>timezone</var>를
      반환합니다.

<h4 id="colors">Colors</h4>

  A <dfn>simple color</dfn> consists of three 8-bit numbers in the range 0..255, representing the
  red, green, and blue components of the color respectively, in the sRGB color space. [[!SRGB]]

  A string is a <dfn>valid simple color</dfn> if it is exactly seven characters long, and the first
  character is a U+0023 NUMBER SIGN character (#), and the remaining six characters are all
  <a>ASCII hex digits</a>, with the first two digits representing the red component, the middle two
  digits representing the green component, and the last two digits representing the blue component,
  in hexadecimal.

  A string is a <dfn>valid lowercase simple color</dfn> if it is a <a>valid simple color</a> and
  doesn't use any characters in the range U+0041 LATIN CAPITAL LETTER A to U+0046 LATIN CAPITAL
  LETTER F.

  The <dfn>rules for parsing simple color values</dfn> are as given in the following algorithm.
  When invoked, the steps must be followed in the order given, aborting at the first step that
  returns a value. This algorithm will return either a <a>simple color</a> or an error.

  1. Let <var>input</var> be the string being parsed.
  2. If <var>input</var> is not exactly seven characters long, then return an error.
  3. If the first character in <var>input</var> is not a U+0023 NUMBER SIGN character (#), then
      return an error.
  4. If the last six characters of <var>input</var> are not all <a>ASCII hex digits</a>, then
      return an error.
  5. Let <var>result</var> be a <a>simple color</a>.
  6. Interpret the second and third characters as a hexadecimal number and let the result be the
      red component of <var>result</var>.
  7. Interpret the fourth and fifth characters as a hexadecimal number and let the result be the
      green component of <var>result</var>.
  8. Interpret the sixth and seventh characters as a hexadecimal number and let the result be the
      blue component of <var>result</var>.
  9. Return <var>result</var>.

  The <dfn>rules for serializing simple color values</dfn> given a <a>simple color</a> are as
  given in the following algorithm:

  1. Let <var>result</var> be a string consisting of a single U+0023 NUMBER SIGN character (#).
  2. Convert the red, green, and blue components in turn to two-digit hexadecimal numbers using
      <a>lowercase ASCII hex digits</a>, zero-padding if necessary, and append these numbers to
      <var>result</var>, in the order red, green, blue.
  3. Return <var>result</var>, which will be a <a>valid lowercase simple color</a>.

  <hr />

  Some obsolete legacy attributes parse colors in a more complicated manner, using the <dfn>rules
  for parsing a legacy color value</dfn>, which are given in the following algorithm. When
  invoked, the steps must be followed in the order given, aborting at the first step that returns
  a value. This algorithm will return either a <a>simple color</a> or an error.

  1. Let <var>input</var> be the string being parsed.
  2. If <var>input</var> is the empty string, then return an error.
  3. <a>Strip leading and trailing whitespace</a> from <var>input</var>.
  4. If <var>input</var> is an <a>ASCII case-insensitive</a> match for the string
      "<code>transparent</code>", then return an error.
  5. If <var>input</var> is an <a>ASCII case-insensitive</a> match for one of the
      <a>named colors</a>, then return the <a>simple color</a> corresponding to that keyword.
      [[!CSS3COLOR]]

      <p class="note"><a>CSS2 System Colors</a> are not recognized.</p>

  6. If <var>input</var> is four characters long, and the first character in <var>input</var> is a
      U+0023 NUMBER SIGN character (#), and the last three characters of <var>input</var> are all
      <a>ASCII hex digits</a>, then run these substeps:
      1. Let <var>result</var> be a <a>simple color</a>.
      2. Interpret the second character of <var>input</var> as a hexadecimal digit; let the red
          component of <var>result</var> be the resulting number multiplied by 17.
      3. Interpret the third character of <var>input</var> as a hexadecimal digit; let the green
          component of <var>result</var> be the resulting number multiplied by 17.
      4. Interpret the fourth character of <var>input</var> as a hexadecimal digit; let the blue
          component of <var>result</var> be the resulting number multiplied by 17.
      5. Return <var>result</var>.

  7. Replace any characters in <var>input</var> that have a Unicode code point greater than U+FFFF
      (i.e., any characters that are not in the basic multilingual plane) with the two-character
      string "<code>00</code>".
  8. If <var>input</var> is longer than 128 characters, truncate <var>input</var>, leaving only
      the first 128 characters.
  9. If the first character in <var>input</var> is a U+0023 NUMBER SIGN character (#), remove it.
  10. Replace any character in <var>input</var> that is not an <a>ASCII hex digit</a> with the
      character U+0030 DIGIT ZERO (0).
  11. While <var>input</var>'s length is zero or not a multiple of three, append a U+0030 DIGIT
      ZERO (0) character to <var>input</var>.
  12. Split <var>input</var> into three strings of equal length, to obtain three components. Let
      <var>length</var> be the length of those components (one third the length of
      <var>input</var>).
  13. If <var>length</var> is greater than 8, then remove the leading <var>length</var>-8
      characters in each component, and let <var>length</var> be 8.
  14. While <var>length</var> is greater than two and the first character in each component is a
      U+0030 DIGIT ZERO (0) character, remove that character and reduce <var>length</var> by one.
  15. If <var>length</var> is <em>still</em> greater than two, truncate each component, leaving
      only the first two characters in each.
  16. Let <var>result</var> be a <a>simple color</a>.
  17. Interpret the first component as a hexadecimal number; let the red component of
      <var>result</var> be the resulting number.
  18. Interpret the second component as a hexadecimal number; let the green component of
      <var>result</var> be the resulting number.
  19. Interpret the third component as a hexadecimal number; let the blue component of
      <var>result</var> be the resulting number.
  20. Return <var>result</var>.

<h4 id="space-separated-tokens">Space-separated tokens</h4>

  A <dfn>set of space-separated tokens</dfn> is a string containing zero or more words (known as
  tokens) separated by one or more <a>space characters</a>, where words consist of any string of one
  or more characters, none of which are <a>space characters</a>.

  A string containing a <a>set of space-separated tokens</a> may have leading or trailing
  <a>space characters</a>.

  An <dfn>unordered set of unique space-separated tokens</dfn> is a
  <a>set of space-separated tokens</a> where none of the tokens are duplicated.

  An <dfn>ordered set of unique space-separated tokens</dfn> is a
  <a>set of space-separated tokens</a> where none of the tokens are duplicated but where the order
  of the tokens is meaningful.

  <a lt="set of space-separated tokens">Sets of space-separated tokens</a> sometimes have a defined set of allowed values. When a set
  of allowed values is defined, the tokens must all be from that list of allowed values; other
  values are non-conforming. If no such set of allowed values is provided, then all values are
  conforming.

  <p class="note">
    How tokens in a <a>set of space-separated tokens</a> are to be compared (e.g., case-sensitively
    or not) is defined on a per-set basis.
  </p>

  When a user agent has to <dfn>split a string on spaces</dfn>, it must use the following
  algorithm:

  1. Let <var>input</var> be the string being parsed.
  2. Let <var>position</var> be a pointer into <var>input</var>, initially pointing at the start
      of the string.
  3. Let <var>tokens</var> be an ordered list of tokens, initially empty.
  4. <a>Skip whitespace</a>
  5. While <var>position</var> is not past the end of <var>input</var>:
      1. <a>Collect a sequence of characters</a> that are not <a>space characters</a>.
      2. Append the string collected in the previous step to <var>tokens</var>.
      3. <a>Skip whitespace</a>
  6. Return <var>tokens</var>.

<h4 id="comma-separated-tokens">Comma-separated tokens</h4>

  A <dfn>set of comma-separated tokens</dfn> is a string containing zero or more tokens each
  separated from the next by a single U+002C COMMA character (,), where tokens consist of any string
  of zero or more characters, neither beginning nor ending with <a>space characters</a>, nor
  containing any U+002C COMMA characters (,), and optionally surrounded by <a>space characters</a>.

  <p class="example">
    For instance, the string "<code>&nbsp;a&nbsp;,b,d&nbsp;d&nbsp;</code>" consists of four tokens:
    "a", "b", the empty string, and "d&nbsp;d". Leading and trailing whitespace around each token
    doesn't count as part of the token, and the empty string can be a token.
  </p>

  <a lt="set of comma-separated tokens">Sets of comma-separated tokens</a> sometimes have further restrictions on what consists a valid
  token. When such restrictions are defined, the tokens must all fit within those restrictions;
  other values are non-conforming. If no such restrictions are specified, then all values are
  conforming.

  When a user agent has to <dfn>split a string on commas</dfn>, it must use the following algorithm:

  1. Let <var>input</var> be the string being parsed.
  2. Let <var>position</var> be a pointer into <var>input</var>, initially pointing at the start
      of the string.
  3. Let <var>tokens</var> be an ordered list of tokens, initially empty.
  4. <i>Token</i>: If <var>position</var> is past the end of <var>input</var>, jump to the last
      step.
  5. <a>Collect a sequence of characters</a> that are not U+002C COMMA characters (,). Let
      <var>s</var> be the resulting sequence (which might be the empty string).
  6. <a>Strip leading and trailing whitespace</a> from <var>s</var>.
  7. Append <var>s</var> to <var>tokens</var>.
  8. If <var>position</var> is not past the end of <var>input</var>, then the character at
      <var>position</var> is a U+002C COMMA character (,); advance <var>position</var> past that
      character.
  9. Jump back to the step labeled <i>token</i>.
  10. Return <var>tokens</var>.

<h4 id="syntax-references">References</h4>

  A <dfn>valid hash-name reference</dfn> to an element of type <var>type</var> is a
  string consisting of a U+0023 NUMBER SIGN character (#) followed by a string which exactly matches
  the value of the <code>name</code> attribute of an element with type <var>type</var> in
  the document.

  The <dfn>rules for parsing a hash-name reference</dfn> to an element of type <var>type</var>,
  given a context node <var>scope</var>, are as follows:

  1. If the string being parsed does not contain a U+0023 NUMBER SIGN character, or if the first
      such character in the string is the last character in the string, then return null and abort
      these steps.
  2. Let <var>s</var> be the string from the character immediately after the first U+0023 NUMBER
      SIGN character in the string being parsed up to the end of that string.
  3. Return the first element of type <var>type</var> in <a>tree order</a> in the subtree rooted
      at <var>scope</var> that has an <code>id</code> attribute whose value is a
      <a>case-sensitive</a> match for <var>s</var> or a <code>name</code> attribute whose value is
      a <a>compatibility caseless</a> match for <var>s</var>.

<h4 id="mq">Media queries</h4>

  A string is a <dfn>valid media query list</dfn> if it matches the
  <code>&lt;media-query-list&gt;</code> production of the Media Queries specification. [[!MEDIAQ]]

  A string <dfn lt="match the environment|matches the environment">matches the environment</dfn> of the user if it is the empty string, a string
  consisting of only <a>space characters</a>, or is a media query list that matches the user's
  environment according to the definitions given in the Media Queries specification. [[!MEDIAQ]]

<h3 id="infrastructure-urls">URLs</h3>

<h4 id="urls-terminology">Terminology</h4>

  A <a for="url">URL</a> is a <dfn>valid URL</dfn> if it conforms to the authoring conformance
  requirements in the WHATWG URL standard. [[!URL]]

  A string is a <dfn>valid non-empty URL</dfn> if it is a <a>valid URL</a> but it is not
  the empty string.

  A string is a <dfn>valid URL potentially surrounded by spaces</dfn> if, after
  <a>stripping leading and trailing whitespace</a> from it, it is a <a>valid URL</a>.

  A string is a <dfn>valid non-empty URL potentially surrounded by spaces</dfn> if, after
  <a>stripping leading and trailing whitespace</a> from it, it is a <a>valid non-empty URL</a>.

  This specification defines the URL <dfn scheme><code>about:legacy-compat</code></dfn> as a reserved,
  though unresolvable, <a scheme><code>about:</code></a> URL, for use in <a>DOCTYPE</a>s in <a>HTML documents</a>
  when needed for compatibility with XML tools. [[!RFC6694]]

  This specification defines the URL <dfn scheme><code>about:srcdoc</code></dfn> as a reserved, though
  unresolvable, <a scheme><code>about:</code></a> URL, that is used as <a>the document's address</a> of
  <a lt="iframe srcdoc document"><code>iframe</code> <code>srcdoc</code> documents</a>. [[!RFC6694]]

  The <dfn>fallback base URL</dfn> of a {{Document}} object is the <a>absolute URL</a>
  obtained by running these substeps:

  1. If <var>document</var> is
      <a lt="iframe srcdoc document">an <code>iframe</code> <code>srcdoc</code> document</a>,
      then return the <a>document base URL</a> of the <var>Document</var>'s
      <a>browsing context</a>'s <a>browsing context container</a>'s <a>node document</a>.
  2. If <var>document</var>'s <a for="url">URL</a> is <code>about:blank</code>, and the
      <var>Document</var>'s <a>browsing context</a> has a <a>creator browsing context</a>, then
      return the <a>creator base URL</a>.
  3. Return <var>document</var>'s <a for="url">URL</a>.

  The <dfn>document base URL</dfn> of a {{Document}} object is the <a>absolute URL</a>
  obtained by running these substeps:

  1. If there is no <{base}> element that has an <{base/href}> attribute in the
      {{Document}}, then the <a>document base URL</a> is the {{Document}}'s
      <a>fallback base URL</a>; abort these steps.
  2. Otherwise, the <a>document base URL</a> is the <a>frozen base URL</a> of the first
      <{base}> element in the {{Document}} that has an <{base/href}>
      attribute, in <a>tree order</a>.

<h4 id="parsing-urls">Parsing URLs</h4>

  Parsing a URL is the process of taking a URL string and obtaining the <a>URL record</a> that it
  implies. While this process is defined in the WHATWG URL standard, this specification defines a
  wrapper for convenience. [[URL]]

  <p class="note">This wrapper is only useful when the character encoding for the URL parser has to
  match that of the document or environment settings object for legacy reasons. When that is not the
  case the <a>URL parser</a> can be used directly.</p>

  To <dfn lt="reparsed|parse a URL|parse|parsing|parsing of relative urls|parsing relative urls">parse a URL</dfn>
  <var>url</var>, relative to either a <var>document</var> or
  <var>environment settings object</var>, the user agent must use the following steps. Parsing a URL
  either results in failure or a <a>resulting URL string</a> and <a>resulting URL record</a>.

  1. Let <var>encoding</var> be <var>document</var>'s <a>character encoding</a>, if
      <var>document</var> was given, and <var>environment settings object</var>'s
      <a>API URL character encoding</a> otherwise.
  2. Let <var>baseURL</var> be <var>document</var>'s <a lt='document base URL'>base URL</a>, if <var>document</var> was
      given, and <var>environment settings object</var>'s <a>API base URL</a> otherwise.
  3. Let <var>urlRecord</var> be the result of applying the <a>URL parser</a> to <var>url</var>,
      with <var>baseURL</var> and <var>encoding</var>.
  4. If <var>urlRecord</var> is failure, then abort these steps with an error.
  5. Let <var>urlString</var> be the result of applying the <a>URL serializer</a> to
      <var>urlRecord</var>.
  6. Return <var>urlString</var> as the <dfn>resulting URL string</dfn> and <var>urlRecord</var> as
      the <dfn lt="resulting URL record|resulting URL records">resulting URL record</dfn>.

<h4 id="dynamic-changes-to-base-urls">Dynamic changes to base URLs</h4>

  When a document's <a>document base URL</a> changes, all elements in that document are
  <a>affected by a base URL change</a>.

  The following are <a>base URL change steps</a>, which run when an element is
  <a>affected by a base URL change</a> (as defined by the DOM specification):

  <dl class="switch">
    <dt>If the element creates a <a>hyperlink</a></dt>
    <dd>
      If the <a for="url">URL</a> identified by the hyperlink is being shown to the user, or if any
      data derived from that <a for="url">URL</a> is affecting the display, then the <{links/href}>
      attribute should be <a>reparsed</a> relative to the element's <a>node document</a> and the UI
      updated appropriately.

      <p class="example">
        For example, the CSS <code>:link</code>/<code>:visited</code> pseudo-classes might have
        been affected.
      </p>
    </dd>

    <dt>
      If the element is a <{q}>, <{blockquote}>, <{ins}>, or
      <{del}> element with a <code>cite</code> attribute
    </dt>
    <dd>
      If the <a for="url">URL</a> identified by the <code>cite</code> attribute is being shown to
      the user, or if any data derived from that <a for="url">URL</a> is affecting the display, then
      the <a for="url">URL</a> should be <a>reparsed</a> relative to the element's
      <a>node document</a> and the UI updated appropriately.
    </dd>

    <dt>Otherwise</dt>
    <dd>
      The element is not directly affected.

      <p class="example">
        For instance, changing the base URL doesn't affect the image displayed by <code>img</code>
        elements, although subsequent accesses of the <code>src</code> IDL attribute from script
        will return a new <a>absolute URL</a> that might no longer correspond to the image being
        shown.
      </p>
    </dd>
  </dl>

<h3 id="fetching-resources">Fetching resources</h3>

<h4 id="fetching-resources-terminology">Terminology</h4>

  User agents can implement a variety of transfer protocols, but this specification mostly defines
  behavior in terms of HTTP. [[!HTTP]]

  The <dfn lt="or equivalent|HTTP GET method">HTTP GET method</dfn> is equivalent to the default retrieval action of the protocol.
  For example, RETR in FTP. Such actions are idempotent and safe, in HTTP terms.

  The <dfn>HTTP response codes</dfn> are equivalent to statuses in other protocols that have the
  same basic meanings. For example, a "file not found" error is equivalent to a 404 code, a server
  error is equivalent to a 5xx code, and so on.

  The <dfn>HTTP headers</dfn> are equivalent to fields in
  other protocols that have the same basic meaning. For example, the HTTP authentication headers
  are equivalent to the authentication aspects of the FTP protocol.

  A <dfn>referrer source</dfn> is either a {{Document}} or a <a for="url">URL</a>.

  To <dfn lt="creating a potential-cors request|create a potential-CORS request">create a potential-CORS request</dfn>, given a <var>url</var>,
  <var>corsAttributeState</var>, and an optional <i>same-origin fallback flag</i>, run these steps:

  1. Let <var>mode</var> be "<code>no-cors</code>" if <var>corsAttributeState</var> is
      <a state for="cors">No CORS</a>, and "<code>cors</code>" otherwise.

  2. If <i>same-origin fallback flag</i> is set and <var>mode</var> is "<code>no-cors</code>", set
      <var>mode</var> to "<code>same-origin</code>".

  3. Let <var>credentialsMode</var> be "<code>include</code>".

  4. If <var>corsAttributeState</var> is <a>Anonymous</a>, set <var>credentialsMode</var> to
      "<code>same-origin</code>".

  5. Let <var>request</var> be a new <a>request</a> whose <a for="url">URL</a> is <var>url</var>,
      <a>destination</a> is "<code>subresource</code>", <a>mode</a> is <var>mode</var>,
      <a>credentials mode</a> is <var>credentialsMode</var>, and whose
      <a>use-URL-credentials flag</a> is set.

<h4 id="fetching-resources-processing-model">Processing model</h4>

  When a user agent is to <a>fetch</a> a resource or <a for="url">URL</a>, optionally
  <strong>from</strong> an origin <i>origin</i>, optionally <strong>using</strong> a specific
  <a>referrer source</a> as an <i>override referrer source</i>, and optionally with any of a
  <i>synchronous flag</i>, a <i>manual redirect flag</i>, a <i>force same-origin flag</i>, and a
  <i>block cookies flag</i>, the following steps must be run. (When a <em>URL</em> is to be
  fetched, the URL identifies a resource to be obtained.)

  1. If there is a specific <i>override referrer source</i>, and it is a <a for="url">URL</a>, then let
      <var>referrer</var> be the <i>override referrer source</i>, and jump to the step labeled
      <i>clean referrer</i>.

  2. Let <var>document</var> be the appropriate {{Document}} as given by the following
      list:
      <dl class="switch">
        <dt>If there is a specific <i>override referrer source</i></dt>
        <dd>The <i>override referrer source</i>.</dd>

        <dt>When <a>navigating</a></dt>
        <dd>The <a>active document</a> of the <a>source browsing context</a>.</dd>

        <dt>When fetching resources for an element</dt>
        <dd>The element's {{Document}}.</dd>
      </dl>
  3. While <var>document</var> is <a lt="iframe srcdoc document">an <code>iframe</code> <code>srcdoc</code> document</a>, let
      <var>document</var> be <var>document</var>'s <a>browsing context</a>'s
      <a>browsing context container</a>'s {{Document}} instead.
  4. If the <a for="concept">origin</a> of <var>Document</var> is not a scheme/host/port tuple, then
      set <var>referrer</var> to the empty string and jump to the step labeled
      <var>Clean referrer</var>.
  5. Let <var>referrer</var> be <a>the document's address</a> of <var>document</var>.
  6. <var>Clean referrer</var>: Apply the <a>URL parser</a> to <var>referrer</var> and let
      <var>parsed referrer</var> be the <a>resulting URL record</a>.
  7. Let <var>referrer</var> be the result of applying the <a>URL serializer</a> to
      <var>parsed referrer</var>, with the <i>exclude fragment flag</i> set.
  8. If <var>referrer</var> is not the empty string, is not a <a scheme lt="data:"><code>data:</code> URL</a>, and
      is not the <a for="url">URL</a> "<code>about:blank</code>", then generate the <i>address of the
      resource from which Request-URIs are obtained</i> as required by HTTP for the
      <code>Referer</code> (sic) header from <var>referrer</var>. [[!HTTP]]

      Otherwise, the <code>Referer</code> (sic) header must be omitted, regardless of its value.
  9. If the algorithm was not invoked with the <i>synchronous flag</i>, perform the remaining
      steps <a>in parallel</a>.
  10. If the {{Document}} with which any <a>tasks</a> <a>queued</a> by this algorithm
      would be associated doesn't have an associated <a>browsing context</a>, then abort these
      steps.
  11. This is the <i>main step</i>.

      If the resource is to be obtained from an <a>application cache</a>, then use the data from
      that <a>application cache</a>, as if it had been obtained in the manner appropriate given
      its <a for="url">URL</a>.

      If the resource is identified by an <a>absolute URL</a>, and the resource is to be obtained
      using an idempotent action (such as an HTTP GET <a>or equivalent</a>), and it is already
      being downloaded for other reasons (e.g., another invocation of this algorithm), and this
      request would be identical to the previous one (e.g., same <code>Accept</code> and
      <code>Origin</code> headers), and the user agent is configured such that it is to reuse the
      data from the existing download instead of initiating a new one, then use the results of the
      existing download instead of starting a new one.

      Otherwise, if the resource is identified by an <a>absolute URL</a> with a scheme that does
      not define a mechanism to obtain the resource (e.g., it is a <code>mailto:</code> URL) or
      that the user agent does not support, then act as if the resource was an HTTP 204 No Content
      response with no other metadata.

      Otherwise, if the resource is identified by the <a for="url">URL</a>
      <code>about:blank</code>, then the resource is immediately available and consists
      of the empty string, with no metadata.

      Otherwise, at a time convenient to the user and the user agent, download (or otherwise
      obtain) the resource, applying the semantics of the relevant specifications (e.g., performing
      an HTTP GET or POST operation, or reading the file from disk, or expanding
      <a scheme lt="data:"><code>data:</code> URLs</a>, etc).

      For the purposes of the <code>Referer</code> (sic) header, use the
      <i>address of the resource from which Request-URIs are obtained</i> generated in the earlier
      step.

      For the purposes of the <code>Origin</code> header, if the <a>fetching algorithm</a> was
      explicitly initiated from an <i>origin</i>, then
      <i>the origin that initiated the HTTP request</i> is <i>origin</i>. Otherwise, this is
      <i>a request from a "privacy-sensitive" context</i>. [[!ORIGIN]]
  12. If the algorithm was not invoked with the <i>block cookies flag</i>, and there are cookies
      to be set, update the cookies. [[!COOKIES]]
          <a class="fingerprint" href="#fingerprinting-vector"><img height="21" src="images/fingerprint.png" width="15" alt="(This is a fingerprinting vector.)" /></a>
  13. If the fetched resource is an HTTP redirect <a>or equivalent</a>, then:

      <dl class="switch">
        <dt>
          If the <i>force same-origin flag</i> is set and the <a for="url">URL</a> of the target of the
          redirect does not have the <a>same origin</a> as the <a for="url">URL</a> for which the
          <a>fetch</a> algorithm was invoked
        </dt>
        <dd>
          Abort these steps and return failure from this algorithm, as if the remote host could
          not be contacted.
        </dd>

        <dt>If the <i>manual redirect flag</i> is set</dt>
        <dd>
          Continue, using the fetched resource (the redirect) as the result of the algorithm. If
          the calling algorithm subsequently requires the user agent to
          <dfn>transparently follow the redirect</dfn>, then the user agent must resume this
          algorithm from the <i>main step</i>, but using the target of the redirect as the
          resource to fetch, rather than the original resource.
        </dd>

        <dt>Otherwise</dt>
        <dd>
          First, apply any relevant requirements for redirects (such as showing any appropriate
          prompts). Then, redo <i>main step</i>, but using the target of the redirect as the
          resource to fetch, rather than the original resource. For HTTP requests, the new request
          must include the same headers as the original request, except for headers for which
          other requirements are specified (such as the <code>Host</code> header). [[!HTTP]]

          <p class="note">
            The HTTP specification requires that 301, 302, and 307 redirects, when applied to
            methods other than the safe methods, not be followed without user confirmation. That
            would be an appropriate prompt for the purposes of the requirement in the paragraph
            above. [[!HTTP]]
        </dd>
      </dl>
  14. If the algorithm was not invoked with the <i>synchronous flag</i>: When the resource is
      available, or if there is an error of some description, <a>queue a task</a> that uses the
      resource as appropriate. If the resource can be processed incrementally, as, for instance,
      with a progressively interlaced JPEG or an HTML file, additional tasks may be queued to
      process the data as it is downloaded. The <a>task source</a> for these <a>tasks</a> is the
      <a>networking task source</a>.

      Otherwise, return the resource or error information to the calling algorithm.

  If the user agent can determine the actual length of the resource being <a>fetched</a> for an
  instance of this algorithm, and if that length is finite, then that length is the file's
  <dfn>size</dfn>. Otherwise, the subject of the algorithm (that is, the resource being fetched)
  has no known <a>size</a>. (For example, the HTTP <code>Content-Length</code> header might
  provide this information.)

  The user agent must also keep track of the <dfn>number of bytes downloaded</dfn> for each
  instance of this algorithm. This number must exclude any out-of-band metadata, such as HTTP
  headers.

  <p class="note">
    The <a>navigation</a> processing model handles redirects itself, overriding the redirection
    handling that would be done by the <a>fetching algorithm</a>.
  </p>

  <p class="note">
    Whether the <a href="#content-type-sniffing">type sniffing rules</a> apply to the fetched resource depends on the algorithm
    that invokes the rules &mdash; they are not always applicable.
  </p>

  <h4 id="encrypted-http-and-related-security-concerns">Encrypted HTTP and related security concerns</h4>

  Anything in this specification that refers to HTTP also applies to HTTP-over-TLS, as represented
  by <a for="url">URLs</a> representing the <code>https</code> scheme. [[!HTTP]]

  <p class="warning">
    User agents should report certificate errors to the user and must either refuse to download
    resources sent with erroneous certificates or must act as if such resources were in fact
    served with no encryption.
  </p>

  User agents should warn the user that there is a potential problem whenever the user visits a
  page that the user has previously visited, if the page uses less secure encryption on the second
  visit.

  Not doing so can result in users not noticing man-in-the-middle attacks.

  <div class="example">
    If a user connects to a server with a self-signed certificate, the user agent could allow the
    connection but just act as if there had been no encryption. If the user agent instead allowed
    the user to override the problem and then displayed the page as if it was fully and safely
    encrypted, the user could be easily tricked into accepting man-in-the-middle connections.

    If a user connects to a server with full encryption, but the page then refers to an external
    resource that has an expired certificate, then the user agent will act as if the resource was
    unavailable, possibly also reporting the problem to the user. If the user agent instead
    allowed the resource to be used, then an attacker could just look for "secure" sites that used
    resources from a different host and only apply man-in-the-middle attacks to that host, for
    example taking over scripts in the page.

    If a user bookmarks a site that uses a CA-signed certificate, and then later revisits that
    site directly but the site has started using a self-signed certificate, the user agent could
    warn the user that a man-in-the-middle attack is likely underway, instead of simply acting as
    if the page was not encrypted.
  </div>

<h4 id="content-type-sniffing">Determining the type of a resource</h4>

  The <dfn lt="content-type metadata|associated content-type headers|associated content-type metadata|explicit content-type metadata|content-type|the resource's content-type metadata|type information">Content-Type metadata</dfn>
  of a resource must be obtained and interpreted in a manner
  consistent with the requirements of the MIME Sniffing specification. [[!MIMESNIFF]]

  The <dfn lt="computed type of the resource|computed type of a resource|image sniffing|computed MIME type">computed type of a resource</dfn>
  must be found in a manner consistent with the requirements given in the MIME Sniffing
  specification for finding the <i>computed media type</i> of the relevant sequence of octets.
  [[!MIMESNIFF]]

  The <dfn lt="image sniffing rules|rules for sniffing images specifically">rules for sniffing images specifically</dfn> and the <dfn>rules for distinguishing if a
  resource is text or binary</dfn> are also defined in the MIME Sniffing specification. Both sets
  of rules return a <a>MIME type</a> as their result. [[!MIMESNIFF]]

  <p class="warning">
    It is imperative that the rules in the MIME Sniffing specification be followed exactly. When a
    user agent uses different heuristics for content type detection than the server expects,
    security problems can occur. For more details, see the MIME Sniffing specification.
    [[!MIMESNIFF]]
  </p>

<h4 id="extracting-character-encodings-from-meta-elements">Extracting character encodings from <{meta}> elements</h4>

  The <dfn>algorithm for extracting a character encoding from a <{meta}> element</dfn>,
  given a string <var>s</var>, is as follows. It either returns a character encoding or nothing.

  1. Let <var>position</var> be a pointer into <var>s</var>, initially pointing at the start of
      the string.
  2. <i>Loop</i>: Find the first seven characters in <var>s</var> after <var>position</var> that
      are an <a>ASCII case-insensitive</a> match for the word "<code>charset</code>". If no such
      match is found, return nothing and abort these steps.
  3. Skip any <a>space characters</a> that immediately follow the word "<code>charset</code>"
      (there might not be any).
  4. If the next character is not a U+003D EQUALS SIGN (=), then move <var>position</var> to point
      just before that next character, and jump back to the step labeled <i>loop</i>.
  5. Skip any <a>space characters</a> that immediately follow the equals sign (there might not be
      any).
  6. Process the next character as follows:
      <dl class="switch">
        <dt>
          If it is a U+0022 QUOTATION MARK character (") and there is a later U+0022 QUOTATION
          MARK character (") in <var>s</var>
        </dt>
        <dt>
          If it is a U+0027 APOSTROPHE character (') and there is a later U+0027 APOSTROPHE
          character (') in <var>s</var>
        </dt>
        <dd>
          Return the result of <a>getting an encoding</a> from the substring that is between
          this character and the next earliest occurrence of this character.
        </dd>

        <dt>If it is an unmatched U+0022 QUOTATION MARK character (")</dt>
        <dt>If it is an unmatched U+0027 APOSTROPHE character (')</dt>
        <dt>If there is no next character</dt>
        <dd>Return nothing.</dd>

        <dt>Otherwise</dt>
        <dd>
          Return the result of <a>getting an encoding</a> from the substring that consists of this
          character up to but not including the first <a>space character</a> or U+003B SEMICOLON
          character (;), or the end of <var>s</var>, whichever comes first.
        </dd>
      </dl>

  <p class="note">
    This algorithm is distinct from those in the HTTP specification (for example, HTTP doesn't
    allow the use of single quotes and requires supporting a backslash-escape mechanism that is
    not supported by this algorithm). While the algorithm is used in contexts that, historically,
    were related to HTTP, the syntax as supported by implementations diverged some time ago.
    [[!HTTP]]
  </p>

<h4 id="cors-settings-attributes">CORS settings attributes</h4>

  A <dfn>CORS settings attribute</dfn> is an <a>enumerated attribute</a>. The following table lists
  the keywords and states for the attribute &mdash; the keywords in the left column map to the
  states in the cell in the second column on the same row as the keyword.

  <table>
    <thead>
      <tr>
        <th>Keyword</th>
        <th>State</th>
        <th>Brief description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><dfn value for="cors"><code>anonymous</code></dfn></td>
        <td><dfn state for="cors">Anonymous</dfn></td>
        <td>
          <a>Requests</a> for the element will have their <a for="request">mode</a> set to "<code>cors</code>" and
          their <a>credentials mode</a> set to "<code>same-origin</code>".
        </td>
      </tr>
      <tr>
        <td><dfn value for="cors"><code>use-credentials</code></dfn></td>
        <td><dfn state for="cors">Use Credentials</dfn></td>
        <td>
          <a>Requests</a> for the element will have their <a for="request">mode</a> set to "<code>cors</code>" and
          their <a>credentials mode</a> set to "<code>include</code>".
        </td>
      </tr>
    </tbody>
  </table>

  The empty string is also a valid keyword, and maps to the <a state for="cors">Anonymous</a> state. The attribute's
  <i>invalid value default</i> is the <a state for="cors">Anonymous</a> state. For the purposes of <a>reflection</a>,
  the canonical case for the <a state for="cors">Anonymous</a> state is the <a value for="cors"><code>anonymous</code></a> keyword. The
  <i>missing value default</i>, used when the attribute is omitted, is the
  <dfn state for="cors">No CORS</dfn> state.

<h3 id="common-dom-interfaces">Common DOM interfaces</h3>

<h4 id="reflecting-content-attributes-in-idl-attributes">Reflecting content attributes in IDL attributes</h4>

  Some IDL attributes are defined to <dfn lt="reflection|reflect">reflect</dfn> a particular content attribute. This means
  that on getting, the IDL attribute returns the current value of the content attribute, and on
  setting, the IDL attribute changes the value of the content attribute to the given value.

  In general, on getting, if the content attribute is not present, the IDL attribute must act as
  if the content attribute's value is the empty string; and on setting, if the content attribute
  is not present, it must first be added.

  If a reflecting IDL attribute is a <code>DOMString</code> attribute whose content attribute is
  defined to contain a <a for="url">URL</a>, then on getting, the IDL attribute must <a>parse</a> the
  value of the content attribute relative to the element and return the resulting
  <a>absolute URL</a> if that was successful, or the empty string otherwise; and on setting, must
  set the content attribute to the specified literal value. If the content attribute is absent,
  the IDL attribute must return the default value, if the content attribute has one, or else the
  empty string.

  If a reflecting IDL attribute is a <code>DOMString</code> attribute whose content attribute is
  defined to contain one or more <a for="url">URLs</a>, then on getting, the IDL attribute must <a lt="split a string on spaces">split the
  content attribute on spaces</a> and return the concatenation of <a>parsing</a> each token URL
  to an <a>absolute URL</a> relative to the element, with a single U+0020 SPACE character between
  each URL, ignoring any tokens that did not resolve successfully. If the content attribute is
  absent, the IDL attribute must return the default value, if the content attribute has one, or
  else the empty string. On setting, the IDL attribute must set the content attribute to the
  specified literal value.

  If a reflecting IDL attribute is a <code>DOMString</code> attribute whose content attribute is
  an <a>enumerated attribute</a>, and the IDL attribute is <dfn>limited to only known values</dfn>,
  then, on getting, the IDL attribute must return the conforming value associated with the state
  the attribute is in (in its canonical case), if any, or the empty string if the attribute is in
  a state that has no associated keyword value or if the attribute is not in a defined state (e.g.,
  the attribute is missing and there is no <i>missing value default</i>); and on setting, the
  content attribute must be set to the specified new value.

  If a reflecting IDL attribute is a nullable <code>DOMString</code> attribute whose content
  attribute is an <a>enumerated attribute</a>, then, on getting, if the corresponding content
  attribute is in its <i>missing value default</i> then the IDL attribute must return null,
  otherwise, the IDL attribute must return the conforming value associated with the state the
  attribute is in (in its canonical case); and on setting, if the new value is null, the content
  attribute must be removed, and otherwise, the content attribute must be set to the specified new
  value.

  If a reflecting IDL attribute is a <code>DOMString</code> attribute but doesn't fall into any
  of the above categories, then the getting and setting must be done in a transparent,
  case-preserving manner.

  If a reflecting IDL attribute is a <code>boolean</code> attribute, then on getting the IDL
  attribute must return true if the content attribute is set, and false if it is absent. On
  setting, the content attribute must be removed if the IDL attribute is set to false, and must be
  set to the empty string if the IDL attribute is set to true. (This corresponds to the rules for
  <a lt="boolean attributes">boolean content attributes</a>.)

  If a reflecting IDL attribute has a signed integer type (<code>long</code>) then, on getting,
  the content attribute must be parsed according to the <a>rules for parsing signed integers</a>,
  and if that is successful, and the value is in the range of the IDL attribute's type, the
  resulting value must be returned. If, on the other hand, it fails or returns an out of range
  value, or if the attribute is absent, then the default value must be returned instead, or 0 if
  there is no default value. On setting, the given value must be converted to the shortest
  possible string representing the number as a <a>valid integer</a> and then that string must be
  used as the new content attribute value.

  If a reflecting IDL attribute has a signed integer type (<code>long</code>)
  that is <dfn>limited to only non-negative numbers</dfn> then, on getting, the content attribute
  must be parsed according to the <a>rules for parsing non-negative integers</a>, and if that
  is successful, and the value is in the range of the IDL attribute's type, the resulting value
  must be returned. If, on the other hand, it fails or returns an out of range value, or if the
  attribute is absent, the default value must be returned instead, or -1 if there is no
  default value. On setting, if the value is negative, the user agent must throw an
  <code>IndexSizeError</code> exception. Otherwise, the given value must be converted to the
  shortest possible string representing the number as a <a>valid non-negative integer</a> and then
  that string must be used as the new content attribute value.

  If a reflecting IDL attribute has an <em>unsigned</em> integer type (<code>unsigned long</code>)
  then, on getting, the content attribute must be parsed according to the <a>rules for parsing
  non-negative integers</a>, and if that is successful, and the value is in the range 0 to
  2147483647 inclusive, the resulting value must be returned. If, on the other hand, it fails or
  returns an out of range value, or if the attribute is absent, the default value must be returned
  instead, or 0 if there is no default value. On setting, first, if the new value is in the range
  0 to 2147483647, then let <var>n</var> be the new value, otherwise let <var>n</var> be the
  default value, or 0 if there is no default value; then, <var>n</var> must be converted to the
  shortest possible string representing the number as a <a>valid non-negative integer</a> and that
  string must be used as the new content attribute value.

  If a reflecting IDL attribute has an unsigned integer type (<code>unsigned long</code>) that is
  <dfn>limited to only non-negative numbers greater than zero</dfn>, then the behavior is similar
  to the previous case, but zero is not allowed. On getting, the content attribute must first be
  parsed according to the <a>rules for parsing non-negative integers</a>, and if that is
  successful, and the value is in the range 1 to 2147483647 inclusive, the resulting value must be
  returned. If, on the other hand, it fails or returns an out of range value, or if the attribute
  is absent, the default value must be returned instead, or 1 if there is no default value. On
  setting, if the value is zero, the user agent must throw an <code>IndexSizeError</code>
  exception. Otherwise, first, if the new value is in the range 1 to 2147483647, then let
  <var>n</var> be the new value, otherwise let <var>n</var> be the default value, or 1 if there is
  no default value; then, <var>n</var> must be converted to the shortest possible string
  representing the number as a <a>valid non-negative integer</a> and that string must be used as
  the new content attribute value.

  If a reflecting IDL attribute has a floating-point number type (<code>double</code> or
  <code>unrestricted double</code>), then, on getting, the content attribute must be parsed
  according to the <a>rules for parsing floating-point number values</a>, and if that is
  successful, the resulting value must be returned. If, on the other hand, it fails, or if the
  attribute is absent, the default value must be returned instead, or 0.0 if there is no default
  value. On setting, the given value must be converted to the
  <a lt="best floating-point number">best representation of the number as a floating-point number</a>
  and then that string must be used as the new content attribute value.

  If a reflecting IDL attribute has a floating-point number type (<code>double</code> or
  <code>unrestricted double</code>) that is <dfn>limited to numbers greater than zero</dfn>, then
  the behavior is similar to the previous case, but zero and negative values are not allowed. On
  getting, the content attribute must be parsed according to the <a>rules for parsing
  floating-point number values</a>, and if that is successful and the value is greater than 0.0,
  the resulting value must be returned. If, on the other hand, it fails or returns an out of range
  value, or if the attribute is absent, the default value must be returned instead, or 0.0 if
  there is no default value. On setting, if the value is less than or equal to zero, then the
  value must be ignored. Otherwise, the given value must be converted to the
  <a lt="best floating-point number">best representation of the number as a floating-point number</a>
  and then that string must be used as the new content attribute value.

  <p class="note">
    The values Infinity and Not-a-Number (NaN) values throw an exception on setting, as defined in
    the Web IDL specification. [[!WEBIDL]]
  </p>

  If a reflecting IDL attribute has the type {{DOMTokenList}}, then on getting it must return a
  {{DOMTokenList}} object whose associated element is the element in question and whose associated
  attribute's local name is the name of the attribute in question. The same {{DOMTokenList}}
  object must be returned every time for each attribute.

  If a reflecting IDL attribute has the type {{HTMLElement}}, or an interface that
  descends from {{HTMLElement}}, then, on getting, it must run the following algorithm
  (stopping at the first point where a value is returned):

  1. If the corresponding content attribute is absent, then the IDL attribute must return null.
  2. Let <var>candidate</var> be the element that the <code>document.getElementById()</code>
      method would find when called on the content attribute's element's <a>node document</a> if
      it were passed as its argument the current value of the corresponding content attribute.
  3. If <var>candidate</var> is null, or if it is not type-compatible with the IDL attribute, then
      the IDL attribute must return null.
  4. Otherwise, it must return <var>candidate</var>.

  On setting, if the given element has an <code>id</code> attribute, and has the same
  <a>home subtree</a> as the element of the attribute being set, and the given element is the
  first element in that <a>home subtree</a> whose <a>ID</a> is the value of that <code>id</code>
  attribute, then the content attribute must be set to the value of that <code>id</code>
  attribute. Otherwise, the content attribute must be set to the empty string.

<h4 id="collections">Collections</h4>

  The {{HTMLFormControlsCollection}} and {{HTMLOptionsCollection}} interfaces are
  <a lt="collection">collections</a> derived from the {{HTMLCollection}} interface. The
  {{HTMLAllCollection}} however, is independent as it has a variety of unique quirks that are not
  desirable to inherit from {{HTMLCollection}}.

<h5 id="the-htmlallcollection-interface">The <code>HTMLAllCollection</code> interface</h5>

  The <code>HTMLAllCollection</code> interface is used for the legacy <code>document.all</code>
  attribute. It operates similarly to <code>HTMLCollection</code>; it also supports a variety of
  other legacy features required for web compatibility such as the ability to be invoked like a
  function (<code>legacycaller</code>).

  <p class="note">
    All <code>HTMLAllCollection</code> objects are rooted at a {{Document}} and have a filter that
    matches all elements, so the elements <a>represented by the collection</a> of an
    {{HTMLAllCollection}} object consist of all the descendant elements of the root {{Document}}.
  </p>

  <pre class="idl" data-highlight="webidl" dfn-for="HTMLAllCollection">
    [LegacyUnenumerableNamedProperties]
    interface HTMLAllCollection {
      readonly attribute unsigned long length;
      getter Element? (unsigned long index);
      getter (HTMLCollection or Element)? namedItem(DOMString name);
      legacycaller (HTMLCollection or Element)? item(optional DOMString nameOrItem);
    };
  </pre>

  <dl class="domintro">
    <dt><var>collection</var> . {{HTMLAllCollection/length}}</dt>
    <dd>Returns the number of elements in the collection.</dd>

    <dt><var>element</var> = <var>collection</var> . {{HTMLAllCollection/item()|item}}(<var>index</var>)</dt>
    <dt><var>element</var> = <var>collection</var>(<var>index</var>)</dt>
    <dt><var>element</var> = <var>collection</var>[<var>index</var>]</dt>
    <dd>Returns the item with index <var>index</var> from the collection (determined by
    <a>tree order</a>.</dd>

    <dt><var>element</var> = <var>collection</var> . {{HTMLAllCollection/item()|item}}(<var>name</var>)</dt>
    <dt><var>collection</var> = <var>collection</var> . {{HTMLAllCollection/item()|item}}(<var>name</var>)</dt>
    <dt><var>element</var> = <var>collection</var> . {{HTMLAllCollection/namedItem()|namedItem}}(<var>name</var>)</dt>
    <dt><var>collection</var> = <var>collection</var> . {{HTMLAllCollection/namedItem()|namedItem}}(<var>name</var>)</dt>
    <dt><var>element</var> = <var>collection</var>(<var>name</var>)</dt>
    <dt><var>collection</var> = <var>collection</var>(<var>name</var>)</dt>
    <dt><var>element</var> = <var>collection</var>[<var>name</var>]</dt>
    <dt><var>collection</var> = <var>collection</var>[<var>name</var>]</dt>
    <dd>Returns the item with <a>ID</a> or name <var>name</var> from the collection.

    If there are multiple matching items, then an {{HTMLCollection}} object containing all those
    elements is returned.

    The <{formelements/name}> attribute's value provides a name for <{button}>, <{input}>,
    <{select}>, and <{textarea}>. Similarly, <{iframe}>'s <{iframe/name}>, <{object}>'s
    <{object/name}>, <{meta}>'s <{meta/name}>, <{map}>'s <{map/name}>, and <{form}>'s <{form/name}>
    attribute's value provides a name for their respective elements. Only the elements mentioned
    have a <dfn lt="named for the all collection">name</dfn> for the purpose of this method.</dd>
  </dl>

  The object's <a>supported property indices</a> are as defined for <code>HTMLCollection</code>
  objects.

  The <a spec="webidl">supported property names</a> consist of the non-empty values of all the
  <{global/id}> and <a lt="named for the all collection">name</a> attributes of all the elements
  <a>represented by the collection</a>, in <a>tree order</a>, ignoring later duplicates, with the
  <{global/id}> of an element preceding its <a lt="named for the all collection">name</a> if it
  contributes both, they differ from each other, and neither is the duplicate of an earlier entry.

  On getting, the <dfn attribute for="HTMLAllCollection"><code>length</code></dfn> attribute must
  return the number of nodes <a>represented by the collection</a>.

  The indexed property getter must return the result of
  <a lt="get all-indexed">getting the "all"-indexed element</a> from this {{HTMLAllCollection}}
  given the passed index.

  The <dfn method for="HTMLAllCollection"><code>namedItem(<var>name</var>)</code></dfn> method
  must return the result of <a lt="get all-named">getting the "all"-named element or elements</a>
  from this {{HTMLAllCollection}} given <var>name</var>.

  The <dfn method for="HTMLAllCollection"><code>item(<var>nameOrIndex</var>)</code></dfn> method
  (and the <code>legacycaller</code> behavior) must act according to the following algorithm:

  1. If <var>nameOrIndex</var> was not provided, return null.
  2. If <var>nameOrIndex</var>, <a>converted</a> to a JavaScript string value, is an
      <a>array index property name</a>, return the result of
      <a lt="get all-indexed">getting the "all"-indexed element</a> from this {{HTMLAllCollection}}
      given the number represented by <var>nameOrIndex</var>.
  3. Return the result of <a lt="get all-named">getting the "all"-named element or elements</a> from
      this {{HTMLAllCollection}} given <var>nameOrIndex</var>.

  The following elements are considered <dfn>"all"-named elements</dfn>: <{a}>, <{applet}>,
  <{button}>, <{embed}>, <{form}>, <{frame}>, <{frameset}>, <{iframe}>, <{img}>, <{input}>, <{map}>,
  <{meta}>, <{object}>, <{select}>, and <{textarea}>.

  To <dfn lt="get all-indexed">get the "all"-indexed element</dfn> from an
  {{HTMLAllCollection}} <var>collection</var> given an index <var>index</var>, return the element
  with index <var>index</var> in <var>collection</var>, or null if there is no such element at
  <var>index</var>.

  To
  <dfn lt="get all-named">get the "all"-named element or elements</dfn>
  from an {{HTMLAllCollection}} <var>collection</var> given a name <var>name</var>, run the
  following algorithm:

  1. If <var>name</var> is the empty string, return null.
  2. Let <var>subCollection</var> be an <code>HTMLCollection</code> object rooted at the same
      {{Document}} as <var>collection</var>, whose filter matches only elements that are either:
      * <a>"all"-named elements</a> with a <a lt="named for the all collection">name</a> attribute
         equal to <var>name</var>, or,
      * elements with an <a>ID</a> equal to <var>name</var>.
  3. If there is exactly one element in <var>subCollection</var>, then return that element.
  4. Otherwise, if <var>subCollection</var> is empty, return null.
  5. Otherwise, return <var>subCollection</var>.

<h5 id="the-htmlformcontrolscollection-interface">The <code>HTMLFormControlsCollection</code> interface</h5>

  The <code>HTMLFormControlsCollection</code> interface is used for <a lt="collection">collections</a> of
  <a>listed elements</a> in <{form}> elements.

  <pre class="idl" data-highlight="webidl" dfn-for="HTMLFormControlsCollection">
    interface HTMLFormControlsCollection : HTMLCollection {
      // inherits length and item()
      getter (RadioNodeList or Element)? namedItem(DOMString name); // shadows inherited namedItem()
    };
  </pre>

  <pre class="idl" data-highlight="webidl" dfn-for="RadioNodeList">
    interface RadioNodeList : NodeList {
      attribute DOMString value;
    };
  </pre>

  <dl class="domintro">
    <dt><var>collection</var> . <code>length</code></dt>
    <dd>Returns the number of elements in the collection.</dd>

    <dt><var>element</var> = <var>collection</var> . <code>item</code>(<var>index</var>)</dt>
    <dt><var>element</var> = <var>collection</var>[<var>index</var>]</dt>
    <dd>
      Returns the item with index <var>index</var> from the collection. The items are sorted in
      <a>tree order</a>.
    </dd>

    <dt><var>element</var> = <var>collection</var> . <code>namedItem</code>(<var>name</var>)</dt>
    <dt>
      <var>radioNodeList</var> = <var>collection</var> . <code>namedItem</code>(<var>name</var>)
    </dt>
    <dt><var>element</var> = <var>collection</var>[<var>name</var>]</dt>
    <dt><var>radioNodeList</var> = <var>collection</var>[<var>name</var>]</dt>
    <dd>
      Returns the item with <a>ID</a> or <code>name</code> <var>name</var> from the collection.

      If there are multiple matching items, then a <code>RadioNodeList</code> object containing all
      those elements is returned.
    </dd>

    <dt><var>radioNodeList</var> . <var>value</var> [ = <var>value</var> ]</dt>
    <dd>
      Returns the value of the first checked radio button represented by the object.

      Can be set, to check the first radio button with the given value represented by the object.
    </dd>
  </dl>

  The object's <a>supported property indices</a> are as defined for <code>HTMLCollection</code>
  objects.

  The <a spec="webidl">supported property names</a> consist of the non-empty values of all the <code>id</code>
  and <code>name</code> attributes of all the elements <a>represented by the collection</a>, in
  <a>tree order</a>, ignoring later duplicates, with the <code>id</code> of an element preceding
  its <code>name</code> if it contributes both, they differ from each other, and neither is the
  duplicate of an earlier entry.

  The properties exposed in this way must be <a>unenumerable</a>.

  The <dfn method for="HTMLFormControlsCollection"><code>namedItem(<var>name</var>)</code></dfn> method must act according to the
  following algorithm:

  1. If <var>name</var> is the empty string, return null and stop the algorithm.
  2. If, at the time the method is called, there is exactly one node in the collection that has
      either an <code>id</code> attribute or a <code>name</code> attribute equal to
      <var>name</var>, then return that node and stop the algorithm.
  3. Otherwise, if there are no nodes in the collection that have either an <code>id</code>
      attribute or a <code>name</code> attribute equal to <var>name</var>, then return null and
      stop the algorithm.
  4. Otherwise, create a new <code>RadioNodeList</code> object representing a <a>live</a> view of
      the <code>HTMLFormControlsCollection</code> object, further filtered so that the only nodes
      in the <code>RadioNodeList</code> object are those that have either an <code>id</code>
      attribute or a <code>name</code> attribute equal to <var>name</var>. The nodes in the
      <code>RadioNodeList</code> object must be sorted in <a>tree order</a>.
  5. Return that <code>RadioNodeList</code> object.

  <hr />

  Members of the <code>RadioNodeList</code> interface inherited from the <code>NodeList</code>
  interface must behave as they would on a <code>NodeList</code> object.

  The {{RadioNodeList/value}} IDL attribute on the <code>RadioNodeList</code> object, on
  getting, must return the value returned by running the following steps:

  1. Let <var>element</var> be the first element in <a>tree order</a> represented by the
      <code>RadioNodeList</code> object that is an <{input}> element whose
      <code>type</code> attribute is in the <a element-state for="input">Radio Button</a> state and whose <a for="forms">checkedness</a>
      is true. Otherwise, let it be null.
  2. If <var>element</var> is null, return the empty string.
  3. If <var>element</var> is an element with no <code>value</code> attribute, return the string
      "<code>on</code>".
  4. Otherwise, return the value of <var>element</var>'s <code>value</code> attribute.

  On setting, the <code>value</code> IDL attribute must run the following steps:

  1. If the new value is the string "<code>on</code>": let <var>element</var> be the first element
      in <a>tree order</a> represented by the <code>RadioNodeList</code> object that is an
      <{input}> element whose <code>type</code> attribute is in the <a element-state for="input">Radio Button</a>
      state and whose <code>value</code> content attribute is either absent, or present and equal
      to the new value, if any. If no such element exists, then instead let <var>element</var> be
      null.

      Otherwise: let <var>element</var> be the first element in <a>tree order</a>
      represented by the <code>RadioNodeList</code> object that is an <{input}> element
      whose <code>type</code> attribute is in the <a element-state for="input">Radio Button</a> state and whose
      <code>value</code> content attribute is present and equal to the new value, if any. If no
      such element exists, then instead let <var>element</var> be null.
  2. If <var>element</var> is not null, then set its <a for="forms">checkedness</a> to true.

<h5 id="the-htmloptionscollection-interface">The <code>HTMLOptionsCollection</code> interface</h5>

  The <code>HTMLOptionsCollection</code> interface is used for <a lt="collection">collections</a> of
  <{option}> elements. It is always rooted on a <{select}> element and has
  attributes and methods that manipulate that element's descendants.

  <pre class="idl" data-highlight="webidl" dfn-for="HTMLOptionsCollection">
    interface HTMLOptionsCollection : HTMLCollection {
      // inherits item(), namedItem()
      attribute unsigned long length; // shadows inherited length
      setter void (unsigned long index, HTMLOptionElement? option);
      void add((HTMLOptionElement or HTMLOptGroupElement) element, optional (HTMLElement or long)? before = null);
      void remove(long index);
      attribute long selectedIndex;
    };
  </pre>

  <dl class="domintro">
    <dt><var>collection</var> . <code>length</code> [ = <var>value</var> ]</dt>
    <dd>
      Returns the number of elements in the collection.

      When set to a smaller number, truncates the number of <{option}> elements in the
      corresponding container.

      When set to a greater number, adds new blank <{option}> elements to that container.
    </dd>

    <dt><var>element</var> = <var>collection</var> . <code>item</code>(<var>index</var>)</dt>
    <dt><var>element</var> = <var>collection</var>[<var>index</var>]</dt>
    <dd>
      Returns the item with index <var>index</var> from the collection. The items are sorted in
      <a>tree order</a>.
    </dd>

    <dt><var>collection</var>[<var>index</var>] = <var>element</var></dt>
    <dd>
      When <var>index</var> is a greater number than the number of items in the collection, adds
      new blank <{option}> elements in the corresponding container.

      When set to null, removes the item at index <var>index</var> from the collection.

      When set to an <{option}> element, adds or replaces it at index <var>index</var>
      from the collection.
    </dd>

    <dt><var>element</var> = <var>collection</var> . <code>namedItem</code>(<var>name</var>)</dt>
    <dt><var>element</var> = <var>collection</var>[<var>name</var>]</dt>
    <dd>
      Returns the item with <a>ID</a> or <code>name</code> <var>name</var> from the collection.

      If there are multiple matching items, then the first is returned.
    </dd>

    <dt><var>collection</var> . <code>add</code>(<var>element</var> [, <var>before</var> ] )</dt>
    <dd>
      Inserts <var>element</var> before the node given by <var>before</var>.

      The <var>before</var> argument can be a number, in which case <var>element</var> is inserted
      before the item with that number, or an element from the collection, in which case
      <var>element</var> is inserted before that element.

      If <var>before</var> is omitted, null, or a number out of range, then <var>element</var> will
      be added at the end of the list.

      This method will throw a <code>HierarchyRequestError</code> exception if <var>element</var> is
      an ancestor of the element into which it is to be inserted.
    </dd>

    <dt><var>collection</var> . <code>remove</code>(<var>index</var>)</dt>
    <dd>Removes the item with index <var>index</var> from the collection.</dd>

    <dt><var>collection</var> . <code>selectedIndex</code> [ = <var>value</var> ]</dt>
    <dd>
      Returns the index of the first selected item, if any, or -1 if there is no selected
      item.

      Can be set, to change the selection.
    </dd>
  </dl>

  The object's <a>supported property indices</a> are as defined for <code>HTMLCollection</code>
  objects.

  On getting, the <dfn attribute for="HTMLOptionsCollection"><code>length</code></dfn> attribute must return the number of nodes
  <a>represented by the collection</a>.

  On setting, the behavior depends on whether the new value is equal to, greater than, or less than
  the number of nodes <a>represented by the collection</a> at that time. If the number is the same,
  then setting the attribute must do nothing. If the new value is greater, then <var>n</var> new
  <{option}> elements with no attributes and no child nodes must be appended to the
  <{select}> element on which the <code>HTMLOptionsCollection</code> is rooted, where
  <var>n</var> is the difference between the two numbers (new value minus old value). Mutation
  events must be fired as if a <code>DocumentFragment</code> containing the new <code>option</code>
  elements had been inserted. If the new value is lower, then the last <var>n</var> nodes in the
  collection must be removed from their parent nodes, where <var>n</var> is the difference between
  the two numbers (old value minus new value).

  <p class="note">
    Setting <code>length</code> never removes or adds any <{optgroup}> elements, and never
    adds new children to existing <{optgroup}> elements (though it can remove children from
    them).
  </p>

  The <a spec="webidl">supported property names</a> consist of the non-empty values of all the <code>id</code> and
  <code>name</code> attributes of all the elements <a>represented by the collection</a>, in
  <a>tree order</a>, ignoring later duplicates, with the <code>id</code> of an element preceding its
  <code>name</code> if it contributes both, they differ from each other, and neither is the
  duplicate of an earlier entry.

  The properties exposed in this way must be <a>unenumerable</a>.

  When the user agent is to <dfn>set the value of a new indexed property or set the value of an
  existing indexed property</dfn> for a given property index <var>index</var> to a new value
  <var>value</var>, it must run the following algorithm:

  1. If <var>value</var> is null, invoke the steps for the <code>remove</code> method with
      <var>index</var> as the argument, and abort these steps.
  2. Let <var>length</var> be the number of nodes <a>represented by the collection</a>.
  3. Let <var>n</var> be <var>index</var> minus <var>length</var>.
  4. If <var>n</var> is greater than zero, then <a>append</a> a <code>DocumentFragment</code>
      consisting of <var>n</var>-1 new <{option}> elements with no attributes and no
      child nodes to the <{select}> element on which the <code>HTMLOptionsCollection</code>
      is rooted.
  5. If <var>n</var> is greater than or equal to zero, <a>append</a> <var>value</var> to the
      <{select}> element. Otherwise, <a>replace</a> the <var>index</var>th element in the
      collection by <var>value</var>.

  The <dfn method for="HTMLOptionsCollection"><code>add(<var>element</var>, <var>before</var>)</code></dfn> method must act according
  to the following algorithm:

  1. If <var>element</var> is an ancestor of the <{select}> element on which the
      <code>HTMLOptionsCollection</code> is rooted, then throw a <code>HierarchyRequestError</code>
      exception and abort these steps.
  2. If <var>before</var> is an element, but that element isn't a descendant of the
      <{select}> element on which the <code>HTMLOptionsCollection</code> is rooted, then
      throw a <code>NotFoundError</code> exception and abort these steps.
  3. If <var>element</var> and <var>before</var> are the same element, then return and abort these
      steps.
  4. If <var>before</var> is a node, then let <var>reference</var> be that node. Otherwise, if
      <var>before</var> is an integer, and there is a <var>before</var>th node in the collection,
      let <var>reference</var> be that node. Otherwise, let <var>reference</var> be null.
  5. If <var>reference</var> is not null, let <var>parent</var> be the parent node of
      <var>reference</var>. Otherwise, let <var>parent</var> be the <{select}> element on
      which the <code>HTMLOptionsCollection</code> is rooted.
  6. Act as if the DOM <code>insertBefore()</code> method was invoked on the <var>parent</var> node,
      with <var>element</var> as the first argument and <var>reference</var> as the second argument.

  The <dfn method for="HTMLOptionsCollection"><code>remove(<var>index</var>)</code></dfn> method must act according to the following
  algorithm:

  1. If the number of nodes <a>represented by the collection</a> is zero, abort these steps.
  2. If <var>index</var> is not a number greater than or equal to 0 and less than the number of
      nodes <a>represented by the collection</a>, abort these steps.
  3. Let <var>element</var> be the <var>index</var>th element in the collection.
  4. Remove <var>element</var> from its parent node.

  The <dfn attribute for="HTMLOptionsCollection"><code>selectedIndex</code></dfn> IDL attribute must act like the identically named
  attribute on the <{select}> element on which the <code>HTMLOptionsCollection</code> is
  rooted

<h4 id="the-domstringmap-interface">The <code>DOMStringMap</code> interface</h4>

  The <code>DOMStringMap</code> interface represents a set of name-value pairs. It exposes these
  using the scripting language's native mechanisms for property access.

  When a <code>DOMStringMap</code> object is instantiated, it is associated with three algorithms,
  one for getting the list of name-value pairs, one for setting names to certain values, and one for
  deleting names.

  <pre class="idl" data-highlight="webidl" dfn-for="DOMStringMap">
    [OverrideBuiltins]
    interface DOMStringMap {
      getter DOMString (DOMString name);
      setter void (DOMString name, DOMString value);
      deleter void (DOMString name);
    };
  </pre>

  The <a spec="webidl">supported property names</a> on a <code>DOMStringMap</code> object at any instant are the
  names of each pair returned from the algorithm for getting the list of name-value pairs at that
  instant, in the order returned.

  To <a spec="webidl">determine the value of a named property</a> <var>name</var> in a
  {{DOMStringMap}}, the user agent must return the value component of the name-value pair
  whose name component is <var>name</var> in the list returned by the algorithm for getting the list
  of name-value pairs.

  To <a for="values" lt="setting">set</a> the value of a named property <var>name</var> to value <var>value</var>, the
  algorithm for setting names to certain values must be run, passing <var>name</var> as the name and
  <var>value</var> as the value.

  To <dfn>delete an existing named property</dfn> <var>name</var>, the algorithm for deleting names
  must be run, passing <var>name</var> as the name.

  <p class="note">
    The <code>DOMStringMap</code> interface definition here is only intended for JavaScript
    environments. Other language bindings will need to define how <code>DOMStringMap</code> is to be
    implemented for those languages.
  </p>

<div class="example">
  The <code>dataset</code> attribute on elements exposes the <code>data-*</code> attributes on the
  element.

  Given the following fragment and elements with similar constructions:

  <pre highlight="html">&lt;img class="tower" id="tower5" data-x="12" data-y="5" data-ai="robotarget" data-hp="46" data-ability="flames" src="towers/rocket.png" alt="Rocket Tower"></pre>

  ...one could imagine a function <code>splashDamage()</code> that takes some arguments, the first
  of which is the element to process:

  <pre highlight="javascript">
    function splashDamage(node, x, y, damage) {
      if (node.classList.contains('tower') && // checking the 'class' attribute
          node.dataset.x == x && // reading the 'data-x' attribute
          node.dataset.y == y) { // reading the 'data-y' attribute
        var hp = parseInt(node.dataset.hp); // reading the 'data-hp' attribute
        hp = hp - damage;
        if (hp &lt; 0) {
          hp = 0;
          node.dataset.ai = 'dead'; // setting the 'data-ai' attribute
          delete node.dataset.ability; // removing the 'data-ability' attribute
        }
        node.dataset.hp = hp; // setting the 'data-hp' attribute
      }
    }
  </pre>
</div>

<h4 id="the-domelementmap-interface">The <code>DOMElementMap</code> interface</h4>

  The <code>DOMElementMap</code> interface represents a set of name-element mappings. It exposes
  these using the scripting language's native mechanisms for property access.


  When a <code>DOMElementMap</code> object is instantiated, it is associated with three algorithms,
  one for getting the list of name-element mappings, one for mapping a name to a certain element,
  and one for deleting mappings by name.

  <pre class="idl" data-highlight="webidl" dfn-for="DOMElementMap">
    interface DOMElementMap {
      getter Element (DOMString name);
      setter creator void (DOMString name, Element value);
      deleter void (DOMString name);
    };
  </pre>

  The <a spec="webidl">supported property names</a> on a <code>DOMElementMap</code> object at any instant are the
  names for each mapping returned from the algorithm for getting the list of name-element mappings
  at that instant, in the order returned.

  To <a spec="webidl">determine the value of a named property</a> <var>name</var> in a
  <code>DOMElementMap</code>, the user agent must return the element component of the name-element
  mapping whose name component is <var>name</var> in the list returned by the algorithm for getting
  the list of name-element mappings.

  To set the value of a <dfn>new</dfn> or <dfn>existing</dfn> named property <var>name</var> to
  value <var>value</var>, the algorithm for mapping a name to a certain element must be run, passing
  <var>name</var> as the name <var>value</var> as the element.

  To <a>delete an existing named property</a> <var>name</var>, the algorithm for deleting
  mappings must be run, passing <var>name</var> as the name component of the mapping to be deleted.

  <p class="note">
    The <code>DOMElementMap</code> interface definition here is only intended for JavaScript
    environments. Other language bindings will need to define how <code>DOMElementMap</code> is to
    be implemented for those languages.
  </p>

<h4 id="garbage-collection">Garbage collection</h4>

  There is an <dfn>implied strong reference</dfn> from any IDL attribute that returns a pre-existing
  object to that object.

  <div class="example">
    For example, the <code>window.document</code> attribute on the {{Window}} object means that there is a strong reference
    from a {{Window}} object to its {{Document}} object. Similarly, there is
    always a strong reference from a {{Document}} to any descendant nodes, and from any
    node to its owner <a>node document</a>.
  </div>

<h3 id="namespaces">Namespaces</h3>

  The <dfn>HTML namespace</dfn> is: <code>http://www.w3.org/1999/xhtml</code>

  The <dfn>MathML namespace</dfn> is: <code>http://www.w3.org/1998/Math/MathML</code>

  The <dfn>SVG namespace</dfn> is: <code>http://www.w3.org/2000/svg</code>

  The <dfn>XLink namespace</dfn> is: <code>http://www.w3.org/1999/xlink</code>

  The <dfn>XML namespace</dfn> is: <code>http://www.w3.org/XML/1998/namespace</code>

  The <dfn>XMLNS namespace</dfn> is: <code>http://www.w3.org/2000/xmlns/</code>

  <hr />

  Data mining tools and other user agents that perform operations on content without running
  scripts, evaluating CSS or XPath expressions, or otherwise exposing the resulting DOM to arbitrary
  content, may "support namespaces" by just asserting that their DOM node analogs are in certain
  namespaces, without actually exposing the above strings.

  <hr />

  <p class="note">
    In <a href="#syntax">the HTML syntax</a>, namespace prefixes and namespace declarations do not have the same
    effect as in XML. For instance, the colon has no special meaning in HTML element names.
  </p>

<h3 id="safe-passing-of-structured-data">Safe passing of structured data</h3>

  This section uses the terminology and typographic conventions from the JavaScript specification.
  [[ECMA-262]]

<h4 id="section-cloneable-objects"><dfn>Cloneable objects</dfn></h4>

  <a>Cloneable objects</a> support being cloned across <a>event loops</a>. That is, they support
  being cloned across {{Document}} and {{Worker}} boundaries, including across {{Document}}s of
  different <a for="concept">origins</a>. Not all objects are <a>cloneable objects</a> and not all
  aspects of objects that are <a>cloneable objects</a> are necessarily preserved when cloned.

  <a>Platform objects</a> have the following internal method:

  [[<dfn for="structured">Clone</dfn>]] ( <var>targetRealm</var>, <var>memory</var> )

  Unless specified otherwise, invoking the [[<a for="structured">Clone</a>]] internal method must
  throw a "{{DataCloneError}}" {{DOMException}}. (By default, <a>platform objects</a> are not
  <a>cloneable objects</a>.)

  <a>Platform objects</a> that are <a>cloneable objects</a> have a [[<a for="structured">Clone</a>]]
  internal method which is specified to run a series of steps. The result of running those steps
  must be a thrown exception or a clone of <em>this</em>, created in <var>targetRealm</var>. It is
  up such objects to define what cloning means for them.

  Objects defined in the JavaScript specification are handled by the <a>StructuredClone</a> abstract
  operation directly.

<h4 id="section-transferable-objects"><dfn>Transferable objects</dfn></h4>

  <a>Transferable objects</a> support being transferred across <a>event loops</a>. Transferring is
  effectively recreating the object while sharing a reference to the underlying data and then
  detaching the object being transferred. This is useful to transfer ownership of expensive
  resources. Not all objects are <a>transferable objects</a> and not all aspects of objects that are
  <a>transferable objects</a> are necessarily preserved when transferred.

  <p class="note">Transferring is an irreversible and non-idempotent operation. Once an object has
  been transferred, it cannot be transferred, or indeed used, again.</p>

  <a>Platform objects</a> that are <a>transferable objects</a> have a [[<dfn>Detached</dfn>]]
  internal slot and the following internal method:

  [[<dfn>Transfer</dfn>]] ( <var>targetRealm</var> )

  <p class="note">Whereas all <a>platform objects</a> have a [[<a for="structured">Clone</a>]]
  internal method, not all have a [[<a>Detached</a>]] internal slot and a [[<a>Transfer</a>]]
  internal method.</p>

  <a>Platform objects</a> that are <a>transferable objects</a> must define the [[<a>Transfer</a>]]
  internal method such that it either throws an exception or returns a clone of <em>this</em>,
  created in <var>targetRealm</var>, with <em>this</em>'s underlying data shared with the return
  value, and <em>this</em>'s [[<a>Detached</a>]] internal slot value set to true. It is up to such
  objects to define what transfering means for them.

  Objects defined in the JavaScript specification are handled by the
  <a>StructuredCloneWithTransfer</a> abstract operation directly. (Technically, by
  <a>IsTransferable</a> and <a>TransferHelper</a>.)

<h4 id="section-structuredclonewithtransfer"><dfn>StructuredCloneWithTransfer</dfn> ( <var>input</var>, <var>transferList</var>, <var>targetRealm</var> )</h4>

  1. Let <var>memory</var> be an empty map.
      <p class="note">The purpose of the memory map, both here and in the <a>StructuredClone</a>
      abstract operation, is to avoid cloning objects twice. This ends up preserving cycles and the
      identity of duplicate objects in graphs.</p>
  2. For each object <var>transferable</var> in <var>transferList</var>:
      1. If <a>IsTransferable</a>(<var>transferable</var>) is false, then throw a
          "{{DataCloneError}}" {{DOMException}}.
      2. Let <var>placeholder</var> be a user-agent-defined placeholder object.
      3. Create an entry in <var>memory</var> with key <var>transferable</var> and value
          <var>placeholder</var>.
  3. Let <var>clone</var> be the result of ? <a>StructuredClone</a>(<var>input</var>,
      <var>targetRealm</var>, <var>memory</var>).
  4. Let <var>outputTransferList</var> be a new empty <a for="ecma">List</a>.
  5. For each object <var>transferable</var> in <var>transferList</var>:
      1. Let <var>placeholderResult</var> be the value of the entry in <var>memory</var> whose key
          is <var>transferable</var>.
      2. Let <var>transferResult</var> be ? <a>TransferHelper</a>(<var>transferable</var>,
          <var>targetRealm</var>).
      3. Within <var>clone</var>, replace references to <var>placeholderResult</var> with
          <var>transferResult</var>, such that everything holding a reference to
          <var>placeholderResult</var>, now holds a reference to <var>transferResult</var>.

          <p class="note">This is a rather unusual low-level operation for which no primitives are defined by JavaScript.</p>
      4. Add <var>transferResult</var> as the last element of <var>outputTransferList</var>.
  6. Return { \[[Clone]]: <var>clone</var>, [[<var>transferList</var>]]:
      <var>outputTransferList</var> }.

  <p class="note">Originally the <a>StructuredCloneWithTransfer</a> abstract operation was known as
  the "structured clone" algorithm. The <a>StructuredClone</a> abstract operation was known as the
  "internal structured clone" algorithm. Transferring objects, now handled by the
  <a>StructuredCloneWithTransfer</a> abstract operation, were formerly handled by parts of the
  algorithm of the <code>postMessage()</code> method on the {{Window}} object and the
  <code>Window/postMessage()</code> method on the {{MessagePort}} object.</p>

<h4 id="section-structuredclone"><dfn>StructuredClone</dfn> ( <var>input</var>, <var>targetRealm</var> [ , <var>memory</var> ] )</h4>

  1. If <var>memory</var> was not supplied, let <var>memory</var> be an empty map.
  2. If <var>memory</var> contains an entry with key <var>input</var>, then return that entry's
      value.
  3. If <a for="ecma">Type</a>(<var>input</var>) is Undefined, Null, Boolean, String, or Number, then return
      <var>input</var>.
  4. If <a for="ecma">Type</a>(<var>input</var>) is Symbol, then throw a "{{DataCloneError}}" {{DOMException}}.
  5. Let <var>deepClone</var> be false.
  6. If <var>input</var> has a \[[BooleanData]] internal slot, then let <var>output</var> be a new
      Boolean object in <var>targetRealm</var> whose \[[BooleanData]] internal slot value is the
      \[[BooleanData]] internal slot value of <var>input</var>.
  7. Otherwise, if <var>input</var> has a \[[NumberData]] internal slot, then let <var>output</var>
      be a new Number object in <var>targetRealm</var> whose [NumberData]] internal slot value is
      the \[[NumberData]] internal slot value of <var>input</var>.
  8. Otherwise, if <var>input</var> has a \[[StringData]] internal slot, then let <var>output</var>
      be a new String object in <var>targetRealm</var> whose \[[StringData]] internal slot value is
      the \[[StringData]] internal slot value of <var>input</var>.
  9. Otherwise, if <var>input</var> has a \[[DateValue]] internal slot, then let <var>output</var>
      be a new Date object in <var>targetRealm</var> whose \[[DateValue]] internal slot value is the
      \[[DateValue]] internal slot value of <var>input</var>.
  10. Otherwise, if <var>input</var> has a \[[RegExpMatcher]] internal slot, then let
      <var>output</var> be a new RegExp object in <var>targetRealm</var> whose \[[RegExpMatcher]]
      internal slot value is the \[[RegExpMatcher]] internal slot value of <var>input</var>, whose
      \[[OriginalSource]] internal slot value is the \[[OriginalSource]] internal slot value of
      <var>input</var>, and whose whose \[[OriginalFlags]] internal slot value is the
      \[[OriginalFlags]] internal slot value of <var>input</var>.
  11. Otherwise, if <var>input</var> has an \[[ArrayBufferData]] internal slot, then:
       1. If <a>IsDetachedBuffer</a>(<var>input</var>) is true, then throw a "{{DataCloneError}}"
           {{DOMException}}.
       2. Let <var>outputArrayBuffer</var> be the <a>%ArrayBuffer%</a> intrinsic object in
           <var>targetRealm</var>.
       3. Let <var>output</var> be ? <a>CloneArrayBuffer</a>(<var>input</var>, 0,
           <var>outputArrayBuffer</var>).
  12. Otherwise, if <var>input</var> has a \[[ViewedArrayBuffer]] internal slot, then:
       1. Let <var>buffer</var> be the value of <var>input</var>'s \[[ViewedArrayBuffer]] internal
           slot.
       2. Let <var>bufferClone</var> be ? <a>StructuredClone</a>(<var>buffer</var>,
           <var>targetRealm</var>, <var>memory</var>)}}.
       3. If <var>input</var> has a \[[DataView]] internal slot, then let <var>output</var> be a
           new DataView object in <var>targetRealm</var> whose \[[DataView]] internal slot value is
           true, whose \[[ViewedArrayBuffer]] internal slot value is <var>bufferClone</var>, whose
           \[[ByteLength]] internal slot value is the \[[ByteLength]] internal slot value of
           <var>input</var>, and whose \[[ByteOffset]] internal slot value is the \[[ByteOffset]]
           internal slot value of <var>input</var>.
       4. Otherwise:
           1. Assert: <var>input</var> has a \[[TypedArrayName]] internal slot.
           2. Let <var>constructor</var> be the intrinsic object listed in column one of
               <a>The TypedArray Constructors</a> table for the value of
               <var>input</var>'s \[[TypedArrayName]] internal slot in <var>targetRealm</var>.
           3. Let <var>byteOffset</var> be <var>input</var>'s \[[ByteOffset]] internal slot value.
           4. Let <var>length</var> be <var>input</var>'s \[[ArrayLength]] internal slot value.
           5. Let <var>output</var> be ? <a>TypedArrayCreate</a>(<var>constructor</var>,
               « <var>bufferClone</var>, <var>byteOffset</var>, <var>length</var> »).
  13. Otherwise, if <var>input</var> has \[[MapData]] internal slot, then:
       1. Let <var>output</var> be a new Map object in <var>targetRealm</var> whose \[[MapData]]
           internal slot value is a new empty <a for="ecma">List</a>.
       2. Set <var>deepClone</var> to true.
  14. Otherwise, if <var>input</var> has \[[SetData]] internal slot, then:
       1. Let <var>output</var> be a new Set object in <var>targetRealm</var> whose \[[SetData]]
           internal slot value is a new empty <a for="ecma">List</a>.
       2. Set <var>deepClone</var> to true.
  15. Otherwise, if <var>input</var> is an Array exotic object, then:
       1. Let <var>inputLen</var> be <a>OrdinaryGetOwnProperty</a>(<var>input</var>,
           "<code>length</code>").\[[value]].
       2. Let <var>outputProto</var> be the <a>%ArrayPrototype%</a> intrinsic object in
           <var>targetRealm</var>.
       3. Let <var>output</var> be ! <a>ArrayCreate</a>(<var>inputLen</var>,
           <var>outputProto</var>).
       4. Set <var>deepClone</var> to true.
  16. Otherwise, if <var>input</var> has a [[<a for="structured">Clone</a>]] internal method, then
       let <var>output</var> be ?
       <var>input</var>.[[<a for="structured">Clone</a>]](<var>targetRealm</var>,
       <var>memory</var>).
  17. Otherwise, if <a>IsCallable</a>(<var>input</var>)}} is true, then throw a
       "{{DataCloneError}}" {{DOMException}}.
  18. Otherwise, if <var>input</var> has any internal slot other than \[[Prototype]] or
       \[[Extensible]], then throw a "{{DataCloneError}}" {{DOMException}}.
       <p class="example">For instance, a \[[PromiseState]] or \[[WeakMapData]] internal slot.</p>
  19. Otherwise, if <var>input</var> is an exotic object, then throw a "{{DataCloneError}}"
       {{DOMException}}.
       <p class="example">For instance, a proxy object.</p>
  20. Otherwise:
       1. Let <var>output</var> be a new Object in <var>targetRealm</var>.
       2. Set <var>deepClone</var> to true.
  21. Create an entry in <var>memory</var> whose key is <var>input</var> and value is
       <var>output</var>.
  22. If <var>deepClone</var> is true, then:
       1. If <var>input</var> has a \[[MapData]] internal slot, then:
           1. Let <var>inputList</var> the value of <var>input</var>'s \[[MapData]] internal slot.
           2. Let <var>copiedList</var> be a new empty <a for="ecma">List</a>.
           3. Repeat for each <a>Record</a> { \[[key]], \[[value]] } <var>entry</var> that is an
               element of <var>inputList</var>,
               1. Let <var>copiedEntry</var> be a new <a>Record</a> { \[[key]]:
                   <var>entry</var>.\[[key]], \[[value]]: <var>entry</var>.\[[value]] }.
               2. If <var>copiedEntry</var>.\[[key]] is not empty, append <var>copiedEntry</var> as
                   the last element of <var>copiedList</var>.
           4. Let <var>outputList</var> be the value of <var>output</var>'s \[[MapData]] internal
               slot.
           5. For each <a>Record</a> { \[[key]], \[[value]] } <var>entry</var> that is an element of
               <var>copiedList</var>,
               1. Let <var>outputKey</var> be ? <a>StructuredClone</a>(<var>entry</var>.\[[key]],
                   <var>targetRealm</var>, <var>memory</var>).
               2. Let <var>outputValue</var> be ?
                   <a>StructuredClone</a>(<var>entry</var>.\[[value]], <var>targetRealm</var>,
                   <var>memory</var>).
               3. Add { \[[key]]: <var>outputKey</var>, \[[value]]: <var>outputValue</var> } as the
                   last element of <var>outputList</var>.
       2. Otherwise, if <var>input</var> has a \[[SetData]] internal slot, then:
           1. Let <var>copiedList</var> be a copy of the value of <var>input</var>'s \[[SetData]]
               internal slot.
           2. Let <var>outputList</var> be the value of <var>output</var>'s \[[SetData]] internal
               slot.
           3. For each <var>entry</var> that is an element of <var>copiedList</var> that is not
               empty,
               1. Let <var>outputEntry</var> be ? <a>StructuredClone</a>(<var>entry</var>,
                   <var>targetRealm</var>, <var>memory</var>).
               2. Add <var>outputEntry</var> as the last element of <var>outputList</var>.
       3. Otherwise:
           1. Let <var>enumerableKeys</var> be a new empty <a for="ecma">List</a>.
           2. For each <var>key</var> in ! <var>input</var>.\[[OwnPropertyKeys]]():
               1. If <a for="ecma">Type</a>(<var>key</var>) is String, then:
                   1. Let <var>inputDesc</var> be !
                       <var>input</var>.\[[GetOwnProperty]](<var>key</var>).
                   2. If <var>inputDesc</var>.\[[Enumerable]] is true, then add <var>key</var> as
                       the last element of <var>enumerableKeys</var>.
           3. For each <var>key</var> in <var>enumerableKeys</var>:
               1. If ! <a>HasOwnProperty</a>(<var>input</var>, <var>key</var>) is true, then:
                   1. Let <var>inputValue</var> be ? <var>input</var>.\[[Get]](<var>key</var>,
                       <var>input</var>).
                   2. Let <var>outputValue</var> be ? <a>StructuredClone</a>(<var>inputValue</var>,
                       <var>targetRealm</var>, <var>memory</var>).
                   3. Perform ? <a>CreateDataProperty</a>(<var>output</var>, <var>key</var>,
                       <var>outputValue</var>).
  23. Return <var>output</var>.

  <p class="note">
    In general implementations will need to use some kind of serialization and marshalling to
    implement the creation of objects in <var>targetRealm</var>, as <var>targetRealm</var> could be
    in a different <a>event loop</a> and not easily accessible to the code that invokes
    <a>StructuredCloneWithTransfer</a> or <a>StructuredClone</a>.
  </p>

<h4 id="section-idistransferable"><dfn>IsTransferable</dfn> ( <var>O</var> )</h4>

  1. Assert: <a for="ecma">Type</a>(<var>O</var>) is Object.
  2. If <var>O</var> has an \[[ArrayBufferData]] internal slot, then:
      1. If <a>IsDetachedBuffer</a>(<var>O</var>) is true, then return false.
      2. Return true.
  3. Otherwise, if <var>O</var> has a [[<a>Detached</a>]] internal slot, then:
      1. If <var>O</var>'s [[<a>Detached</a>]] internal slot value is true, then return false.
      2. Return true.
  4. Return false.

<h4 id="section-transferhelper"><dfn>TransferHelper</dfn> ( <var>input</var>, <var>targetRealm</var> )</h4>

  1. If <var>input</var> has an \[[ArrayBufferData]] internal slot, then:
      1. Let <var>output</var> be a new {{ArrayBuffer}} object in <var>targetRealm</var> whose
          \[[ArrayBufferByteLength]] internal slot value is the \[[ArrayBufferByteLength]] internal
          slot value of <var>input</var>, and whose \[[ArrayBufferData]] internal slot value is the
          \[[ArrayBufferData]] internal slot value of <var>input</var>.
      2. Perform ! <a>DetachArrayBuffer</a>(<var>input</var>).
      3. Return <var>output</var>.
  2. Return ? <var>input</var>.[[<a>Transfer</a>]](<var>targetRealm</var>).

</section>
