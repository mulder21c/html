<section>
<!--
████████   ███████  ██     ██
██     ██ ██     ██ ███   ███
██     ██ ██     ██ ████ ████
██     ██ ██     ██ ██ ███ ██
██     ██ ██     ██ ██     ██
██     ██ ██     ██ ██     ██
████████   ███████  ██     ██
-->

<h2 id="dom">HTML 문서의 의미론, 구조, API</h2>

<h3 id="documents">문서</h3>

  HTML 유저 에이전트에서 모든 XML과 HTML 문서는 {{Document}} 객체로 표현됩니다.
  [[!DOM]]

  <dfn lt="the document address|address|the document's address|the address">문서의 주소</dfn>는
  <i>{{Document}}와 연관된 URL</i>입니다(DOM 표준에 정의된 대로). 그것은 {{Document}}가 생성될 때 
  초기에 설정되지만, {{Document}}의 수명 기간 동안 변경될 수 있습니다; 예를 들어, 사용자가 페이지의
  <a for="url" lt="fragment">문서 조각</a>으로 <a lt="navigates">이동</a>할 때 그리고 
  <code>pushState()</code> 메서드가 새로운 <a for="url">URL</a>을 가지고 호출 될 때 변경됩니다. [[!DOM]]

  <p class="warning">
    대화형 유저 에이전트들은 보통 유저 인터페이스에 <a lt="the document's address">문서의 주소</a>를 
    노출합니다. 이것은 사이트가 다른 사람으로 가장하려하는지를 사용자가 알 수 있는 주된 메커니즘입니다.
  </p>

  {{Document}}가 <code>createDocument()</code>나 <code>createHTMLDocument()</code> API를 사용하여
  <a for="concept" lt="script">스크립트</a>에 의해 생성되는 경우, <a lt="the document's address">문서의 주소</a>는
  스크립트의 <a lt="settings object">설정 객체</a>에 의해 명시된 <a lt="responsible document">신뢰할 수 있는 문서</a>의
  <a lt="the document's address">문서의 주소</a>와 동일하고, {{Document}}는 즉시 
  <a lt="ready for post-load tasks">로딩 후 작업에 대해 준비</a>되며 <a lt="completely loaded">완전히 로드</a>됩니다.

  <dfn lt="The document's referrer">문서의 리퍼러</dfn>는 {{Document}}가 생성될 때 설정될 수 있는
  <a lt="absolute URL">절대 URL</a>입니다. 이것이 명시적으로 설정되지 않는다면, 그 값은 빈 문자열입니다.

  각 {{Document}} 객체는 처음에는 설정되어 있지 않은 <dfn lt="reload override flag">리로드 재정의 플래그</dfn>를
  가집니다. 이 플래그는 특정한 상황에서 <code>document.open()</code>과 <a method lt="write()"><code>document.write()</code></a> 
  메서드에 의해 설정됩니다. 플래그가 설정 되는 경우, {{Document}}는 리로드 될 때 문서의 소스로
  사용되는 유니코드 문자열인 <dfn lt="reload override buffer">리로드 재정의 버퍼</dfn>를 가집니다.

  유저 에이전트가 <a lt="source browsing context">소스 브라우징 컨텍스트</a>가 주어진, 
  <dfn lt="overridden reload|an overridden reload">재정의 된 리로드</dfn>를 수행하려면, 다음과 같이 
  동작해야(must) 합니다:


  1. <var>source</var>를 <a lt="browsing context">브라우징 컨텍스트</a>의 <a lt="active document">활성 문서</a>의
      <a lt="reload override buffer">리로드 재정의 버퍼</a>의 값으로 둡니다.
  2. <var>address</var>를 <a lt="browsing context">브라우징 컨텍스트</a>의 <a lt="active document">활성 문서</a>의
      <a lt="document url">URL</a>로 둡니다.
  3. <var>HTTPS state</var>를 <a lt="browsing context">브라우징 컨텍스트</a>의 <a lt="active document">활성 문서</a>의 
      <a for="document" lt="HTTPS state">HTTPS 상태</a>로 둡니다.
  4. <var>CSP list</var>를 <a lt="browsing context">브라우징 컨텍스트</a>의 <a lt="active document">활성 문서</a>의 
       <a for="document" lt="CSP list">CSP 목록</a>으로 둡니다.
  5. <a lt="browsing context">브라우징 컨텍스트</a>를 <a lt="exceptions enabled flag">예외 활성화 플래그</a>와
      <a lt="replacement enabled">교체 활성화</a>를 가지고 <a for="response">body</a>가 <var>source</var>이고,
      <a for="response" lt="CSP list">CSP 목록</a>이 <var>CSP list</var>이고 <a for="response" lt="HTTPS state">HTTP 상태</a>가
      <var>HTTPS state</var>인 새로운 <a lt="response">응답</a>으로 <a lt="Navigate">이동</a>합니다.
      <a lt="source browsing context">소스 브라우징 컨텍스트</a> 는 <a lt="overridden reload">재정의 된 리로드</a>
      알고리즘에 주어진 것입니다. <a lt="navigate">이동</a> 알고리즘이 이 목적을 위해 {{Document}} 
      객체를 생성할 경우, 그 {{Document}}의 <a lt="reload override flag">리로드 재정의 플래그</a>를
      설정하고 그것의 <a lt="reload override buffer">리로드 재정의 버퍼</a>를 <var>source</var>로
      설정합니다. 모든 예외를 다시 던집니다.

      <a lt="navigation algorithm">이동 알고리즘</a>에서 <a lt="set the document's address">문서의 주소를 설정</a>할 
      때가 되면, <a lt="override URL">재정의 URL</a>로 <var>address</var>를 사용합니다.

<h4 id="the-document-object"><dfn element>Document</dfn> 객체</h4>

  DOM 명세는 {{Document}} 인터페이스를 정의하고, 이 명세는 이를 크게 확장합니다:

  <pre class="idl" data-highlight="webidl" dfn-for="Document">
    enum DocumentReadyState { "loading", "interactive", "complete" };

    [OverrideBuiltins]
    partial /*sealed*/ interface Document {
      // resource metadata management
      [PutForwards=href, Unforgeable] readonly attribute Location? location;
      attribute DOMString domain;
      readonly attribute DOMString referrer;
      attribute DOMString cookie;
      readonly attribute DOMString lastModified;
      readonly attribute DocumentReadyState readyState;

      // DOM tree accessors
      getter object (DOMString name);
      attribute DOMString title;
      attribute DOMString dir;
      attribute HTMLElement? body;
      readonly attribute HTMLHeadElement? head;
      [SameObject] readonly attribute HTMLCollection images;
      [SameObject] readonly attribute HTMLCollection embeds;
      [SameObject] readonly attribute HTMLCollection plugins;
      [SameObject] readonly attribute HTMLCollection links;
      [SameObject] readonly attribute HTMLCollection forms;
      [SameObject] readonly attribute HTMLCollection scripts;
      NodeList getElementsByName(DOMString elementName);
      readonly attribute HTMLScriptElement? currentScript;

      // dynamic markup insertion
      Document open(optional DOMString type = "text/html", optional DOMString replace = "");
      WindowProxy open(DOMString url, DOMString name, DOMString features, optional boolean replace = false);
      void close();
      void write(DOMString... text);
      void writeln(DOMString... text);

      // user interaction
      readonly attribute WindowProxy? defaultView;
      readonly attribute Element? activeElement;
      boolean hasFocus();
      attribute DOMString designMode;
      boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = "");
      boolean queryCommandEnabled(DOMString commandId);
      boolean queryCommandIndeterm(DOMString commandId);
      boolean queryCommandState(DOMString commandId);
      boolean queryCommandSupported(DOMString commandId);
      DOMString queryCommandValue(DOMString commandId);

      // special event handler IDL attributes that only apply to Document objects
      [LenientThis] attribute EventHandler onreadystatechange;
    };
    Document implements GlobalEventHandlers;
    Document implements DocumentAndElementEventHandlers;
  </pre>

  {{Document}}는 초기에 "<code>none</code>"인 <dfn for="document" lt="HTTPS state">HTTP 상태</dfn>
  (<a lt="HTTPS state value">HTTPS 상태 값</a>)를 가지고, 이것은 {{Document}}의 데이터를 전달하는데
  사용된 네트워크 채널의 보안 속성(property)들을 나타냅니다.

  {{Document}}는 <dfn for="document" lt="CSP list">CSP 목록</dfn>을 가지고, 이것은 이 컨텍스트에서
  <a lt="Content Security Policy">콘텐트 보안 정책</a>의 목록입니다. 달리 명시되지 않는 한 목록은
  비어있습니다.

<h4 id="resource-metadata-management">리소스 메타데이터 관리</h4>

  <dl class="domintro">
    <dt><var>document</var> . <code>referrer</code></dt>
    <dd>
      사용자가 이 문서로 이동한 문서로부터, 차단되어 있거나 그러한 문서가 없지 않은 한, {{Document}}의
      <a lt="the address">주소</a>를 반환하고, 그러한 경우에는 빈 문자열을 반환합니다.

      <code>noreferrer</code> 링크 유형은 리퍼러를 차단하는 데 사용될 수 있습니다.
    </dd>
  </dl>

  <div class="impl">
    <dfn attribute for="Document"><code>referrer</code></dfn> 속성(attribute)은 
    <a lt="the document's referrer">문서의 리퍼러</a>를 반환해야(must) 합니다.
  </div>

  <hr />

  <dl class="domintro">
    <dt><var>document</var> . <code>cookie</code> [ = <var>value</var> ]</dt>
    <dd>
      {{Document}}에 적용되는 HTTP 쿠키를 반환합니다. 쿠키가 없거나 이 리소스에 쿠키가 적용될 수 없다면,
      빈 문자열이 반환 될 것입니다.

      새로운 쿠키를 요소(element)의 HTTP 쿠키 세트에 추가하기 위해, 설정 될 수 있습니다.

     콘텐츠가 <a lt="sandboxed into a unique origin">고유 출처(origin)에 샌드박스 되었다</a>면 (예를 들어, 
      <{iframe/sandbox}> 속성(attribute)를 가진 <code>iframe</code>안에), 가져올 때와 설정할 때
      "{{SecurityError}}" {{DOMException}}이 던져질 것입니다.
    </dd>
  </dl>

  <dfn attribute for="Document"><code>cookie</code></dfn> 속성(attribute)은 
  <a lt="the document's address">문서 주소</a>에 의해 식별되는 리소스의 쿠키를 나타냅니다.

  다음 조건 중 하나로 분류되는 {{Document}} 객체는 
  <dfn lt="cookie-averse|sandbox cookies">쿠키를 거부하는 {{Document}} 객체</dfn>입니다:

  * <a lt="browsing context">브라우징 컨텍스트</a>가 없는 {{Document}}.

  * <a lt="address">주소</a>가 서버 기반 네이밍 권한을 사용하지 않는 {{Document}}.

  가져올 때, 문서가 <a lt="cookie-averse">쿠키를 거부하는 <code>Document</code> 객체</a>라면,
  유저 에이전트는 빈 문자열을 반환해야(must) 합니다. 그렇지 않고, {{Document}}의 
  <a for="concept" lt="origin">출처(origin)</a>가 <a lt="opaque origin">불분명한 출처(origin)</a>라면, 유저 
  에이전트는 "{{SecurityError}}" {{DOMException}}를 던져야(must) 합니다. 그렇지 않으면, 유저 
  에이전트는 "non-HTTP" API를 위해 <a lt="UTF-8 decode without BOM">BOM 없는 UTF-8 디코드</a>를 
  사용하여 디코드 된 <a lt="the document's address">문서의 주소</a>에 대한 
  <a lt="cookie-string">쿠키 문자열</a>을 반환해야(must) 합니다. [[!COOKIES]]
  <a class="fingerprint" href="#fingerprinting-vector"><img height="21" src="images/fingerprint.png" width="15" alt="(이것은 지문 그림입니다.)" /></a>

  설정할 때, 문서가 <a lt="cookie-averse">쿠키를 거부하는 <code>Document</code> 객체</a>라면, 
  유저 에이전트는 아무 것도 하지 않아야(must) 합니다. 그렇지 않고, {{Document}}의 <a for="concept" lt="origin">출처(origin)</a>가
  <a lt="opaque origin">불분명한 출처(origin)</a>이라면, 유저 에이전트는 "{{SecurityError}}" 
  {{DOMException}}를 던져야 합니다. 그렇지 않으면, 유저 에이전트는 <a lt="encoded as UTF-8">UTF-8로 인코드 된</a>
  새로운 값으로 구성하여, "non-HTTP" API를 통해 <a lt="the document's address">문서의 주소</a>에 대해 
  <a lt="receiving a set-cookie-string">설정 쿠키 문자열을 받는</a> 경우와 같이 동작해야(must) 합니다. 
  [[!COOKIES]] [[!ENCODING]]

  <p class="note">
    <code>cookie</code> 속성(attribute)은 프레임 전반에 접근이 가능하기 때문에, 쿠키에 대한 경로 제한은
    사이트의 어느 부분으로 어떤 쿠키가 전송되는지를 관리하는데 도움이 되는 도구일 뿐이고, 어떤 방식으로든
    보안 기능이 아닙니다.
  </p>

  <p class="warning">
    <code>cookie</code> 속성(attribute)의 getter와 setter는 동기적으로 공유 된 상태에 접근합니다.
    잠금 매커니즘이 없기 때문에, 다중 프로세스 유저 에이전트에서 다른 브라우징 컨텍스트는 스크립트가 
    수행되는 중에 쿠키를 수정할 수 있습니다. 예를 들어, 사이트는 쿠키 값을 읽고, 그 값을 증가시키고,
    세션에 대한 고유 식별자로서 쿠키의 새로운 값을 사용하여, 다시 그것을 작성하는 것을 시도할 수
    있습니다; 사이트가 동시에 두 개의 다른 브라우저에서 이것을 두 번 수행한다면, 잠재적으로 형편없는 
    영향을 가지고, 양쪽 세션에 대해 동일한 "고유" 식별자를 사용하게 됩니다.
  </p>

  <hr />

  <dl class="domintro">
    <dt><var>document</var> . <code>lastModified</code></dt>
    <dd>
      사용자의 로컬 표준 시간대에 따라, "<code>MM/DD/YYYY&nbsp;hh:mm:ss</code>" 형식으로 서버에 
      의해 보고 된 대로, 문서에 대한 마지막 수정한 날짜를 반환합니다.

      마지막 수정 날짜가 알 수 없다면, 현재 시간이 대신 반환됩니다.
    </dd>
  </dl>

  <div class="impl">
    가져올 때, <dfn attribute for="Document"><code>lastModified</code></dfn> 속성(attribute)은 
    사용자의 로컬 표준 시간대에 따라 {{Document}}의 소스 파일의 마지막 수정 날짜와 시간을 다음 형식
    에 따라 반환해야(must) 합니다:

    1. 날짜의 월 컴포넌트.
    2. U+002F 슬래쉬 문자 (/).
    3. 날짜의 일 컴포넌트.
    4. U+002F 슬래쉬 문자 (/).
    5. 날짜의 연 컴포넌트
    6. U+0020 공백 문자.
    7. 시간의 시 컴포넌트.
    8. U+003A 콜론 문자 (:).
    9. 시간의 분 컴포넌트.
    10. U+003A 콜론 문자 (:).
    11. 시간의 초 컴포넌트.

    연도를 제외한, 위 모든 숫자 컴포넌트는 필요하다면 0을 채워, 10 진수 숫자를 나타내는 두 
    <a lt="ASCII digits">ASCII 숫자</a>로 주어져야(must) 합니다. 연도는 필요하다면 0을 채워, 10 진수
    숫자를 나타내는 4개 이상의 <a lt="ASCII digits">ASCII 숫자</a>의 가능한 가장 짧은 문자열로 
    주어져야 합니다.

    {{Document}}의 소스 파일의 마지막 수정 날짜와 시간은 사용된 네트워크 프로토콜의 관련 기능으로부터,
    예를 들어, 문서의 HTTP <code>Last-Modified</code> 헤더의 값으로부터, 혹은 로컬 파일에 대한 파일  
    시스템 메타데이터로부터 얻어져야(must) 합니다. 마지막 수정 날짜와 시간을 알 수 없다면, 
    속성(attribute)은 위 형식에 따라 현재 날짜와 시간을 반환해야(must) 합니다.
  </div>

  <hr />

  <dl class="domintro">
    <dt><var>document</var> . <code>readyState</code></dt>
    <dd>
      {{Document}}가 로딩되는 동안 "<code>loading</code>"을, 일단 해석이 끝났으나 아직 서브-리소스를
      로딩 중에는 "<code>interactive</code>"를, 로드가 완료되었다면 "<code>complete</code>"를 
      반환합니다.

      이 값이 바뀔 경우 {{Document}} 객체에서 <code>readystatechange</code> 이벤트가 발생합니다.
    </dd>
  </dl>

  <div class="impl">
    각 문서는 <dfn lt="current document readiness">현재 문서 준비상태</dfn>를 가집니다. {{Document}} 
    객체가 생성될 때, 문서가 <a lt="HTML parser">HTML 해석기</a>, <a lt="XML parser">XML 해석기</a>, 
    혹은 XSLT 처리기와 연관된다면 {{Document}}는 문자열 "<code>loading</code>"로, 그렇지 않으면 문자열 
    "<code>complete</code>"로 설정 된 그것의 <a lt="current document readiness">현재 문서 준비상태</a>를
    가져야(must) 합니다. 페이지 로딩 동안 다양한 알고리즘은 이 값에 영향을 끼칩니다. 값이 설정된 경우,
    유저 에이전트는 {{Document}} 객체에 <code>readystatechange</code>로 명명된
    <a lt="fire a simple event">단순한 이벤트를 발생</a> 시켜야(must) 합니다.

    {{Document}}는 아직 <a lt="stopped">멈추거나</a> <a lt="aborted">중단 되지</a> 않은 
    <a lt="HTML parser">HTML 해석기</a>나 <a lt="XML parser">XML 해석기</a>와 연관된다면 
    <dfn lt="active parser">활성화 해석기</dfn>를 가진다고 합니다.

    <dfn attribute for="Document"><code>readyState</code></dfn> IDL 속성(attribute)은 가져올 때,
    <a lt="current document readiness">현재 문서 준비상태</a>를 반환해야(must) 합니다.
  </div>

<h4 id="dom-tree-accessors">DOM 트리 접근자</h4>

  문서의 <{html}> 요소(element)는 문서의 루트 요소(element)가 하나 존재하고 그것이 <{html}> 요소(element)라면
  문서의 루트 요소(element)이고, 그렇지 않으면 null입니다.

  <hr />

  <dl class="domintro">
    <dt><var>document</var> . <code>head</code></dt>
    <dd><{head}> 요소(element)를 반환합니다.</dd>
  </dl>

  문서의 <{head}> 요소(element)는 <{html}> 요소(element)의 자식인 첫 번째 <{head}> 요소(element)가
  하나 존재한다면 문서의 <{head}> 요소(element)이고, 그렇지 않으면 null 입니다.

  <div class="impl">
    <dfn attribute for="Document"><code>head</code></dfn> 속성(attribute)은, 가져올 때, 문서의  must return
    <{head}> 요소(element) (<{head}> 요소(element)나 null)를 반환해야(must) 합니다.
  </div>

  <hr />

  <dl class="domintro">
    <dt><var>document</var> . <code>title</code> [ = <var>value</var> ]</dt>
    <dd>
      HTML에 대해 <a element for="html"><code>title</code></a> 요소(element)에 의해 주어진 대로,
      SVG에 대해 SVG <a element for="svg"><code>title</code></a> 요소(element)에 의해 주어진 대로,
      문서의 제목을 반환합니다.

      문서의 제목을 업데이트하기 위해, 설정될 수 있습니다. 업데이트를 위한 적절한 요소(element)가 
      없다면, 새로운 값은 무시됩니다.
    </dd>
  </dl>

  문서의 <a element for="html"><code>title</code></a> 요소(element)는 문서에 하나만 존재한다면 
  문서의 첫 번째 <a element for="html"><code>title</code></a> 요소(element)이고 
  (<a lt="tree order">트리 순서에 따라</a>), 그렇지 않으면 null 입니다.

  <div class="impl">
    <dfn attribute for="Document"><code>title</code></dfn> 속성(attribute)은 가져올 때, 다음 알고리즘을 수행해야(must) 합니다:

    1. <a lt="root element">루트 요소(element)</a>가 <a lt="SVG namespace">SVG 네임스페이스</a>에 있는
        <{svg}> 요소(element)라면 <var>value</var>를 <a lt="root element">루트 요소(element)</a>의 자식인
        <a lt="SVG namespace">SVG 네임스페이스</a>에 있는 첫 번째 <a element for="svg"><code>title</code></a> 
        요소(element)의 모든 자식 <code>Text</code> 노드의 데이터의 연결로 둡니다. [[!SVG11]]
    2. 그렇지 않으면, <var>value</var>를 <a lt="tree order">트리 순서에 따라</a> 
        <a element for="html"><code>title</code></a> 요소(element)의 모든 자식 <code>Text</code> 
        노드의 데이터의 연결로 두고, <a element for="html"><code>title</code></a> 요소(element)가 null 
        이라면 빈 문자열로 둡니다.
    3. <var>value</var>에서 <a lt="Strip and collapse whitespace">여백 문자를 들어내고 병합</a>합니다.
    4. <var>value</var>를 반환합니다.

    설정할 때, 다음 목록의 처음 일치하는 조건에 해당하는 단계를 수행해야(must) 합니다:

    <dl class="switch">
      <dt>
        <a lt="root element">루트 요소(element)</a>가 <a lt="SVG namespace">SVG 네임스페이스</a>에 있는
        <{svg}> 요소(element)라면 [[!SVG11]]
      </dt>
      <dd>
        1. <var>element</var>를 <a lt="root element">루트 요소(element)</a>의 자식인 
            <a lt="SVG namespace">SVG 네임스페이스</a>에 있는 첫 번째 <a element for="svg"><code>title</code></a> 
            요소(element)가 있다면, 그것으로 둡니다. 그것이 없다면, <a lt="SVG namespace">SVG 네임스페이스</a>에
            <a element for="svg"><code>title</code></a> 요소(element)를 생성하고, <a lt="root element">루트 요소(element)</a>의
            첫 번째 자식으로 추가하고, <var>element</var>를 그 요소(element)로 둡니다. [[!SVG11]]
        2. <var>element</var>의 {{Node/textContent}} IDL 속성(attribute)이 할당되는 새로운 값으로
            설정된 것 처럼 동작합니다.
      </dd>

      <dt><a lt="root element">루트 요소(element)</a>가 <a lt="HTML namespace">HTML 네임스페이스</a>에 있다면</dt>
      <dd>
        1. <a element for="html"><code>title</code></a> 요소(element)가 null이고 <{head}> 요소(element)가
            null이라면, 이 단계들을 중단합니다.
        2. <a element for="html"><code>title</code></a> 요소(element)가 null이라면, 새로운 <code>title</code>
            요소(element)를 생성하고 <{head}> 요소(element)에 <a lt="append">추가(append)</a>하고,
            <var>element</var>를 새롭게 생성된 요소(element)로 둡니다; 그렇지 않으면,
            <var>element</var>를 <a element for="html"><code>title</code></a> 요소(element)로 둡니다.
        3. <var>element</var>의 {{Node/textContent}} IDL 속성(attribute)이 할당되는 새로운 값으로
            설정된 것 처럼 동작합니다.
      </dd>

      <dt>그렇지 않으면</dt>
      <dd>아무 것도 하지 않습니다.</dd>
    </dl>
  </div>

  <hr />

  <dl class="domintro">
    <dt><var>document</var> . <code>body</code> [ = <var>value</var> ]</dt>
    <dd>
      <{body}> 요소(element)를 반환합니다.

      <{body}> 요소(element)를 바꾸기 위해, 설정 될 수 있습니다.

      새로운 값이 <code>body</code>나 <{frameset}> 요소(element)가 아니라면, 이것은
      <code>HierarchyRequestError</code> 예외를 던질 것입니다.
    </dd>
  </dl>

  문서의 <{body}> 요소(element)는 <{html}> 요소(element)의 첫 번째 자식인 <{body}> 요소(element)나
  <{frameset}> 요소(element)입니다. 그러한 요소(element)가 없다면, null입니다.

  <div class="impl">
    <dfn attribute for="Document"><code>body</code></dfn> 속성(attribute)은 가져올 때, 문서의
    <{body}> 요소(<{body}> 요소(element)나 <{frameset}> 요소(element)나 null)를 반환해야 합니다.
    설정할 때, 다음 알고리즘을 수행해야 합니다:

    1. 새로운 값이 <{body}>나 <{frameset}> 요소(element)가 아니라면, <code>HierarchyRequestError</code>
        예외를 던지고 이 단계들을 중단합니다.
    2. 그렇지 않고, 새로운 값이 <{body}> 요소(element)와 동일하다면, 아무것도 하지 않습니다. 이
        단계들을 중단합니다.
    3. 그렇지 않고, <{body}> 요소(element)가 null이 아니라면, 루트 요소(element)의 <code>replaceChild()</code>
        메서드가 그것의 두 인자로 각각 새로운 값과 기존 <{body}> 요소(element)를 가지고 호출된 것 처럼,
        그 요소(element)를 DOM에 새로운 값으로 바꾸고, 이 단계들을 중단합니다.
    4. 그렇지 않고, 루트 요소(element)가 없다면, <code>HierarchyRequestError</code> 예외를 던지고 
        이 단계들을 중단합니다.
    5. 그렇지 않으면, <{body}> 요소(element)는 null이지만, 루트 요소(element)는 존재합니다. 
        루트 요소(element)에 새로운 값을 추가(append)합니다.
  </div>

  <hr />

  <dl class="domintro">
    <dt><var>document</var> . <code>images</code></dt>
    <dd>
      {{Document}}에 있는 <{img}> 요소(element)들의 <code>HTMLCollection</code>을 반환합니다.
    </dd>

    <dt><var>document</var> . <code>embeds</code></dt>
    <dt><var>document</var> . <code>plugins</code></dt>
    <dd>
      {{Document}}에 있는 <{embed}> 요소(element)들의 <code>HTMLCollection</code>을 반환합니다.
    </dd>

    <dt><var>document</var> . <code>links</code></dt>
    <dd>
      {{Document}}에 있는 <{links/href}> 속성(attribute)을 가진 <{a}>와 <{area}> 요소(element)들의 
      <code>HTMLCollection</code>을 반환합니다.
    </dd>

    <dt><var>document</var> . <code>forms</code></dt>
    <dd>
      {{Document}}에 있는 <{form}> 요소(element)들의 <code>HTMLCollection</code>을 반환합니다.
    </dd>

    <dt><var>document</var> . <code>scripts</code></dt>
    <dd>
      {{Document}}에 있는 <{script}> 요소(element)들의 <code>HTMLCollection</code>을 반환합니다.
    </dd>

  </dl>

  <div class="impl">
    <dfn attribute for="Document"><code>images</code></dfn> 속성(attribute)은 {{Document}} 노드에 
    뿌리를 둔 <code>HTMLCollection</code>을 반환해야(must) 하고, 이 속성(attribute)의 필터는 <{img}> 
    요소(element)들과만 일치합니다.

    <dfn attribute for="Document"><code>embeds</code></dfn> 속성(attribute)은 {{Document}} 노드에 
    뿌리를 둔 <code>HTMLCollection</code>을 반환해야(must) 하고, 이 속성(attribute)의 필터는 <{embed}> 
    요소(element)들과만 일치합니다.

    <dfn attribute for="Document"><code>plugins</code></dfn> 속성(attribute)은 <code>embeds</code> 
    속성(attribute)에 의해 반환된 것과 동일한 객체를 반환해야(must) 합니다.

    <dfn attribute for="Document"><code>links</code></dfn> 속성(attribute)은 {{Document}} 노드에 
    뿌리를 둔 <code>HTMLCollection</code>을 반환해야(must) 하고, 이 속성(attribute)의 필터는 <{links/href}> 
    속성(attribute)을 가진 <{a}> 요소(element)들과 <{links/href}> 속성(attribute)을 가진 <{area}> 
    요소(element)들과만 일치합니다.

    <dfn attribute for="Document"><code>forms</code></dfn> 속성(attribute)은 {{Document}} 노드에 
    뿌리를 둔 <code>HTMLCollection</code>을 반환해야(must) 하고, 이 속성(attribute)의 필터는 <{form}> 
    요소(element)들과만 일치합니다.

    <dfn attribute for="Document"><code>scripts</code></dfn>  속성(attribute)은 {{Document}} 노드에 
    뿌리를 둔 <code>HTMLCollection</code>을 반환해야(must) 하고, 이 속성(attribute)의 필터는 <{script}> 
    요소(element)들과만 일치합니다.

    <hr />
  </div>

  <dl class="domintro">
    <dt>
      <var>collection</var> = <var>document</var> . <code>getElementsByName</code>(<var>name</var>)
    </dt>
    <dd>
      {{Document}}에 있는 값 <var>name</var>를 가진 <code>name</code> 속성(attribute)을 가진 
      요소(element)들의 <code>NodeList</code>를 반환합니다.
    </dd>
  </dl>

  <div class="impl">
    <dfn><code>getElementsByName(<var>name</var>)</code></dfn> 메서드는 문자열 <var>name</var>을 
    사용하고, <a lt="tree order">트리 순서</a>에 따라, 그 문서 내의 값이 인자 <var>name</var>과 동일한
    (<a lt="case-sensitive">대소문자 구분</a> 방법으로) <code>name</code> 속성(attribute)를 가진 모든
    <a lt="html elements">html 요소(element)들</a>을 포함하는 <a lt="live">라이브</a> <code>NodeList</code>를
    반환해야(must) 합니다. 메서드가 {{Document}} 객체에서 동일한 인자를 가지고 다시 호출 되는 경우, 
    유저 에이전트는 이전 호출에 의해 반환된 객체와 동일한 객체를 반환할 수도 있습니다. 다른 경우에는
    새로운 <code>NodeList</code> 객체가 반환되어야(must) 합니다.
  </div>

  <hr />

  <dl class="domintro">
    <dt><var>document</var> . <code>currentScript</code></dt>
    <dd>
      현재 실행중인 <{script}> 요소(element)를 반환합니다. 재진입 <code>script</code> 실행의 경우,
      아직 실행을 완료하지 않은 스크립트 중에서 가장 최근에 실행이 시작된 스크립트를 반환합니다.

      {{Document}}가 현재 <code>script</code> 요소(element)를 실행 중이 아니라면 (예를 들어, 수행 
      중인 스크립트가 이벤트 처리기나 타임 아웃되었기 때문에) null을 반환합니다.
    </dd>
  </dl>

  <div class="impl">
    <dfn attribute for="Document"><code>currentScript</code></dfn> 속성(attribute)은 가져올 때, 
    가장 최근에 초기화 된 값을 반환해야(must) 합니다. {{Document}}가 생성될 때, <code>currentScript</code>는
    null로 초기화 되어야(must) 합니다.
  </div>

  <div class="impl">
    <hr />

    {{Document}} 인터페이스는 <a spec="webidl" lt="support named properties">명명된 속성(property)들을 
    지원</a>합니다. 어느 순간에 <a spec="webidl" lt="supported property names">지원되는 속성(property) 
    이름들</a>은 {{Document}} 안에 있는 비어 있지 않은 <code>name</code> 콘텐트 속성(attribute)을 
    가진 모든 <{applet}>, <a lt="exposed">노출 된</a> <{embed}>, <{form}>, <{iframe}>, <{img}>, 
    <a lt="exposed">노출된</a> <code>object</code> 요소(element)들의 <code>name</code> 콘텐트 
    속성(attribute)들의 값들과, {{Document}} 안에 있는 비어 있지 않은 <code>id</code> 콘텐트 
    속성(attribute)을 가진 모든 <code>applet</code>과 <a lt="exposed">노출된</a> <{object}> 
    요소(element)들의 <code>id</code> 콘텐트 속성(attribute)들의 값들과, {{Document}} 안에 있는 비어 
    있지 않은 <code>name</code> 콘텐트 속성(attribute)과 비어있지 않은 <code>id</code> 콘텐트 
    속성(attribute)을 가진 모든 <{img}> 요소(element)들의 <code>id</code> 콘텐트 속성(attribute)들의 
    값들로 구성됩니다. <a spec="webidl" lt="supported property names">지원되는 속성(property) 이름들</a>은 
    동일한 요소(element)가 <code>id</code> 속성(attribute)과 <code>name</code> 속성(attribute) 모두를 
    제공하는 경우 <code>name</code> 속성(attribute)으로부터의 값 앞에 오는 <code>id</code> 속성(attribute)의 
    값을 가지고, 나중의 중복을 무시하여, <a lt="tree order">트리 순서</a>에 따라야(must) 합니다.

    <dfn lt="the Document object is indexed for property retrieval">{{Document}} 객체가 속성(property) 검색(retrieval)을 위해 인덱싱 되는</dfn>
    경우 <a spec="webidl" lt="determine the value of a named property">명명된 속성(property) 
    <var>name</var>의 값을 결정</a>하기 위해, 유저 에이전트는 다음 단계들을 사용하여 얻어진 값을 
    반환해야(must) 합니다:

    1. <var>elements</var>를 {{Document}}에 이름 <var>name</var>을 가진 
        <a lt="named elements">명명된 요소(element)들</a>의 목록으로 둡니다.

        <p class="note">명세에 의해, 적어도 하나의 그러한 요소(element)가 존재할 것입니다.</p>
    2. <var>elements</var>가 하나의 요소(element)만을 가지고, 그 요소(element)가 <code>iframe</code>
        요소(element)라면, 그 <{iframe}> 요소(element)에 의해 나타나는 
        <a lt="nested browsing context">중첩된 브라우징 컨텍스트</a>의 <code>WindowProxy</code>
        객체를 반환하고, 이 단계들을 중단합니다.
    3. 그렇지 않고, <var>elements</var>가 하나의 요소(element)만을 가진다면, 그 요소(element)를 
        반환하고, 이 단계들을 중단합니다.
    4. 그렇지 않으면 {{Document}}에 뿌리를 둔, 필터가 이름 <var>name</var>를 가진 
        <a lt="named elements">명명된 요소(element)들</a>에만 일치하는 <code>HTMLCollection</code>를
        반환합니다.

    위 알고리즘의 목적을 위해 이름 <var>name</var>을 가진  
    <dfn lt="Named elements">명명된 요소(element)들</dfn>은 다음 중 하나입니다:

    * 값이 <var>name</var>인 <code>name</code> 콘텐트 속성(attribute)을 가지는 <{applet}>, 
        <a lt="exposed">노출 된</a> <{embed}>, <{form}>, <{iframe}>, <{img}>, 
        <a lt="exposed">노출 된</a> <{object}> 요소(element)들, 혹은,
    * 값이 <var>name</var>인 <code>id</code> 콘텐트 속성(attribute)을 가지는 <code>applet</code> 또는
        <a lt="exposed">노출 된</a> <{object}> 요소(element)들
    * 값이 <var>name</var>인 <code>id</code> 콘텐트 속성(attribute)을 가지고, 
        비어 있지 않은 <var>name</var> 콘텐트 속성(attribute)도 가지는 <{img}> 요소(element)들

    <code>embed</code>나 <{object}> 요소(element)는 <a lt="exposed">노출 된</a> 조상 <code>object</code>를
    가지지 않고, <{object}> 요소(element)에 대해 추가적으로 요소의 <a lt="fallback content">폴백 콘텐트</a>가
    보이지 않거나 후손 <code>object</code>나 <code>embed</code>를 가지지 않는다면 
    <dfn lt="exposed">노출 되었다</dfn>라고 합니다.
  </div>

  <hr />

  <p class="note">
    {{Document}} 인터페이스에서 <code>dir</code> 속성(attribute)은 <code>dir</code> 콘텐트 
    속성(attribute)과 함께 정의됩니다.
  </p>

  <div class="impl">
    <h4 id="loading-xml-documents">XML 문서 로딩</h4>

    <pre class="idl" data-highlight="webidl" dfn-for="XMLDocument">
      partial interface XMLDocument {
        boolean load(DOMString url);
      };
    </pre>

    <dfn><code>load(<var>url</var>)</code></dfn> 메서드는 다음 단계들을 수행해야(must) 합니다:

    1. <var>document</var>를 메서드가 호출되는 {{XMLDocument}} 객체로 둡니다. 
    2. <var>url</var>을, relative to the <a lt="entry settings object">엔트리 설정 객체</a>에 관련하여 
        <a lt="parse">해석</a>합니다. 이것이 성공적이지 않다면, "{{SyntaxError}}" {{DOMException}}를 
        던지고 이 단계들을 중단합니다. 그렇지 않으면, <var>urlRecord</var>를 
        <a lt="resulting URL record">결과 URL 레코드</a>로 둡니다.
    3. <var>urlRecord</var>의 <a for="url" lt="origin">출처(origin)</a>가 <var>document</var>의
        <a for="concept" lt="origin">출처(origin)</a>와 동일한 것이 아니라면, "{{SecurityError}}"
        {{DOMException}}를 던지고 이 단계들을 중단합니다.
    4. 어떤 변경 이벤트도 발생시키지 않고, <var>document</var>의 모든 자식 노드들을 제거합니다.
    5. <var>document</var>의 <a lt="current document readiness">현재 문서 준비상태</a>를 
        "<code>loading</code>" 으로 설정합니다.
    6. <a lt="in parallel">병렬로</a> 이 단계들의 나머지를 수행하고, 메서드로부터 true를 반환합니다.
    7. <var>result</var>를 {{Document}} 객체로 둡니다.
    8. <var>success</var>를 false로 둡니다.
    9. <var>request</var>를 <a for="url">URL</a>이 <var>urlRecord</var>이고 <a lt="client">클라이언트</a>가
        <a lt="entry settings object">엔트리 설정 객체</a>이고, <a lt="destination">목적지</a>가
        "<code>subresource</code>"이며, <a lt="synchronous flag">동기 플래그</a>가 설정되고,
        <a for="request" lt="mode">모드</a>가 "<code>same-origin</code>", <a lt="credentials mode">자격 증명 모드</a>가
        "<code>same-origin</code>"이고, <a lt="use-URL-credentials flag">URL 자격 증명 사용 플래그</a>가
        설정 된 새로운 <a lt="request">요청</a>으로 둡니다
    10. <var>response</var>를 <var>request</var>를 <a lt="fetching">가져 온</a> 결과로 둡니다.
    11. <var>response</var>의 <a lt="Content-Type metadata">Content-Type 메타데이터</a>가 
        <a lt="XML MIME type">XML MIME 타입</a>이라면, 이 하위 단계들을 수행합니다:
        1. <var>result</var> 문서와 연관된 새로운 <a lt="XML parser">XML 해석기</a>를 생성합니다.
        2. 이 해석기 <var>response</var>의 <a for="response" lt="body">본문</a>을 전달합니다.
        3. XML well-formedness나 XML 네임스페이스 well-formedness 오류가 있다면, <var>result</var>로부터 
            모든 자식 노드들을 제거합니다. 그렇지 않으면, <var>success</var>를 true로 둡니다.
    12. 다음 단계들을 수행하기 위한 <a lt="Queue a task">작업을 대기열에 넣습니다</a>.
        1. <var>document</var>의 <a lt="current document readiness">현재 문서 준비상태</a>를
            "<code>complete</code>"로 설정합니다.
        2. 새로운 자식을 포함하는 <code>DocumentFragment</code>가 삽입 된 것처럼 변경 이벤트를 발생하여,
            <var>document</var>의 모든 자식을 <var>result</var>의 자식으로 바꿉니다 (그것이 자식을 
            가지지 않는다 하더라도).
        3. <var>document</var>에 <code>load</code>라고 명명된 <a lt="fire a simple event">단순한 이벤트를 발생</a>시킵니다.
  </div>

<h3 id="elements">요소(element)</h3>

<h4 id="elements-semantics">의미론(semantic)</h4>

  HTML에서 요소(element), 속성(attribute), 속성 값(attribute value)은 정의 된 (이 명세에 의해) 특정한
  의미(semantic)을 가집니다. 예를 들어, <{ol}> 요소(element)는 순서가 있는 목록을 나타내고, 
  <{global/lang}> 속성(attribute)은 콘텐트의 언어를 나타냅니다.

  이 정의는 웹 브라우저와 검색 엔진 같은 HTML 처리기가 다른 컨텍스트에서 문서와 어플리케이션을 
  일관되게 표현하는 것을 허용합니다.

  <div class="example">
  이 예제에서 HTML 제목(heading)은 데스크탑 브라우저에서 큰 텍스트로, 또는 모바일 브라우저에서 굵은 일반 
  사이즈 텍스트로 보여질 수 있습니다. 두 경우 모두에서 의미론적 정보는 모두 동일하게 남겨집니다 -  
  <{h1}>과 <{h2}> 요소(element)들은 제목(heading)을 나타냅니다.

    <pre highlight="html">
      &lt;!doctype html&gt;
      &lt;html lang="en"&gt;
        &lt;head&gt;
          &lt;title&gt;Favorite books&lt;/title&gt;
        &lt;/head&gt;
            &lt;body&gt;
          &lt;header&gt;
            &lt;img src="logo.png" alt="Favorite books logo"&gt;
          &lt;/header&gt;
          &lt;main&gt;
            &lt;h1&gt;Favorite books&lt;/h1&gt;
            &lt;p&gt;These are a few of my favorite books.&lt;/p&gt;
            &lt;h2&gt;The Belgariad&lt;/h2&gt;
            &lt;p&gt;Five books by David and Leigh Eddings.&lt;/p&gt;
            &lt;h2&gt;The Hitchhiker's Guide to the Galaxy&lt;/h2&gt;
            &lt;p&gt;A trilogy of five books by Douglas Adams.&lt;/p&gt;
          &lt;/main&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
  </div>

  이 의미론적 정보는 보조 기술에 있어 매우 중요합니다. 예를 들어, 스크린 리더(screen reader)는
  브라우저에 의미론적 정보를 질의하고 음성 낭독으로 문서나 어플리케이션을 표시하기 위해 그 정보를
  사용합니다.

  어떤 경우에 보조 기술은 추가적인 기능을 제공하기 위해 의미론적인 정보를 사용합니다. 
  음성 인식 도구는 예를 들어 <{main}> 요소(element)의 시작 지점으로 초점을 이동하기 위한 음성 명령을
  제공 할 수 있습니다.

  적절한 HTML 요소(element)나 속성(attribute)가 사용되지 않는 경우, HTML 처리기에 가치 있는 의미론적 
  정보를 주지 않게 됩니다.

  <div class="example">
  이 예제에서 스타일링은 제목(heading)과 다른 컴포넌트의 시각적 표현을 생성하는데 사용될 수 있지만,
  적절한 HTML 요소(element)가 사용 되지 않았기 때문에 웹 브라우저, 검색 엔진, 보저 기술에 사용 가능한
  의미론적 정보가 거의 존재하지 않습니다.

    <pre highlight="html">
      &lt;!doctype html&gt;
      &lt;html lang="en"&gt;
        &lt;head&gt;
          &lt;title&gt;Favorite books&lt;/title&gt;
        &lt;/head&gt;
              &lt;body&gt;
          &lt;div class="header"&gt;
             &lt;img src="logo.png" alt="Favorite books logo"&gt;
          &lt;/div&gt;
          &lt;div class="main"&gt;
             &lt;span class="largeHeading"&gt;Favorite books&lt;/span&gt;
             &lt;p&gt;These are a few of my favorite books.&lt;/p&gt;
             &lt;span class="smallHeading"&gt;The Belgariad&lt;/span&gt;
             &lt;p&gt;Five books by David and Leigh Eddings.&lt;/p&gt;
             &lt;span class="smallHeading"&gt;The Hitchhiker's Guide to the Galaxy&lt;/span&gt;
             &lt;p&gt;A trilogy of five books by Douglas Adams.&lt;/p&gt;
          &lt;/div&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    </pre>
  </div>

  문서는 그것이 처리되는 동안 동적으로 변경될 수 있습니다. 스크립팅과 다른 메커니즘은 속성(tattribute) 
  값, 텍스트, 전체 문서 구조를 변경하는데 사용될 수 있습니다. 따라서 문서의 의미론은 특정 시점의 
  문서의 상태에 기반하지만, 외부 이벤트에 대한 응답으로 변경될 수도 있습니다. 유저 에이전트들은
  이러한 변경을 반영하기 위해 문서의 표현을 업데이트 해야(must) 합니다.

  <div class="example">
  이 예제에서 <{audio}> 요소(element)는 음악 트랙을 재생하는데 사용됩니다. 
  <dfn attribute for="Document"><code>controls</code></dfn> 속성(attribute)은 유저 에이전트 플레이어를 
  보여주는데 사용되고, 음악이 재생하는 동안 진행을 나타내기 위해 컨트롤이 업데이트 됩니다. 사용 가능한
  의미론적 정보는 이러한 변경에 대한 응답으로 업데이트 됩니다.

  <pre highlight="html">
    &lt;audio src="comfortablynumb.mp3" controls&gt;
  </pre>
  </div>

<h4 id="elements-in-the-dom">DOM에서의 요소(Element)</h4>

  DOM에서 <a lt="html elements">html 요소(element)들</a>을 나타내는 노드는 이 명세의 관련 명세에 
  그것들에 대해 나열된 인터페이스를 구현해야(must) 하고 스크립트에 노출해야(must) 합니다. 여기에는
  문서가 다른 컨텍스트(예를 들어, XSLT 변환 내부)에 있는 문서라 하더라도,  
  <a lt="XML documents">XML 문서들</a>의 <a lt="html elements">html 요소(element)들</a>이 포함됩니다. 

  DOM의 요소(element)들은 상황(things)을 <dfn lt="represent">나타냅니다</dfn>; 즉, DOM의 요소
  (element)들은 의미론(semantic)으로 알려진, 고유한 <em>의미(meaning)</em>를 가집니다. 

  <p class="example">예를 들어, <{ol}> 요소(element)는 순서가 있는 목록을 나타냅니다.</p>

  모든 <a lt="html elements">html 요소(element)들</a>의 인터페이스가 상속 받 <span class="impl">고,
  추가적인 요구사항이 없는 요소(element)들을 사용해야(must) 하</span>는 기본 인터페이스는 {{HTMLElement}}
  인터페이스 입니다.

  <pre class="idl" data-highlight="webidl" dfn-for="HTMLElement">
    interface HTMLElement : Element {
      // metadata attributes
      attribute DOMString title;
      attribute DOMString lang;
      attribute boolean translate;
      attribute DOMString dir;
      [SameObject] readonly attribute DOMStringMap dataset;

      // user interaction
      attribute boolean hidden;
      void click();
      attribute long tabIndex;
      void focus();
      void blur();
      attribute DOMString accessKey;
      attribute boolean draggable;
      [PutForwards=value] readonly attribute DOMTokenList dropzone;
      attribute HTMLMenuElement? contextMenu;
      attribute boolean spellcheck;
      void forceSpellCheck();
    };
    HTMLElement implements GlobalEventHandlers;
    HTMLElement implements DocumentAndElementEventHandlers;
    HTMLElement implements ElementContentEditable;
  </pre>

  <pre class="idl" data-highlight="webidl" dfn-for="HTMLUnknownElement">
    interface HTMLUnknownElement : HTMLElement { };
  </pre>

  {{HTMLElement}} 인터페이스는 다수의 상이한 기능과 관련된 메서드와 속성(attribtue)들을 보유하고,
  따라서 이 인터페이스의 멤버들은 이 명세의 다양한 다른 섹션에서 설명됩니다.

  <div class="impl">
    {{HTMLUnknownElement}} 인터페이스는 이 명세(또는 <a lt="applicable specification">다른 적용 
    가능한 명세</a>)에 정의되지 않은 <a lt="html elements">html 요소(element)들</a>에 사용되어야(must) 
    합니다. 
  </div>

<h4 id="element-definitions">요소(element) 정의</h4>

  이 명세에서 각 요소(element)는 다음 정보를 포함하는 정의를 가집니다:

  : <dfn lt="categories">카테고리</dfn>
  :: 요소(element)가 속하는 <a lt="categories">카테고리</a>의 목록. 이것들은 각 요소(element)에 대해
      <a lt="content models">콘텐트 모델</a>을 정의할 때 사용됩니다.
  : <dfn lt="Contexts in which this element can be used">이 요소(element)가 사용될 수 있는 컨텍스트</dfn>
  :: 요소(element)가 사용될 수 있는 곳의 <em>비 규범적</em> 설명. 이 정보는 자식으로서 이것을 허용하는
      요소의 콘텐트 모델과 중복되고, 편의상으로만 제공됩니다.
      <p class="note">
        간결함을 위해, 가장 구체적인 예상되는 것들만 언급됩니다. 예를 들어, 
        <a lt="flow content">흐름(flow) 콘텐트</a>이면서 <a lt="phrasing content">어구(phrasing) 콘텐트</a>인
        요소(element)는 <a lt="phrasing content">어구(phrasing) 콘텐트</a>가 예상되는 어느 곳에서나
        사용될 수 있지만, <a lt="flow content">흐름(flow) 콘텐트</a>가 예상되는 곳은 
        <a lt="phrasing content">어구(phrasing) 콘텐트</a>도 예상되기 때문에 (모든 
        <a lt="phrasing content">어구(phrasing) 콘텐트</a>는 <a lt="flow content">흐름(flow) 콘텐트</a>이기 
        때문에), "<a lt="phrasing content">어구(phrasing) 콘텐트</a>가 예상되는 곳"만 언급 될 것입니다.
      </p>
  : <dfn lt="content model">콘텐트 모델</dfn>
  :: 요소(element)의 자식과 후손으로 포함되어야(must) 하는 콘텐트의 규범적 설명.
  : <dfn lt="tag omission in text/html">text/html에서 태그 생략</dfn>
  :: <a href="#text-html"><code>text/html</code></a> 구문에서, <a lt="start tag">시작</a> 태그와
      <a lt="end tag">종료 태그</a>가 생략될 수 있는지 여부의 <em>비규범적</em> 설명. 이 정보는
      <a lt="omitted">선택적 태그</a> 섹션에 주어진 규범적인 요구 사항과 중복되고, 요소(element)
      정의에 편의상으로만 제공됩니다.
  : <dfn lt="content attribute|content attributes">콘텐트 속성(attribute)</dfn>
  :: 요소(element)에 명시될 수 있는 속성(attribute)의 규범적 목록과 (달리 허용되지 않는 경우를 제외하고)
      그 속성(attribute)들의 비 규범적인 설명. (대시의 왼쪽의 콘텐트는 규범적이고, 대시 오른쪽의 
      콘텐트는 규범적이지 않습니다.)
  : 허용된 <a href="#aria-role-attribute">ARIA 역학(role) 속성(attribute)</a> 값
  :: 요소에 명시될 수 있는 <a href="#aria-role-attribute">ARIA 역할(role) 속성(attribute)</a> 값들의
      규범적 목록(달리 허용되지 않는 경우를 제외하고). 각 값은 비 규범적 설명에 연결됩니다.
  : 허용된 <a href="#state-and-property-attributes">ARIA 상태(state)와 속성(property) 속성(attribute)들</a>
  :: <a lt="Global aria-* attributes">범용 aria-* 속성(attribute)</a> 목록과
      <a href="#allowed-aria-roles-states-and-properties">허용된 역할(role), 상태(state), 속성(property)</a> 
      표로의 링크
  : <dfn>DOM 인터페이스</dfn>
  :: 그 요소(element)가 구현해야(must)하는 DOM 인터페이스의 규범적 정의

  이것은 요소가 작성자<span class="impl">와 구현</span>에 적용할 수 있는 추가적인 규범적 적합성 기준과
  함께, 무엇을 <a lt="represents">나타내는지</a>의 설명이 이후에 따라옵니다. 예제도 때때로 포함됩니다.

<h5 id="element-definitions-attributes">속성(attribute)</h5>

  달리 명시되지 않는 한, <a lt="html elements">html 요소(element)</a>의 속성(attribute)은 빈 문자열을
  포함하여 임의의 문자열 값을 가질 수 있습니다. 명시적으로 정해지지 않는 한, 그러한 속성(attribute)에
  명시 될 수 있는 텍스트에 대한 제약 사항은 없습니다.

<h4 id="content-models">콘텐트 모델(Content model)</h4>

  이 명세에 정의된 각 요소(element)는 콘텐트 모델을 가집니다: 요소의 예상되는 <a lt='html-contents'>콘텐츠</a>의 설명.
  <a lt="HTML element">HTML 요소(element)</a>는 요소(element)의 콘텐트 모델에 기술된 요구사항에
  일치하는 콘텐트를 가져야(must) 합니다. 요소(element)의 <dfn lt='html-contents'>콘텐트</dfn>는 자식이
  <a lt="template contents">템플릿 콘텐트</a>에 있는 <{template}> 요소(element)를 (요소가 생성될 때
  요소에 대입되는 별도의 <code>DocumentFragment</code>) 제외하고, DOM에서 그것의 자식입니다.

  <a lt="space characters">공백 문자들</a>은 항상 요소(element)들 사이에 허용됩니다. 유저 에이전트들은
  소스 마크업에서 요소(element)들 사이의 이 문자들을 DOM 에서 <code>Text</code> 노드로 나타냅니다.
  일련의 그 문자로만 구성되는 빈 <code>Text</code> 노드와 <code>Text</code> 노드는
  <dfn lt="inter-element whitespace">요소(element) 간 여백</dfn>으로 간주됩니다.

  <a lt="inter-element whitespace">요소 간 여백</a>, 주석 노드, 처리 지시 노드는 요소(element)의
  콘텐트가 요소(element)의 콘텐트 모델과 일치하는지 아닌지의 여부가 수립 될 때 무시되어야(must) 하고,
  문서와 요소(element) 의미론을 정의하는 알고리즘을 따를 때 무시되어야(must) 합니다.

  <p class="note">
    따라서, <var>A</var> and <var>B</var>가 동일한 부모 노드를 가지고 둘 사이에 다른 요소(element)
    노드나 <code>Text</code> 노드(<a lt="inter-element whitespace">요소(element) 간 여백</a> 외)가
    없다면 요소(element) <var>A</var>는 두 번째 요소(element) <var>B</var>보다 <i>앞서거나 
    <var>B</var>가 뒤따른다</i>고 합니다. 마찬가지로, 요소(element)가 
    <a lt="inter-element whitespace">요소(element) 간 여백</a>, 주석 노드, 처리 지시 노드 외 다른
    노드를 포함하지 않는다면 이 노드는 그 요소(element)의 <i>유일한 자식</i>입니다.
  </p>

  작성자는 <a lt="html elements">html 요소(element)들</a>을 각 요소(element)들에 대해 정의 된대로
  혹은 다른 명세에 의해 명시적으로 요구 된 대로 그것들이 명시적으로 허용된 곳을 제외한 다른 어떤
  곳에도 사용하지 않아야(must) 합니다. XML 복합 문서에 대해, 그 요소(element)들이 관련 컨텍스트를
  제공하도록 정의되었다면, 이 상황들은 다른 네임스페이스의 내부 요소(element)가 될 수 있습니다. 

  <div class="example">
    예를 들어, 아톰(Atom) 명세는 <code>content</code> 요소(element)를 정의합니다. 그것의 <code>type</code>
    속성(attribute)이 <code>xhtml</code> 값을 가지는 경우, 아톰(Atom) 명세는 단일 HTML <{div}>
    요소(element)를 포함하도록 요구합니다. 따라서, <{div}> 요소(element)는 비록 이 명세에 의해
    명시적으로 규범적으로 지정되지 않았지만 그 컨텍스트에서는 허용됩니다. [[RFC4287]]
  </div>

  추가적으로, <a lt="html elements">html 요소(element)들</a>은 고아 노드(즉, 부모 노드가 없는)가 될 
  수 있습니다.

  <div class="example">
    예를 들어, <{td}> 요소(element)가 <{tr}> 요소(element) 내부에만 사용되도록 되어있다 하더라도,
    스크립트에서 <{td}> 요소(element)를 생성하고 전역 변수에 저장하는 것은 적합합니다.

    <pre highlight="javascript">
      var data = {
        name: "Banana",
        cell: document.createElement('td'),
      };
    </pre>
  </div>

<h5 id="the-nothing-content-model">"없는(nothing)" 콘텐트 모델</h5>

  요소(element)의 콘텐트 모델이 <dfn lt="nothing">없는</dfn> 경우, 요소(element)는 <code>Text</code> 
  노드 (<a lt="inter-element whitespace">요소(element)간 공백</a> 외)와 요소(element) 노드를 포함하지
  않아야(must) 합니다.

  <p class="note">
    콘텐트 모델이 "없는" 대부분 HTML 요소(element)들은 편의상 <a lt="void elements">텅 빈 요소(element)</a>
    (<a href="#syntax">HTML 문법</a>에 따라 <a lt="end tag">종료 태그</a>를 가지지 않는 요소(element)). 
    하지만, 이것들은 완전히 분리된 개념입니다.
  </p>

<h5 id="kinds-of-content">콘텐트의 종류</h5>

  HTML에서 각 요소(element)는 서로 유사한 특성을 가진 요소(element)를 분류한 0개 이상의
  <dfn lt="content categories|conent category">카테고리</dfn>에 속합니다:

  <ul class="brief category-list">
    <li>[[#kinds-of-content-metadata-content]]</li>
    <li>[[#kinds-of-content-flow-content]]</li>
    <li>[[#kinds-of-content-sectioning-content]]</li>
    <li>[[#kinds-of-content-heading-content]]</li>
    <li>[[#kinds-of-content-phrasing-content]]</li>
    <li>[[#kinds-of-content-embedded-content]]</li>
    <li>[[#kinds-of-content-interactive-content]]</li>
  </ul>

  <p class="note">
    어떤 요소들은 이 명세에서 다른 부분에 정의된 다른 카테고리에도 해당됩니다.
  </p>

  이 카테고리들은 다음과 같이 관련됩니다:

  <object width="1000" height="288" data="images/content-venn.svg"><img src="images/content-venn.png" alt="" width="512" height="288" /></object>

  섹션화(sectioning) 콘텐트, 제목(heading) 콘텐트, 어구(phrasing) 콘텐트, 삽입(embedded) 콘텐트,
  대화형(interactive) 콘텐트는 흐름(flow) 콘텐트의 모든 유형입니다. 메타데이터는 때때로 흐름(flow)
  콘텐트 입니다. 메타데이터와 대화형(interactive) 콘텐트는 때때로 어구(phrasing) 콘텐트 입니다.
  삽입(embedded) 콘텐트는 또한 어구(phrasing) 콘텐트이 유형이고, 때때로 대화형(interactive) 콘텐트입니다.

  다른 카테고리들은 특정 목적을 위해서도 사용됩니다, 예를 들어, 양식(form) 컨트롤들은 공통 요구사항을
  정의하기 위해 여러 가지 카테고리를 사용하여 명시됩니다. 일부 요소(element)들은 고유의 요구사항을 
  가지고 특정 카테고리에 맞지 않습니다.

<h6 id="kinds-of-content-metadata-content">메타데이터 콘텐트</h6>

  <dfn lt="metadata content">메타데이터 콘텐트</dfn>는 콘텐트 나머지의 표현이나 동작을 설정하거나,
  다른 문서와 문서의 관계를 설정하거나, 다른 "대역 외" 정보를 전달하는 콘텐트 입니다.

  <ul class="brief category-list">
    <li><{base}></li>
    <li><{link}></li>
    <li><{meta}></li>
    <li><{noscript}></li>
    <li><{script}></li>
    <li><{style}></li>
    <li><{template}></li>
    <li><a element for="html"><code>title</code></a></li>
  </ul>

<h6 id="kinds-of-content-flow-content">흐름(flow) 콘텐트</h6>

  문서와 어플리케이션의 본문에 사용되는 대부분 요소(element)는 <dfn lt="flow content">흐름(flow) 콘텐트</dfn>로
  분류됩니다.

  <ul class="brief category-list">
    <li><{a}></li>
    <li><{abbr}></li>
    <li><{address}></li>
    <li><{area}> (<{map}> 요소(element)의 후손이라면)</li>
    <li><{article}></li>
    <li><{aside}></li>
    <li><{audio}></li>
    <li><{b}></li>
    <li><{bdi}></li>
    <li><{bdo}></li>
    <li><{blockquote}></li>
    <li><{br}></li>
    <li><{button}></li>
    <li><{canvas}></li>
    <li><{cite}></li>
    <li><{code}></li>
    <li><{data}></li>
    <li><{datalist}></li>
    <li><{del}></li>
    <li><{details}></li>
    <li><{dfn}></li>
    <li><{div}></li>
    <li><{dl}></li>
    <li><{em}></li>
    <li><{embed}></li>
    <li><{fieldset}></li>
    <li><{figure}></li>
    <li><{footer}></li>
    <li><{form}></li>
    <li><{h1}></li>
    <li><{h2}></li>
    <li><{h3}></li>
    <li><{h4}></li>
    <li><{h5}></li>
    <li><{h6}></li>
    <li><{header}></li>
    <li><{hr}></li>
    <li><{i}></li>
    <li><{iframe}></li>
    <li><{img}></li>
    <li><{input}></li>
    <li><{ins}></li>
    <li><{kbd}></li>
    <li><{keygen}></li>
    <li><{label}></li>
    <li><{main}></li>
    <li><{map}></li>
    <li><{mark}></li>
    <li><{math}></li>
    <li><{menu}></li>
    <li><{meter}></li>
    <li><{nav}></li>
    <li><{noscript}></li>
    <li><{object}></li>
    <li><{ol}></li>
    <li><{output}></li>
    <li><{p}></li>
    <li><{picture}></li>
    <li><{pre}></li>
    <li><{progress}></li>
    <li><{q}></li>
    <li><{ruby}></li>
    <li><{s}></li>
    <li><{samp}></li>
    <li><{script}></li>
    <li><{section}></li>
    <li><{select}></li>
    <li><{small}></li>
    <li><{span}></li>
    <li><{strong}></li>
    <li><{sub}></li>
    <li><{sup}></li>
    <li><{svg}></li>
    <li><{table}></li>
    <li><{template}></li>
    <li><{textarea}></li>
    <li><{time}></li>
    <li><{u}></li>
    <li><{ul}></li>
    <li><{var}></li>
    <li><{video}></li>
    <li><{wbr}></li>
    <li><a lt="Text">텍스트</a></li>
  </ul>


<h6 id="kinds-of-content-sectioning-content">그룹화(sectioning) 콘텐트</h6>

  <dfn lt="sectioning content">그룹화(sectioning) 콘텐트</dfn>는 <a lt="headings">제목(heading)</a>과
  <a element lt="footer">바닥글(footer)</a>들의 범위를 정의하는 콘텐트 입니다.

  <ul class="brief category-list">
    <li><{article}></li>
    <li><{aside}></li>
    <li><{nav}></li>
    <li><{section}></li>
  </ul>

  각 <a lt="sectioning content">섹션화(sectioning) 콘텐트</a>는 잠재적으로 제목(heading)과
  <a lt="outline">개요(outline)</a>를 가집니다. 더 자세한 내용을 위해 [[#headings-and-sections]]의 
  섹션을 참고하세요.

  <p class="note">
    <a lt="sectioning roots">섹션화(sectioning) 루트</a>인 특정 요소(element)들도 있습니다. 
    이것들은 <a lt="sectioning content">섹션화(sectioning) 콘텐트</a>와 구별되지만, 
    이들도 <a lt="outline">개요(outline)</a>를 가질 수 있습니다.
  </p>

<h6 id="kinds-of-content-heading-content">제목(heading) 콘텐트</h6>

  <dfn lt="heading content|headings">제목(heading) 콘텐트</dfn>는 (<a lt="sectioning content">섹션화(sectioning)
  콘텐트</a> 요소(element)를 사용하여 명시적으로 마크업했거나, 제목(heading) 콘텐트 자체로 나타내어)
  섹션의 헤더를 정의합니다.

  <ul class="brief category-list">
    <li><{h1}></li>
    <li><{h2}></li>
    <li><{h3}></li>
    <li><{h4}></li>
    <li><{h5}></li>
    <li><{h6}></li>
  </ul>

<h6 id="kinds-of-content-phrasing-content">어구(phrasing) 콘텐트</h6>

  <dfn lt="phrasing content">어구(phrasing) 콘텐트</dfn>는 문서의 텍스트 뿐만 아니라 문단 내부(intra-paragraph)
  레벨에서 텍스트를 마크업 하는 요소(element) 입니다. <a lt="paragraphs">문단</a>에서의 연속 된
  <a lt="phrasing content">어구(phrasing) 콘텐트</a>.

  <ul class="brief category-list">
    <li><{a}></li>
    <li><{abbr}></li>
    <li><{area}> (<{map}> 요소(element)의 후손이라면)</li>
    <li><{audio}></li>
    <li><{b}></li>
    <li><{bdi}></li>
    <li><{bdo}></li>
    <li><{br}></li>
    <li><{button}></li>
    <li><{canvas}></li>
    <li><{cite}></li>
    <li><{code}></li>
    <li><{data}></li>
    <li><{datalist}></li>
    <li><{del}></li>
    <li><{dfn}></li>
    <li><{em}></li>
    <li><{embed}></li>
    <li><{i}></li>
    <li><{iframe}></li>
    <li><{img}></li>
    <li><{input}></li>
    <li><{ins}></li>
    <li><{kbd}></li>
    <li><{keygen}></li>
    <li><{label}></li>
    <li><{map}></li>
    <li><{mark}></li>
    <li><{math}></li>
    <li><{meter}></li>
    <li><{noscript}></li>
    <li><{object}></li>
    <li><{output}></li>
    <li><{picture}></li>
    <li><{progress}></li>
    <li><{q}></li>
    <li><{ruby}></li>
    <li><{s}></li>
    <li><{samp}></li>
    <li><{script}></li>
    <li><{select}></li>
    <li><{small}></li>
    <li><{span}></li>
    <li><{strong}></li>
    <li><{sub}></li>
    <li><{sup}></li>
    <li><{svg}></li>
    <li><{template}></li>
    <li><{textarea}></li>
    <li><{time}></li>
    <li><{u}></li>
    <li><{var}></li>
    <li><{video}></li>
    <li><{wbr}></li>
    <li><a lt="Text">텍스트</a></li>
  </ul>

  <p class="note">
    어구(phrasing) 콘텐트로 분류된 대부분 요소(element)들은 흐름(flow) 콘텐트가 아닌 어구(phrasing)
    컨텐트로 분류된 자기 자신인 요소(element)만을 포함 할 수 있습니다.
  </p>

  콘텐트 모델의 맥락에서 <dfn lt="Text|Text content">텍스트</dfn>는 아무 것도 의미하지 않거나 <code>Text</code>
  노드를 의미합니다. <a lt="Text">텍스트</a>는 때때로 그 자체로 콘텐트 모델로 사용되지만,
  <a lt="phrasing content">어구(phrasing) 콘텐트</a>이기도 하며, 
  <a lt="inter-element whitespace">요소(element) 간 공백</a>이 될 수 있습니다(<code>Text</code> 노드가
  비어있거나 <a lt="space characters">공백 문자들</a>만을 포함한다면).

  <code>Text</code> 노드와 속성(attribute) 값은 <a lt="Unicode characters">유니코드 문자들</a>로
  구성되어야(must) 하고, U+0000 문자는 포함하지 않아야(must) 하고, 영구적으로 정의되지 않은 유니코드
  문자(비문자)를 포함하지 않아야(must) 하고, <a lt="space characters">공백 문자들</a> 외
  <a lt="control characters">제어 문자</a>를 포함하지 않아야(must) 합니다.

  이 명세는 정확한 컨텍스트에 따른 <code>Text</code> 노드의 정확한 값과 속성(attribtue) 값에 추가 
  제한 사항들을 포함합니다.

  HTML에서 요소(element)들에 대해, <a lt="Text">텍스트</a> <a lt="content model">콘텐트 모델</a>의
  제한 사항도 <a lt="kind of element">요소(element)의 종류</a>에 따릅니다. 예를 들어, <{textarea}>
  요소(element) 안에 "<code>&lt;</code>"는 <{textarea}>가 <a lt="escapable raw text">이스케이프 될 
  수 있는 원시 텍스트</a> 요소(element)이기 때문에  HTML에서 이스케이프 될 필요가 없습니다. (이것은
  XHTML에 적용하지 않습니다. XHTML에서, <a lt="kind of element">요소(element)의 종류</a>는 
  <a lt="content model">콘텐트 모델</a>: <a lt="Text">텍스트</a>의 제한 사항에 영향을 주지 않습니다.)

<h6 id="kinds-of-content-embedded-content">삽입(embedded) 콘텐트</h6>

  <dfn lt="embedded content">삽입(embedded) 콘텐트</dfn>는 문서에 다른 리소스를 불러오는 콘텐트, 혹은
  <a for="document" lt="inserted into the document">문서에 삽입 된</a> 다른 표현 형식으로부터의 콘텐트 
  입니다.

  <ul class="brief category-list">
    <li><{audio}></li>
    <li><{canvas}></li>
    <li><{embed}></li>
    <li><{iframe}></li>
    <li><{img}></li>
    <li><{math}></li>
    <li><{object}></li>
    <li><{picture}></li>
    <li><{svg}></li>
    <li><{video}></li>
  </ul>

  <a lt="HTML namespace">HTML 네임스페이스</a>와 다른 네임스페이스이고 콘텐트를 전달하지만 메타데이터는
  전달하지 않는 요소(element)는 이 명세에 정의된 콘텐트 모델의 목적에 대한 
  <a lt="embedded content">삽입(embedded) 콘텐트</a> 입니다. (예를 들어, MathML 혹은 SVG.)

  일부 삽입(embedded) 콘텐트 요소(element)들은 <dfn lt="fallback content">폴백 콘텐트</dfn>를 가질 수
  있습니다: 외부 리소스가 사용될 수 없는 경우 (예를 들어, 지원되지 않는 형식의 콘텐트이기 때문에)
  사용되는 콘텐트. 폴백이 있다면 요소(element) 정의는 폴백이 무엇인지 지정합니다.

<h6 id="kinds-of-content-interactive-content">대화형(interactive) 콘텐트</h6>

  <dfn lt="interactive content">대화형(interactive) 콘텐트</dfn>는 유저 인터랙션을 위해 특별히 의도된
  콘텐트 입니다.

  <ul class="brief category-list">
    <li><{a}> (<{a/href}> 속성(attribute)이 존재한다면)</li>
    <li><{audio}> (<{audio/controls}> 속성(attribute)이 존재한다면)</li>
    <li><{button}></li>
    <li><{details}></li>
    <li><{embed}></li>
    <li><{iframe}></li>
    <li><{img}> (<{img/usemap}> 속성(attribute)이 존재한다면)</li>
    <li>
      <{input}> (<{input/type}> 속성(attribute)이 <a lt="Hidden">숨김</a> 상태가 <em>아니</em>라면)
    </li>
    <li><{keygen}></li>
    <li><{label}></li>
    <li><{select}></li>
    <li><{textarea}></li>
    <li><{video}> (<{video/controls}> 속성(attribute)이 존재한다면)</li>
  </ul>

  <code>tabindex</code> 속성(attribute)은 모든 요소(element)를
  <a lt="interactive content">대화형(interactive) 콘텐트</a>로 만들 수 있습니다.

<h6 id="sec-palpable-content">분명한(palpable) 콘텐트</h6>

  일반적인 규칙으로, 콘텐트 모델이 <a lt="flow content">흐름(flow) 콘텐트</a>나 
  <a lt="phrasing content">어구(phrasing) 콘텐트</a>를 허용하는 요소(element)는 
  <a lt="palpable content">분명한(palpable) 콘텐트</a>이고 명시된 <code>hidden</code> 속성(attribute)을
  가지지 않는 그것의 <a lt='html-contents'>contents</a>에 적어도 하나의 노드를 가져야(should) 합니다.

  <p class="note">
    <dfn lt="palpable content">분명한(palpable) 콘텐트</dfn>는 일부 비어 있지 않은 후손 <a lt="text">텍스트</a>를
    제공하거나, 사용자가 들을 수 있거나(<{audio}> 요소(element)들) 볼 수 있거나 (<{video}> 나 <{img}>
    혹은 <{canvas}> 요소(element)들) 혹은 상호 작용 할 수 있는 (예를 들어, 대화형 양식(form) 컨트롤들)
    것을 제공하여 요소를 비어 있지 않게 만듭니다.
  </p>

  하지만, 요소가 타당하게 비어 있을 수 있는 많은 경우, 예를 들어 스크립트에 의해 나중에 채워질
  플레이스홀더로 사용되거나, 요소가 템플릿의 일부이고 일부 페이지에서는 아니지만 대다수 페이지에서
  채워지는 경우가 있기 때문에 이 요구사항은 견고한 요구 사항이 아닙니다.

  적합성 검사기는 작성 보조 도구로서, 작성자에게 이 요구 사항을 충족하는데 실패한 요소(element)들을
  찾기 위한 메커니즘을 제공하도록 권장됩니다.

  다음 요소(element)들은 분명한(palpable) 콘텐트입니다:

  <ul class="brief category-list">
    <li><{a}></li>
    <li><{abbr}></li>
    <li><{address}></li>
    <li><{article}></li>
    <li><{aside}></li>
    <li><{audio}> (<code>controls</code> 속성(attribute)이 존재한다면)</li>
    <li><{b}></li>
    <li><{bdi}></li>
    <li><{bdo}></li>
    <li><{blockquote}></li>
    <li><{button}></li>
    <li><{canvas}></li>
    <li><{cite}></li>
    <li><{code}></li>
    <li><{data}></li>
    <li><{details}></li>
    <li><{dfn}></li>
    <li><{div}></li>
    <li><{dl}> (요소(element)의 자식이 적어도 하나의 이름-값 그룹을 포함한다면)</li>
    <li><{em}></li>
    <li><{embed}></li>
    <li><{fieldset}></li>
    <li><{figure}></li>
    <li><{footer}></li>
    <li><{form}></li>
    <li><{h1}></li>
    <li><{h2}></li>
    <li><{h3}></li>
    <li><{h4}></li>
    <li><{h5}></li>
    <li><{h6}></li>
    <li><{header}></li>
    <li><{i}></li>
    <li><{iframe}></li>
    <li><{img}></li>
    <li>
      <{input}> (<code>type</code> 속성(attribute)이 <a element-state for="input" lt="Hidden">숨김</a> 상태에
      있지 <em>않는</em>다면)
    </li>
    <li><{ins}></li>
    <li><{kbd}></li>
    <li><{keygen}></li>
    <li><{label}></li>
    <li><{main}></li>
    <li><{map}></li>
    <li><{mark}></li>
    <li><{math}></li>
    <li><{meter}></li>
    <li><{nav}></li>
    <li><{object}></li>
    <li>
      <{ol}> (요소(element)의 자식이 적어도 하나의 <{li}> 요소(element)를 포함한다면)
    </li>
    <li><{output}></li>
    <li><{p}></li>
    <li><{pre}></li>
    <li><{progress}></li>
    <li><{q}></li>
    <li><{ruby}></li>
    <li><{s}></li>
    <li><{samp}></li>
    <li><{section}></li>
    <li><{select}></li>
    <li><{small}></li>
    <li><{span}></li>
    <li><{strong}></li>
    <li><{sub}></li>
    <li><{sup}></li>
    <li><{svg}></li>
    <li><{table}></li>
    <li><{textarea}></li>
    <li><{time}></li>
    <li><{u}></li>
    <li>
      <{ul}> (요소(element)의 자식이 적어도 하나의 <{li}> 요소(element)를 포함한다면)
    </li>
    <li><{var}></li>
    <li><{video}></li>
    <li><a lt="inter-element whitespace">요소(element) 간 여백</a>이 아닌 <a lt="Text">텍스트</a></li>
  </ul>

<h6 id="sec-script-supporting-elements">스크립트 지원 요소(element)</h6>

  <dfn lt="Script-supporting element|Script-supporting elements">스크립트 지원 요소(element)</dfn>는
  스스로 아무 것도 <a lt="represent">나타내지</a> 않지만(즉, 렌더링 되지 않습니다), 스크립트를 
  지원하는데, 예를 들어 사용자를 위한 기능적 제공을 위해 사용됩니다.

  다음 요소(element)들은 스크립트 지원 요소(element)들 입니다:

  <ul class="brief category-list">
    <li><{script}></li>
    <li><{template}></li>
  </ul>

<h5 id="transparent-content-models">투명 콘텐트 모델</h5>

  일부 요소(element)들은 <dfn lt="transparent">투명</dfn>으로 기술됩니다; 그것들은 콘텐트 모델의 설명에
  "투명"을 가집니다. <a lt="transparent">투명</a> 요소(element)의 콘텐트 모델은 부모 요소의 콘텐트
  모델에서 유래됩니다: "투명"인 콘텐트 모델의 부분에 요구되는 요소(element)들은 투명 요소(element)가
  자신을 발견하는 투명 요소(element)의 부모 요소의 콘텐트 모델의 부분에 요구되는 것과 같은
  요소(element)입니다.

  <div class="example">
    예를 들어, <{ruby}> 요소(element) 안의 <{ins}> 요소(element)는, <{ins}> 요소(element)를 허용하는 
    <{ruby}> 요소(element)의 콘텐트 모델의 부분은 <a lt="phrasing content">어구(phrasing) 콘텐트</a>를
    허용하는 부분이고, <{rt}> 요소(element)는 <a lt="phrasing content">어구(phrasing) 콘텐트</a>가
    아니기 때문에, <{rt}> 요소(element)를 포함할 수 없습니다.
  </div>

  <p class="note">
    어떤 경우에, 투명 요소(element)가 서로 중첩되는 경우, 반복적으로 처리가 적용되어야(has to) 합니다.
  </p>

  <div class="example">
    다음 마크업 코드 조각을 고려해보세요:

    <pre highlight="html">&lt;p>&lt;object>&lt;param>&lt;ins>&lt;map>&lt;a href="/">Apples&lt;/a>&lt;/map>&lt;/ins>&lt;/object>&lt;/p></pre>

    "Apples"가 <{a}> 요소(element) 안에 허용되는지를 확인하기 위해, 콘텐트 모델이 검사됩니다. <{a}>
    요소(element)의 콘텐트 모델은 투명이고, <{map}> 요소(element)의 콘텐트 모델도, <{ins}> 요소(element)의
    콘텐트 모델도, <{ins}> 요소(element)가 발견되는 <{object}> 요소의 부분도 마찬가지입니다. <{object}>
    요소(element)는 콘텐트 모델이 <a lt="phrasing content">어구(phrasing) 콘텐트</a>인 <{p}> 요소(element)
    안에서 발견되어집니다. 따라서, 텍스트는 <a lt="phrasing content">어구(phrasing) 콘텐트</a>이기
    때문에, "Apples"는 허용됩니다. 
  </div>

  투명 요소(element)가 부모가 없는 경우, "transparent"인 그것의 콘텐트 모델의 부분은 대신 모든
  <a lt="flow content">흐름(flow) 콘텐트</a>를 허용하는 것으로 취급되어야(must) 합니다.

<h5 id="paragraphs">문단(paragraphs)</h5>

  <p class="note">
    이 섹션에 정의된 용어 <a lt="paragraph">문단</a>은 <{p}> 요소(element)의 정의 이상으로 사용됩니다.
    여기에 정의 된 <a lt="paragraph">문단</a> 개념은 문서를 해석하는 방법을 기술하는데 사용됩니다.
    <{p}> 요소(element)는 <a lt="paragraph">문단</a>을 마크업하는 몇 가지 방법 중 단지 한 가지일 
    뿐입니다.
  </p>

  <dfn lt="paragraph|paragraphs|implied paragraph|paragraphing|implied|implied paragraphs">문단</dfn>은
  일반적으로 타이포그라피에서와 같이, 특정 주제에 관해 논하는 하나 이상의 문장들을 가진 텍스트 블럭을
  구성하거나, 좀 더 일반적인 주제 그룹에 사용될 수 있는 <a lt="phrasing content">어구(phrasing) 콘텐트</a>의
  연속입니다. 예를 들어, 주소도 문단이고, 시(詩)의 양식의 일부나, 필자 이름을 적은 행, 혹은 연(聯)도
  그러합니다.

  <div class="example">
    다음 예제에서, 섹션에 두 개의 문단이 존재합니다. 문단이 아닌 어구(phrasing) 콘텐트를 포함하는 
    제목(heading)도 존재합니다. 주석과 <a lt="inter-element whitespace">요소(element) 간 여백</a>이 
    문단을 구성하지 않는 방식에 주목하세요.

    <pre highlight="html">
      &lt;section>
        &lt;h2>Example of paragraphs&lt;/h2>
        This is the &lt;em>first&lt;/em> paragraph in this example.
        &lt;p>This is the second.&lt;/p>
        &lt;!-- This is not a paragraph. -->
      &lt;/section>
    </pre>
  </div>

  <a lt="flow content">흐름(flow) 콘텐트</a> 안의 문단은 문서가 문제를 복잡하게 만드는 <{a}>, <{ins}>,
  <{del}>, <{map}> 요소(element)들은 그들의 혼합 콘텐트 모델을 가지고 아래 처음 두 예제에서 보이는 
  것과 같이 문단 경계를 모호하게 할 수 있기 때문에, 이 요소(element)들이 없는 것 같이 보이는 것에
  관련하여 정의됩니다.

  <p class="note">
    일반적으로, 문단 경계를 모호하게 하는 요소(element)를 가지는 것을 방지하는 것이 가장 좋습니다. 
    그러한 마크업을 유지보수 하는 것은 어렵게 만들 수 있습니다.
  </p>

  <div class="example">
    다음 예제는 이전 예제에서 마크업을 가져와서 텍스트가 변경되었음을 나타내기 위해 (이 경우에서 
    이기는 하지만, 변경 사항은 확실히 말이 안 되기는 합니다) 일부 마크업 주변에 <{ins}>와 <{del}>
    요소(element)를 넣습니다. 이 예제가 <{ins}>과 <{del}> 요소(element)에도 불구하고, 이전의 것과
    정확히 동일한 문단을 가지는 방식에 주목하세요 &mdash; <{ins}> 요소(element)는 제목(heading)과
    첫 번째 문단을 모호하게 하고, <{del}> 요소(element)는 두 문단 사이 경계를 모호하게 합니다.

    <pre highlight="html">
      &lt;section>
        &lt;ins>&lt;h1>Example of paragraphs&lt;/h1>
        This is the &lt;em>first&lt;/em> paragraph in&lt;/ins> this example&lt;del>.
        &lt;p>This is the second.&lt;/p>&lt;/del>
        &lt;!-- This is not a paragraph. -->
      &lt;/section>
    </pre>
  </div>

  <div class="impl">
    <var>view</var>를 문서의 모든 <{a}>, <{ins}>, <{del}>, <{map}> 요소(element)를 그들의 
    <a lt='html-contents'>콘텐츠</a>로 바꾸는 DOM의 뷰로 둡니다. 그 후, <var>view</var>에서, 콘텐트의
    다른 유형에 의해 연속 된 각 일련의 <a lt="phrasing content">어구(phrasing) 콘텐트</a> 형제 노드에
    대해, <a lt="phrasing content">어구(phrasing) 콘텐트</a> 뿐 아니라 <a lt="phrasing content">어구(phrasing) 콘텐트</a>
    외 다른 콘텐트를 허용하는 요소(element) 내에서, <var>first</var>를 연속의 첫 번째 노드로 두고,
    <var>last</var>를 연속의 마지막 노드로 둡니다. <a lt="embedded content">삽입(embedded) 콘텐트</a>나
    <a lt="inter-element whitespace">요소(element) 간 여백</a>이 아닌 적어도 하나의 노드로 구성되는 
    그 각 연속에 대해, 문단은 <var>first</var> 바로 전부터 <var>last</var> 바로 이후까지 본래의 DOM에
    존재합니다. (따라서 문단은 <{a}>, <{ins}>, <{del}>, <{map}> 요소(element)들 전반에 걸쳐질 수 
    있습니다.)

    적합성 검사기는 서로 겹치는 문단을 가지는 경우의 작성자에게 경고할 수 있습니다 (이것은 <{object}>,
    <{video}>, <{audio}>, <{canvas}> 요소(element))들에 발생될 수 있고, HTML 안에 추가적으로 삽입되는
    것을 허용하는 다른 네임스페이스에 있는 요소(element)들을, <{svg}> <{math}> 같은, 통해 간접적으로
    발생될 수 있습니다).
  </div>

  <a lt="paragraph">문단</a>은 또한 명식적으로 <{p}> 요소(element)에 의해 구성 될 수 있습니다.

  <p class="note">
    <{p}> 요소(element)는 서로 문단을 구분하기 위한 어구(phrasing) 콘텐트외 다른 어떤 콘텐트도
    존재하지 않을 경우 각각의 문단을 감싸는데 사용 될 수 있습니다.
  </p>

  <div class="example">
    다음 예제에서, 링크가 첫 번째 문단의 반, 두 번째 문단을 구분하는 제목(heading) 전부, 두 번째 
    문단의 반에 걸쳐 있습니다. 이는 문단과 헤딩을 모호하게 합니다.

    <pre highlight="html">
      &lt;header>
        Welcome!
        &lt;a href="about.html">
          This is home of...
          &lt;h1>The Falcons!&lt;/h1>
          The Lockheed Martin multirole jet fighter aircraft!
        &lt;/a>
        This page discusses the F-16 Fighting Falcon's innermost secrets.
      &lt;/header>
    </pre>

    여기, 이번에는 명시적으로 문단을 보여주고, 한 개 링크 요소(element)를 세개로 분할하여 이를
    마크업하는 다른 방법이 있습니다:

    <pre highlight="html">
      &lt;header>
        &lt;p>Welcome! &lt;a href="about.html">This is home of...&lt;/a>&lt;/p>
        &lt;h1>&lt;a href="about.html">The Falcons!&lt;/a>&lt;/h1>
        &lt;p>&lt;a href="about.html">The Lockheed Martin multirole jet
        fighter aircraft!&lt;/a> This page discusses the F-16 Fighting
        Falcon's innermost secrets.&lt;/p>
      &lt;/header>
    </pre>
  </div>

  <div class="example">
    폴백 콘텐트를 정의하는 특정 요소(element)를 사용하는 경우 문단이 중첩되는 것이 가능합니다. 예를 
    들어, 다음 섹션에서:

    <pre highlight="html">
      &lt;section>
        &lt;h2>My Cats&lt;/h2>
        You can play with my cat simulator.
        &lt;object data="cats.sim">
          To see the cat simulator, use one of the following links:
          &lt;ul>
            &lt;li>&lt;a href="cats.sim">Download simulator file&lt;/a>
            &lt;li>&lt;a href="https://sims.example.com/watch?v=LYds5xY4INU">Use online simulator&lt;/a>
          &lt;/ul>
          Alternatively, upgrade to the Mellblom Browser.
        &lt;/object>
        I'm quite proud of it.
      &lt;/section>
    </pre>

    다섯 개의 문단이 있습니다:

    1. <i>object</i>가 <{object}> 요소(element)인 "You can play with my cat simulator. <i>object</i> I'm quite proud of
        it." 라고 말하는 문단.
    2. "To see the cat simulator, use one of the following links:" 라고 말하는 문단.
    3. "Download simulator file" 라고 말하는 문단.
    4. "Use online simulator" 라고 말하는 문단.
    5. "Alternatively, upgrade to the Mellblom Browser." 라고 말하는 문단.

    첫 번째 문단은 다른 네 개의 문단에 의해 중첩됩니다. "cats.sim" 리소스를 지원하는 유저 에이전트는
    첫 번째 문단만을 보여줄 것이지만, 폴백 컨텐트를 보여주는 유저 에이전트는 혼란스럽게 첫 번째 
    문단의 첫 번째 문장을 두 번째 문장으로서 동일한 문단에 있었던 것 처럼 보여줄 것이고, 마지막
    문단을 첫 번째 문단의 두 번째 문장의 시작에 있었던 것 처럼 보여줄 것입니다.

    이 혼란을 방지하기 위해, 명시적인 <{p}> 요소(element)가 사용될 수 있습니다. 예를 들어:

    <pre highlight="html">
      &lt;section>
        &lt;h2>My Cats&lt;/h2>
        &lt;p>You can play with my cat simulator.&lt;/p>
        &lt;object data="cats.sim">
          &lt;p>To see the cat simulator, use one of the following links:&lt;/p>
          &lt;ul>
            &lt;li>&lt;a href="cats.sim">Download simulator file&lt;/a>
            &lt;li>&lt;a href="https://sims.example.com/watch?v=LYds5xY4INU">Use online simulator&lt;/a>
          &lt;/ul>
          &lt;p>Alternatively, upgrade to the Mellblom Browser.&lt;/p>
        &lt;/object>
        &lt;p>I'm quite proud of it.&lt;/p>
      &lt;/section>
    </pre>
  </div>


<h4 id="sec-global-attributes"><dfn lt="Global attributes">범용 속성(attribute)</dfn></h4>

  다음 속성(attribute)들은 모든 <a lt="html elements">html 요소(element)들</a>에 정의될 수 있습니다 
  <span class="impl"> (심지어 이 명세에 정의되어 있지 않더라도)</span>:

  * <{global/accesskey}>
  * <code>class</code>
  * <{global/contenteditable}>
  * <{global/contextmenu}>
  * <{global/dir}>
  * <{global/draggable}>
  * <{global/dropzone}>
  * <code>hidden</code>
  * <{global/id}>
  * <{global/lang}>
  * <code>spellcheck</code>
  * <code>style</code>
  * <code>tabindex</code>
  * <{global/title}>
  * <code>translate</code>

  <div class="impl">
  이 속성(attribute)들은 <a lt="HTML elements">HTML 요소(element)들</a>에 대한 속성(attribute)들로서
  이 명세에 의해서만 정의됩니다. 이 명세가 이 속성(attribute)들을 가지는 요소(element)에 참조하는 
  경우, 이 속성(attribute)들을 가지는 것으로 정의되지 않은 네임스페이스의 요소(element)들은 이
  속성(attribute)들을 가진 요소(element)들이 되는 것으로 간주되지 않아야(must) 합니다.

  <div class="example">
    예를 들어, 다음 XML 코드 조각에서, "<code>bogus</code>" 요소(element)는 리터럴 이름 
    "<{global/dir}>"을 가진 속성(attribute)을 가짐에도 불구하고, 이 명세에 정의된 대로 <{global/dir}>
    속성(attribute)을 가지지 않습니다. 따라서, 가장 안쪽 <{span}> 요소(element)의 <a lt="the directionality">방향성</a>은
    간접적으로 "<code>bogus</code>" 요소(element)를 통해 <{div}> 요소(element)로부터 상속 된, 
    &quot;<a attr-value for="global/dir"><code>rtl</code></a>&quot;입니다.

    <pre class="bad">
      &lt;div xmlns="https://www.w3.org/1999/xhtml" dir="rtl">
        &lt;bogus xmlns="https://example.net/ns" dir="ltr">
          &lt;span xmlns="https://www.w3.org/1999/xhtml">
          &lt;/span>
        &lt;/bogus>
      &lt;/div>
    </pre>
  </div>

  </div>

  <hr />

  보조 기술 제품이 HTML 요소(element)와 속성(attribute)으로 가능한 것보다 좀 더 세밀한 인터페이스를 
  노출할 수 있게 하기 위해, 보조 기술 제품을 위한 주석(annotation)의 세트가 명시될 수 있습니다 (ARIA 
  <code>role</code>과 <code>aria-*</code> 속성(attribute)들). [[!WAI-ARIA]]

  <hr />

  다음 <a lt="event handler content attributes">이벤트 처리기 콘텐트 속성(attribute)들</a>은 모든
  <a lt="HTML element">HTML 요소(element)</a>에 명시될 수 있습니다:

  * <code>onabort</code>
  * <code>onblur</code>*
  * <code>oncancel</code>
  * <code>oncanplay</code>
  * <code>oncanplaythrough</code>
  * <code>onchange</code>
  * <code>onclick</code>
  * <code>onclose</code>
  * <code>oncontextmenu</code>
  * <code>oncopy</code>
  * <code>oncuechange</code>
  * <code>oncut</code>
  * <code>ondblclick</code>
  * <code>ondrag</code>
  * <code>ondragend</code>
  * <code>ondragenter</code>
  * <code>ondragexit</code>
  * <code>ondragleave</code>
  * <code>ondragover</code>
  * <code>ondragstart</code>
  * <code>ondrop</code>
  * <code>ondurationchange</code>
  * <code>onemptied</code>
  * <code>onended</code>
  * <code>onerror</code>*
  * <code>onfocus</code>*
  * <code>oninput</code>
  * <code>oninvalid</code>
  * <code>onkeydown</code>
  * <code>onkeypress</code>
  * <code>onkeyup</code>
  * <code>onload</code>*
  * <code>onloadeddata</code>
  * <code>onloadedmetadata</code>
  * <code>onloadstart</code>
  * <code>onmousedown</code>
  * <code>onmouseenter</code>
  * <code>onmouseleave</code>
  * <code>onmousemove</code>
  * <code>onmouseout</code>
  * <code>onmouseover</code>
  * <code>onmouseup</code>
  * <code>onwheel</code>
  * <code>onpaste</code>
  * <code>onpause</code>
  * <code>onplay</code>
  * <code>onplaying</code>
  * <code>onprogress</code>
  * <code>onratechange</code>
  * <code>onreset</code>
  * <code>onresize</code>*
  * <code>onscroll</code>*
  * <code>onseeked</code>
  * <code>onseeking</code>
  * <code>onselect</code>
  * <code>onshow</code>
  * <code>onstalled</code>
  * <code>onsubmit</code>
  * <code>onsuspend</code>
  * <code>ontimeupdate</code>
  * <code>ontoggle</code>
  * <code>onvolumechange</code>
  * <code>onwaiting</code>

  <p class="note">
    별표로 표기 된 속성(attribute)들은 <{body}> 요소(element)들에 명시되었을 경우 그 요소(element)들이
    동일한 이름을 가지고 <code>Window</code> 객체의 <a lt="event handlers">이벤트 처리기</a>를 노출하기
    때문에 다른 의미(meaning)를 가집니다.
  </p>

  <p class="note">
    이 속성(attribute)들이 모든 요소(element)들에 적용되는데 반해, 그것들이 모든 요소(element)에 
    쓸모있는 것은 아닙니다. 예를 들어 <a lt="media elements">미디어 요소(element)들</a>만이 유저 
    에이전트에 의해 발생된 <a event for="media"><code>volumechange</code></a> 이벤트를 받을 것입니다. 
  </p>

  <hr />

  <a lt="Custom data attributes">커스텀 데이터 속성(attribute)들</a>은 (예를 들어, 
  <code>data-foldername</code>나 <code>data-msgid</code>) 모든 <a lt="HTML element">HTML 요소(element)</a>에
  페이지에 특수한 커스텀 데이터를 저장하기 위해 명시 될 수 있습니다.

  <hr />

  <a lt="HTML documents">HTML 문서들</a>에, <a lt="HTML namespace">HTML 네임스페이스</a> 안에 있는
  요소(element)들은 명시된 <code>xmlns</code> 속성(attribute)을 가질 수 있고, 이 속성(attribute)을 
  가진 경우에만, 정확한 값 "<code>https://www.w3.org/1999/xhtml</code>"을 가집니다. 이것은
  <a lt="XML documents">XML 문서들</a>에는 적용되지 않습니다.

  <p class="note">
    HTML에서, <code>xmlns</code> 속성(attribute)은 전혀 영향을 가지지 않습니다. 이것은 기본적으로 
    마스코트 같은 것 입니다. 단지 XHTML로 그리고 XHTML로부터 약간 쉽게 마이그레이션 할 수 있도록 
    허용된 것입니다. <a lt="HTML parser">HTML 해석기</a>에 의해 해석된 경우, 속성(attribute)은
    XML에서 네임스페이스 선언 속성(attribute)과 같은 "<code>https://www.w3.org/2000/xmlns/</code>"
    네임스페이스가 아닌, 어떤 네임스페이스에도 없게 됩니다.
  </p>

  <p class="note">
    XML에서, <code>xmlns</code> 속성(attribute)은 네임스페이스 선언 메커니즘의 일부이고, 요소(element)는
    실제로 명시된 네임스페이스가 없는 <code>xmlns</code> 속성(attribute)을 가질 수 없습니다.
  </p>

  <hr />

  XML 명세는 또한 <a lt="XML document">XML 문서</a>에 있는 모든 요소에 <a lt="XML namespace">XML 네임스페이스</a>에
  있는 <code>xml:space</code> 속성(attribute)의 사용을 허용합니다. 이 속성(attribute)은 HTML에서 기본
  동작이 여백을 유지하는 것이기 때문에, <a lt="html elements">html 요소(element)들</a>에 어떤 영향도 
  가지지 않습니다. [[!XML]]

  <p class="note">
    <a href="#text-html"><code>text/html</code></a> 문법에서 <a lt="html elements">html 요소(element)들</a>에
    <code>xml:space</code> 속성(attribute)을 직렬화 하는 방법은 없습니다.
  </p>

<h5 id="the-id-attribute"><dfn element-attr for="global"><code>id</code></dfn> 속성(attribute)</h5>

  <code>id</code> 속성(attribute)은 그 요소(element)의 <a lt="id">고유 식별자 (ID)</a>를 명시합니다. 
  [[!DOM]]

  값은 요소(element)의 <a lt="home subtree">홈 하위 트리</a>에 있는 모든 <a lt="IDs">ID들</a> 중 
  고유해야(must) 하고 적어도 하나의 문자를 포함해야(must) 합니다. 값은 어떠한 
  <a lt="space characters">공백 문자들</a>도 포함하지 않아야(must) 합니다.

  <p class="note">
    ID가 취할 수 있는 형식에는 다른 제약사항이 없습니다; 특별히, 숫자로 구성 될 수도, 숫자로 시작할 
    수도, 밑줄로 시작할 수도, 구두점으로 구성 될 수도, 기타 등등이 가능합니다.
  </p>

  <p class="note">
    요소(element)의 <a lt="id">고유 식별자</a>는 가장 명백하게는 부분 식별자를 사용하여 문서의 특정 
    부분으로 연결하기 위한 방법으로, 스크립팅의 경우 요소(element)를 목표로 삼기 위한 방법으로,
    CSS에서 특정 요소(element)를 스타일하기 위한 방법 등 다양한 목적으로 사용될 수 있습니다.
  </p>

  <div class="impl">
    식별자는 분명하지 않은 문자열입니다. 특별한 의미(meanings)가 <code>id</code> 속성(attribute)의 
    값으로부터 파생되지 않아야(should) 합니다.
  </div>

<h5 id="the-title-attribute"><code>title</code> 속성(attribute)</h5>

  <dfn element-attr for="global,figure,div,img,textarea,meter"><code>title</code></dfn> 속성(attribute)은 
  툴팁에 적절할 것 같은 조언 정보를 <a lt="represents">나타냅니다</a>. 링크에서, 이것은 제목(title)이나
  대상 리소스의 설명이 될 수 있고; 이미지에서, 이미지 제공자(image credit)나 이미지의 설명; 문단에서,
  텍스트에 각주나 주석; 인용구에서, 소스에 대한 추가적인 정보; 
  <a lt="interactive content">대화형(interactive)  콘텐트</a>에서, 요소(element)의 사용에 대한 
  레이블이나 지시사항 등등이 될 수 있습니다. 값은 텍스트입니다.

  <p class="note">
    <code>title</code> 속성(attribute)에 의존하는 것은 많은 유저 에이전트들이 이 명세에 의해 요구된 
    대로 접근 가능한 방법으로 속성을 노출하지 않기 때문에 (예를 들어, 현대의 폰이나 태블릿을 가진 
    사람들 같이, 키보드만 사용하는 유저와 터치만 사용하는 유저들을 배제하고, 툴팁이 나타나도록 하기 
    위해 마우스 같은 포인팅 디바이스를 요구하는 것) 현재 지양됩니다.
  </p>

  이 속성(attribute)이 요소(element)에 생략되었다면, <code>title</code> 속성(attribute) 설정을 가진 
  가장 가까운 조상 <a lt="HTML element">HTML 요소</a>의 <code>title</code> 속성(attribute)이 이
  요소(element)에도 관련 됨을 암시합니다. 속성(attribute)이 이것을 재정의하도록 설정하는 것은, 
  명시적으로 모든 조상 요소(element)의 조언 정보가 이 요소에 관련되지 않음을 지정하는 것입니다.
  속성(attribute)을 빈 문자열로 설정하는 것은 요소(element)가 조언 정보를 가지지 않는 다는 것을 
  나타냅니다.

  <code>title</code> 속성(attribute)의 값이 U+000A 라인피드 (LF) 문자를 포함한다면, 콘텐트는 
  여러 줄로 나뉘어 집니다. 각 U+000A 라인피드 (LF) 문자는 개행을 나타냅니다.

  <div class="example">
    주의해야 할 것은 <code>title</code> 속성(attribute)에 새로운 행을 사용하는 점에 대해 신중해야 합니다.

    예를 들어, 다음 코드 조각은 실제로 <em>개행이 있는</em> 축약어의 본딧말을 정의합니다:

    <pre class="bad" highlight="html">
      &lt;p>My logs show that there was some interest in &lt;abbr title="Hypertext
      Transport Protocol">HTTP&lt;/abbr> today.&lt;/p>
    </pre>

	
    <p class="translator-note">
      마치 &lt;br> 이 있는 것과 같이 표현되며, 스크린 리더로 읽을 시에도 &lt;br> 처리가 된 것 처럼 
      "Hypertext"를 한 개 행으로, "Transport Protocol"를 한 개 행으로 읽습니다. <br>
	  즉, "Hypertext Transport Protocol" 이라는 하나의 용어를 의미하지 않게 됩니다.
    </p>
  </div>

  <{link}>, <{abbr}>, <{input}> 같은 어떤 요소(element)들은 위에서 설명된 의미(semantics) 이외에 
  <code>title</code> 속성(attribute)에 대한 추가적인 의미(semantics)를 정의합니다.

  <div class="impl">
    요소(element)의 <dfn lt="advisory information">조언 정보</dfn>는 일단 값이 반환되면 알고리즘이 
    중단되는 다음 알고리즘이 반환하는 값입니다. 알고리즘이 빈 문자열을 반환하는 경우, 조언 정보는
    없습니다.

    1. 요소(element)가 <{link}>, <{style}>, <{dfn}>, <{abbr}>, <{menuitem}> 요소(element)라면:
        요소(element)가 <code>title</code> 속성(attribute)을 가진다면, 그 속성(attribute)의 값을 
        반환하고, 그렇지 않으면 빈 문자열을 반환합니다.
    2. 그렇지 않고, 요소(element)가 속성(attribute)을 가진다면, 그 값을 반환합니다.
    3. 그렇지 않고, 요소(element)가 부모 요소를 가진다면, 부모 요소(element)의 
        <a lt="advisory information">조언 정보</a>를 반환합니다.
    4. 그렇지 않으면, 빈 문자열을 반환합니다.

    유저 에이전트들은 요소(element)가 <a lt="advisory information">조언 정보</a>를 가지는 경우,  
    사용자에게 알려야(should) 하고, 그렇지 않으면 정보는 인지될 수 없을 것입니다.

    <hr />

    <code>title</code> IDL 속성(attribute)은 <code>title</code> 콘텐트 속성(attribute)을 
    <a lt="reflect">반영</a>해야(must) 합니다.
  </div>

<h5 id="the-lang-and-xmllang-attributes">
  <{global/lang}>과 <{xml/lang|xml:lang}> 속성(attribute)
</h5>

  <dfn element-attr for="global"><code>lang</code></dfn> 속성(attribute)은 (네임스페이스에 없는)
  요소(element)의 콘텐츠와 텍스트를 포함하는 요소(element)의 속성(attribute)에 대한 주 언어를
  명시합니다. 그 값은 유효한 BCP 47 언어 태그나 빈 문자열이어야(must) 합니다. 속성(attribute)을 빈 
  문자열로 설정하는 것은 주 언어가 알 수 없는 것임을 나타냅니다. [[!BCP47]]

  <a lt="XML namespace">XML 네임스페이스</a>에 있는 <dfn element-attr for="xml"><code>lang</code></dfn> 
  속성(attribute)은 XML에서 정의됩니다. [[!XML]]

  요소(element)에서 이 속성(attribute)들이 생략되었다면, 이 요소(element)의 언어는 부모 요소(element)의 
  언어가 있다면 그것과 동일합니다.

  네임 스페이스가 없는 <{global/lang}> 속성(attribute)은 모든 <a lt="HTML element">HTML 요소(element)</a>에
  사용 될 수 있습니다.

  <a lt="XML namespace">XML 네임스페이스</a>에 있는 <{global/lang}> 속성(attribute)은 
  <a lt="XML documents">XML 문서</a>의 <a lt="html elements">html 요소(element)들</a> 뿐만 아니라, 
  관련 명세가 그것을 허용한다면 (특히, MathML과 SVG는 그들의 요소(elemenet)에 
  <a lt="XML namespace">XML 네임스페이스</a>의 <{global/lang}> 속성(attribute)이 명시되는 것을 
  허용합니다) 다른 네임스페이스에 있는 요소(element)들에 사용될 수 있습니다. 네임 스페이스가 없는
  <{global/lang}> 속성(attribute)과 <a lt="XML namespace">XML 네임스페이스</a>에 있는 <{global/lang}> 
  속성(attribute)이 모두 동일한 요소(element)에 명시되었다면, 그것들은 <a lt="ASCII case-insensitive">ASCII 대소문자 비구분</a>
  방식으로 비교되는 경우 정확히 동일한 값을 가져야(must) 합니다.

  작성자는 <a lt="HTML documents">HTML 문서들</a>의 <a lt="html elements">html 요소(element)들</a>에
  <a lt="XML namespace">XML 네임스페이스</a>에 있는 <{global/lang}> 속성(attribute)을 사용하지 
  않아야(must) 합니다. XHTML로 그리고 XHTML로부터 쉬운 마이그레이션을 위해, 작성자는 
  <a lt="XML namespace">XML 네임스페이스</a>가 없는 속성(attribute)을 <a lt="HTML documents">HTML 문서</a>의 
  <a lt="html elements">html 요소(element)들</a>에 지역 이름 "<{xml/lang|xml:lang}>"를 가지고 접두어 
  없이 명시할 수 있지만, 그러한 속성(attribute)들은 네임스페이스가 없는 <{global/lang}> 
  속성(attribute)도 명시된 경우에만 명시되어야(must) 하고, 두 속성(attribute) 모두  
  <a lt="ASCII case-insensitive">ASCII 대소문자 비구분</a> 방법으로 비교될 경우 동일한 값을 가져야(must)
  합니다.

  <p class="note">
    접두어가 없고 리터럴 지역 이름 "<{xml/lang|xml:lang}>"을 가진 네임스페이스가 없는 속성(attribute)은
    언어 처리에 영향을 가지지 않습니다.
  </p>

  <p class="warning" id="lang-warning">
  <a lt="HTML documents">HTML 문서들</a>의 언어는 (문서의 주 언어를 나타내기 위해 <{HTML}> 요소(element)
  자신에, 언어의 변경을 나타내기 위해 각 요소(element)들에) <{global/lang}> 속성(attribute)을
  사용하여 나타납니다. 그것은 콘텐트의 언어에 대해 유저 에이전트들에 명시적인 표시를 제공하기 때문에,
  적절한 언어 사전이 사용될 수 있고, 스크린 리더와 음성 출력을 가진 비슷한 보조 기술의 경우에, 
  콘텐트는 올바른 음성 / 언어 라이브러리를 (사용 가능한 경우) 사용하여 발음됩니다. <strong>문서나
  문서 일부의 언어와 일치하지 않는 <{global/lang}> 속성(attribute)을 사용하여 언어를 설정하는 것은 
  일부 사용자가 내용을 이해할 수 없게 만들 것입니다</strong>.
  </p>

  <div class="impl">
    <hr />

    노드의 <dfn lt="language">언어</dfn>를 결정하기 위해, 유저 에이전트들은 
    <a lt="XML namespace">XML 네임스페이스</a>에 있는 <{global/lang}> 속성(attribute) 세트를 가지거나 
    네임스페이스가 없는 <{global/lang}> 속성(attribute) 세트를 가진 <a lt="HTML element">HTML 요소(element)</a>인 
    가장 가까운 조상 요소(element)를 (노드가 요소(element)라면 그 요소(element)를 포함하여) 고려해야(must)
    합니다. 그 속성(attribute)은 노드의 언어를 명시합니다(그 값에 상관하지 않고). 

    네임 스페이스가 없는 <{global/lang}> 속성(attribute)과 <a lt="XML namespace">XML 네임스페이스</a>에
    있는 <{global/lang}> 속성(attribute)이 둘 모두 요소(element)에 설정된 경우, 유저 에이전트들은 
    <a lt="XML namespace">XML 네임스페이스</a>에 있는 <{global/lang}> 속성(attribute)을 사용해야(must)하고,
    네임 스페이스가 없는 <{global/lang}> 속성(attribute)은 요소(element)의 언어 결정의 목적에 대해 
    <a lt="ignored">무시</a>되어야(must) 합니다.

    <a lt="root element">루트 요소(element)</a>를 포함하여 노드나 노드의 조상 중 어떠한 것도 속성(attribute) 
    세트를 가지지 않지만, <a lt="pragma-set default language">선처리 설정 기본 언어</a> 세트가 존재한다면, 
    그것은 노드의 언어입니다. <a lt="pragma-set default language">선처리 설정 기본 언어</a> 세트가 
    없다면, 상위 레벨 프로토콜(HTTP 같은)의 언어 정보가 있다면 대신 마지막 폴백 언어로서 그것이
    사용되어야(must) 합니다. 그러한 언어 정보가 없고, 상위 레벨 프로토콜이 여러 언어를 출력하는
    경우, 노드의 언어는 알 수 없고, 해당하는 언어 태그는 빈 문자열입니다.

    <p class="example">
      예를 들어, 문서가 HTTP로 전송되고 <code>Content-Language</code> HTTP 헤더가 "<code>en</code>"로 
      정의되어 있다면 (그리고 선처리 설정 기본 언어가 없다면), 그 자체에 <{global/lang}> 속성이나
      해당 요소(element)의 어떤 조상도 가지지 않는 문서 내 모든 요소(element)에 대해, 요소에 대한
      폴백 언어는 영어가 될 것입니다. <code>Content-Language</code> 헤더의 값이 "<code>de, fr, it</code>"
      였다면, 노드의 언어는 알 수 없습니다. 
      <a href="https://www.w3.org/International/questions/qa-http-and-lang">이 글</a>은 HTTP 헤더와
      언어 정보를 제공하는 <{meta}> 요소(element) 사용에 대한 몇 가지 추가적인 지침을 제공합니다.
    </p>

    결과 값이 알려진 언어 태그가 아니라면, 모든 다른 언어들와 별개의, 주어진 언어 태그를 가지는
    알 수 없는 언어로 취급되어야(must) 합니다. 언어 태그를 기대하는 다른 서비스와 왕복하거나 
    통신하는 목적을 위해,  유저 에이전트들은 BCP 47 언어 태그가 되도록 태그 되고, 수정되지 않은 채로
    알 수 없는 언어를 전달해야(should) 하기 때문에, 차후 서비스들은 언어 설명의 다른 유형으로
    데이터를 해석하지 않습니다. [[!BCP47]]

    <p class="example">
      따라서, 예를 들어, <code>lang="xyzzy"</code>를 가진 요소(element)는, 둘 모두 동일하게 유효하지 
      않기는 하지만, 선택자 <code>:lang(xyzzy)</code>에 (예를 들어, CSS에서) 매칭될 것이지만 
      <code>:lang(abcde)</code>에는 매칭되지 않을 것입니다. 비슷하게, 웹 브라우저와 스크린 리더가 
      요소(element)의 언어에 대해 합력하여 통신했다면, 그것이 유효하지 않다는 것을 알았을 지라도, 
      결국에는 스크린 리더는 실제로 그 태그를 가지고 언어가 지원된 경우에 한하여, 브라우저는 
      스크린 리더에 언어가 "xyzzy"라고 알려줄 것입니다. 
      스크린 리더가 BCP 47과 인코딩 언어 이름을 위한 다른 문법이 모두 지원되고 그 다른 문법에서 
      문자열 "xyzzy"가 벨라루스어를 나타내는 방법이었다 하더라도, "xyzzy"는 벨라루스어가 BCP 47
      코드로 기술 된 방식이 아니기 때문에 (BCP 47은 벨라루스어에 대해 코드 "be"를 사용합니다), 
      그것은 스크린리더가 텍스트를 벨라루스어로 취급하기 시작하는 것은 <em>옳지 않게</em> 될 것입니다.
    </p>

    결과 값이 빈 문자열이라면, 노드의 언어가 명시적으로 알 수 없음을 의미하는 것으로 해석 되어야(must) 
    합니다.

    <hr />

    유저 에이전트들은 요소의 언어를 적절한 처리나 렌더링을 결정하는데 사용할 수 있습니다 (예를 들어,
    적절한 폰트나 발음의 선택으로, 혹은 사전 선택을 위해, 혹은 날짜 선택기 같은 양식 컨트롤의
    유저 인터페이스를 위해).

    <hr />

    <{global/lang}> IDL 속성(attribute)은 네임 스페이스가 없는 <{global/lang}> 콘텐트 속성(attribute)을
    <a lt="reflect">반영</a>해야(must) 합니다.
  </div>

<h5 id="the-translate-attribute"><code>translate</code> 속성(attribute)</h5>

  <dfn element-attr for="global"><code>translate</code></dfn> 속성(attribute)은 페이지가 지역화 될
  때 요소(element)의 속성(attribute) 값과 그것의 자식 <code>Text</code> 노드의 값이 번역될지 여부를
  지정하는데 사용되는 <a lt="enumerated attribute">열거 속성(attribute)</a>입니다.

  속성(attribute)의 키워드는 빈 문자열, <code>yes</code>, <code>no</code>입니다. 빈 문자열과 <code>yes</code> 
  키워드는 <i>yes</i> 상태에 매핑됩니다. <code>no</code> 키워드는 <i>no</i> 상태에 매핑됩니다. 게다가,
  세번째 상태가 있는데, <i>누락 기본 값</i>인 (그리고 <i>유효하지 않은 기본 값</i>인) <i>inherit</i>
  상태입니다.

  각 요소(element)는 (비 HTML 요소(element) 조차) <a lt="translate-enabled">번역 가능</a> 상태 혹은
  <a lt="no-translate">번역 안함</a> 상태에 속하는, <dfn lt="translation mode">번역 모드</dfn>를 
  가집니다. <a lt="HTML element">HTML 요소(element)</a>의 <code>translate</code> 속성(attribute)이 
  <i>yes</i> 상태에 있다면, 요소(element)의 <a lt="translation mode">번역 모드</a>는 
  <a lt="translate-enabled">번역 가능</a> 상태에 있습니다; 그렇지 않고 요소(element)의 <code>translate</code>
  속성(attribute)이 <i>no</i> 상태에 있다면, 요소(element)의 <a lt="translation mode">번역 모드</a>는
  <a lt="no-translate">번역 안함</a> 상태에 있습니다; 그렇지 않으면, 요소(element)의 <code>translate</code>
  속성(attribute)은 <i>inherit</i> 상태에 있거나 요소(element)는 <a lt="HTML element">HTML 요소(element)</a>가
  아니고 따라서 <code>translate</code> 속성(attribute)을 가지지 않습니다; 어느 경우에나, 요소(element)의
  <a lt="translation mode">번역 모드</a>는 그 부모 요소(element)의 상태가 있다면 그것과 동일한
  상태에 있거나, 요소가 <a lt="root element">루트 요소(element)</a>라면, <a lt="translate-enabled">번역 가능</a>
  상태에 있습니다.

  요소(element)가 <dfn lt="translate-enabled">번역 가능</dfn> 상태에 있다면, 요소(element)의 
  <a lt="translatable attributes">번역 가능 속성(attribute)들</a>과 자식 <code>Text</code> 노드의
  값들은 페이지가 지역화 될 경우 번역 되어야 합니다.

  요소(element)가 <dfn lt="no-translate">번역 안함</dfn> 상태에  있는 경우, 예를 들어, 요소(element)가
  사람의 이름이나 컴퓨터 프로그램의 이름을 포함하기 때문에, 요소(elment)의 속성(attribure)값과 자식
  <code>Text</code> 노드의 값들은 페이지가 지역화 될 때 그대로 남습니다.

  다음 속성(attribute)들은 <dfn lt="translatable attributes">번역 가능 속성(attribute)</dfn>입니다:

  * <{th}> 요소(element)의 <code>abbr</code>
  * <{area}>, <{img}>, <{input}> 요소(element)의 <code>alt</code>
  * <{meta}> 요소(element)의 <code>content</code>, 단 <code>name</code> 속성(attribute)이 번역될 수 
    있는 알려진 값을 가진 메타데이터 이름을 지정한다면.
  * <{a}>와 <{area}> 요소(element)의 <code>download</code> 
  * <{menuitem}>, <{menu}>, <{optgroup}>, <{option}>, <{track}> 요소(element)의 <code>label</code>
  * <a lt="html elements">html 요소(element)들</a>의 <{global/lang}>; 번역에 사용되는 언어와 일치하도록 
    "번역" 되어야(must) 합니다.
  * <code>input</code>과 <{textarea}> 요소(element)의 <code>placeholder</code>
  * <{iframe}> 요소(element)의 <code>srcdoc</code> ; 해석되고 재귀적으로 처리되어야(must) 합니다
  * <a lt="html elements">html 요소(element)들</a>의 <code>style</code>; 해석되고 재귀적으로 
    처리되어야(must) 합니다 (예를 들어, &quot;content&quot; 속성(property)의 값에 대해).
  * <a lt="html elements">html 요소(element)들</a> <code>title</code>
  * <a element-state for="input">Button</a>, <a element-state for="input">submit button</a>, 
    <a element-state for="input">reset button</a> 상태에 있는 <{input/type}> 속성(attribute)을 가진 
	<code>value</code>
    

  <div class="impl">
    <hr />

    <code>translate</code> IDL 속성(attribute)은 가져올 때 요소(element)의 <a lt="translation mode">번역 모드</a>가
    <a lt="translate-enabled">번역 가능</a>이라면 true를 반환하고, 그렇지 않으면 false를 반환해야(must) 
    합니다. 설정할 때, 새로운 값이 true라면 콘텐트 속성(attribute)의 값을 "<code>yes</code>"로 설정하고,
    그렇지 않으면 콘텐트 속성(attribute)의 값을 "<code>no</code>"로 설정해야(must) 합니다.
  </div>

  <div class="example">
    이 예제에서, 키보드 입력 견본과 프로그램 출력 견본을 제외하고, 페이지가 지역화 될 때 문서의 모든 
    것이 번역됩니다:

    <pre highlight="html">
      &lt;!DOCTYPE HTML>
      &lt;html> &lt;!-- default on the root element is translate=yes -->
        &lt;head>
          &lt;title>The Bee Game&lt;/title> &lt;!-- implied translate=yes inherited from ancestors -->
        &lt;/head>
        &lt;body>
          &lt;p>The Bee Game is a text adventure game in English.&lt;/p>
          &lt;p>When the game launches, the first thing you should do is type
            &lt;kbd translate=no>eat honey&lt;/kbd>. The game will respond with:&lt;/p>
        &lt;pre>&lt;samp translate=no>Yum yum! That was some good honey!&lt;/samp>&lt;/pre>
        &lt;/body>
      &lt;/html>
    </pre>
  </div>

<h5 id="the-xmlbase-attribute-xml-only"><dfn element for="global"><code>xml:base</code></dfn> 속성(attribute) (XML만)</h5>

  <code>xml:base</code> 속성(attribute)은 XML 기반에서 정의됩니다. [[!XMLBASE]]

  <code>xml:base</code> 속성(attribute)은 <a lt="XML documents">XML 문서들</a>의 
  <a lt="html elements">html 요소(element)</a>에 사용될 수 있습니다.
  작성자는 <a lt="HTML documents">HTML 문서들</a>에 있는 <a lt="html elements">html 요소(element)</a>에  must not use the 
  <code>xml:base</code>를 사용하지 않아야(must) 합니다.

<h5 id="the-dir-attribute"><code>dir</code> 속성(attribute)</h5>

  <dfn element-attr for="global"><code>dir</code></dfn> 속성(attribute)은 요소(element)의 텍스트 
  방향성을 명시합니다. 속성(attribute)은 다음 키워드와 상태를 가진 
  <a lt="enumerated attribute">열거 속성</a> 입니다:

  : <dfn state for="dir">ltr</dfn> 상태에 일치하는 <dfn attr-value for="global/dir"><code>ltr</code></dfn> 키워드
  :: 요소(element)의 콘텐트가 명시적으로 방향성이 왼쪽에서 오른쪽으로 구분 된 텍스트임을 나타냅니다.
  : <dfn state for="dir">rtl</dfn> 상태에 일치하는 <dfn attr-value for="global/dir"><code>rtl</code></dfn> 키워드
  :: 요소(element)의 콘텐트가 명시적으로 방향성이 오른쪽에서 왼쪽으로 구분 된 텍스트임을 나타냅니다.
  : <dfn state for="dir">auto</dfn> 상태에 일치하는 <dfn attr-value for="global/dir"><code>auto</code></dfn> 키워드
  :: 요소(element)의 콘텐트가 명시적으로 방향성이 구분 된 텍스트임을 나타내지만, 방향은 요소(element)의 
      콘텐츠를 사용하여 (아래 설명된 대로) 프로그램적으로 결정됩니다.

      <p class="note">
        이 상태에 의해 사용되는 휴리스틱은 매우 조잡합니다 (양방향 알고리즘에서 문단 레벨 결정과 
        유사한 방식으로, 강한 방향성을 가진 첫 번째 문자를 살필 뿐입니다). 작성자는 텍스트의 방향이
        정말로 알 수 없고 적용 될 수 있는 더 나은 서버 사이드 휴리스틱이 없을 경우, 최후의 수단으로만
        이 값을 사용하도록 권장됩니다. [[!BIDI]]
      </p>

      <p class="note">
        <code>textarea</code>과 <{pre}> 요소(element)에 대해, 휴리스틱은 문단별 레벨에 적용됩니다.
      </p>

  속성(attribute)은 <i>유효하지 않은 기본 값</i>과 <i>누락 기본 값</i>이 없습니다.

  <hr />

  요소(element)의 <dfn lt="directionality|the directionality|the element's directionality">방향성</dfn>은
  (<a lt="HTML element">HTML 요소(element)</a>가 아닌 모든 요소) 
  &quot;<a attr-value for="global/dir"><code>ltr</code></a>&quot; 혹은 
  &quot;<a attr-value for="global/dir"><code>rtl</code></a>&quot;이고, 다음 목록의 단계들의 첫 번째 
  적절한 설정에 따라 결정됩니다:

  <dl class="switch">
    <dt>요소(element)의 <{global/dir}> 속성(attribute)이 <a state for="dir">ltr</a> 상태에 있다면</dt>
    <dt>
      요소(element)가 <a lt="root element">루트 요소(element)</a>이고 <{global/dir}> 속성(attribute)이 
      정의된 상태에 있지 않다면 (즉, 존재하지 않거나 유효하지 않은 값을 가지는 경우)
    </dt>
    <dt>
      요소(element)가 <code>type</code> 속성(attribute)이 <a element-state for="input">Telephone</a> 
      상태에 있고 <{global/dir}> 속성(attribute)이 정의된 상태에 있지 않은 (즉, 존재하지 않거나 
      유효하지 않은 값을 가지는 경우) <{input}> 요소(element)라면
    </dt>
    <dd>요소(element)의 <a lt="The directionality">방향성</a>이 &quot;<a state for="dir">ltr</a>&quot;입니다.</dd>

    <dt>요소(element)의 <{global/dir}> 속성(attribute)이 <a attr-value for="global/dir"><code>rtl</code></a> 상태에 있다면</dt>
    <dd>요소(element)의 <a lt="The directionality">방향성</a>이 &quot;<a state for="dir">rtl</a>&quot;입니다.</dd>

    <dt>
      요소(element)가 <code>type</code> 속성(attribute)이 <a element-state for="input">Text</a>, 
      <a element-state for="input">Search</a>, <a element-state for="input">Telephone</a>, 
      <a element-state for="input">URL</a>, <a element-state for="input">E-mail</a> 상태에 있고, 
      <{global/dir}> 속성(attribute)이 <a state for="dir">auto</a> 상태에 있는 <{input}> 요소(element)라면
    </dt>
    <dt>
      요소(element)가 <{textarea}> 요소(element)이고 <{global/dir}> 속성(attribute)이 
      <a state for="dir">auto</a> 상태에 있다면
    </dt>
    <dd>
      요소(element)의 <a lt="attribute value">값</a>이 양방향성 문자 유형 AL이나 R의 문자를 포함하고
      요소의 <a lt="attribute value">값</a>의 그 문자에 앞서 양방향성 문자 유형 L의 문자가 없다면,
      요소(element)의 <a lt="The directionality">방향성</a>은 &quot;<a state for="dir">rtl</a>&quot;입니다.
      [[!BIDI]]

      그렇지 않고, 요소(element)의 <a lt="attribute value">값</a>이 빈 문자열이 아니거나, 요소(element)가
      <a lt="root element">루트 요소(element)</a>라면, 요소(element)의 <a lt="The directionality">방향성</a>은 
      &quot;<a state for="dir">ltr</a>&quot;입니다.

      그렇지 않으면, 요소(element)의 <a lt="The directionality">방향성</a>은 요소(element)의 부모
      요소(element)의 <a lt="directionality">방향성</a>과 같습니다.
    </dd>

    <dt>요소(element)의 <{global/dir}> <{global/dir}> 속성(attribute)이 <a state for="dir">auto</a> 상태에 있다면</dt>
    <dt>
      요소(element)가 <{bdi}> 요소(element)이고 <{global/dir}> 속성(attribute)이 정의된 상태에 있지
      않다면 (즉, 존재하지 않거나 유효하지 않은 값을 가지는 경우)
    </dt>
    <dd>
      <a lt="tree order">트리 순서</a>에 따라 다음 기준에 일치하는 첫 번째 문자를 찾습니다:

      * 문자가 <a lt="directionality">방향성</a>이 결정되어야 할 요소(element)의 후손인 
        <code>Text</code> 노드에 있습니다.
      * 문자는 양방향성의 문자 유형 L, AL, 또는 R 입니다. [[!BIDI]]
      * 문자가 <a lt="directionality">방향성</a>이 결정되어야 할 요소(element)의 후손이면서 다음 중 
        하나인 조상 요소(element)를 가진 <code>Text</code> 노드에 없습니다:
        * <{bdi}> 요소(element).
        * <{script}> 요소(element).
        * <{style}> 요소(element).
        * <{textarea}> 요소(element).
        * 정의된 상태에 있는 <{global/dir}> 속성(attribute)을 가진 요소(element).

      그러한 문자가 발견되고 그것이 양방향성의 문자 유형 AL나 R의 것이라면, 요소(element)의 
      <a lt="The directionality">방향성</a>은 &quot;<a state for="dir">rtl</a>&quot;입니다.

      그러한 문자가 발견되고 그것이 양방향성의 문자 유형 L의 것이라면, 요소(element)의 
      <a lt="The directionality">방향성</a>은 &quot;<a state for="dir">ltr</a>&quot;입니다.

      그렇지 않고, 요소(element)가 <a lt="root element">루트 요소(element)</a>라면, 요소(element)의 
      <a lt="The directionality">방향성</a>은 &quot;<a state for="dir">ltr</a>&quot;입니다.

      그렇지 않으면, 요소(element)의 <a lt="The directionality">방향성</a>은 부모 요소(element)의 
      <a lt="directionality">방향성</a>과 같습니다.
    </dd>

    <dt>
      요소(element)가 부모 요소(element)를 가지고 <{global/dir}> 속성(attribute)이 정의된 상태에 
      있지 않다면 (즉, 존재하지 않거나 유효하지 않은 값을 가지는 경우)
    </dt>
    <dd>
      요소(element)의 <a lt="The directionality">방향성</a>은 요소(element)의 부모 요소(element)의 
      <a lt="directionality">방향성</a>과 같습니다.
    </dd>
  </dl>

  <p class="note">
    속성(attribute)은 <a lt="html elements">html 요소(element)</a>에만 사용될 수 있기 때문에, 다른
    네임스페이스의 요소(element)들에는 존재할 수 없습니다. 따라서, 다른 네임스페이스의 요소(element)들은
    그들의 부모 요소(element)에서 <a lt="directionality">방향성</a>을 상속 받거나, 부모 요소(element)를
    가지지 않는다면, 기본으로 &quot;<a attr-value for="global/dir"><code>ltr</code></a>&quot;가 됩니다.
  </p>

  <div class="impl">
    <p class="note">
      이 속성(attribute)은 <a href="#bidireq">양방향성 알고리즘을 수반하는 렌더링 요구사항을 가집니다</a>.
    </p>
  </div>

  <hr />

  속성(attribute)의 텍스트가 렌더링 되는 어떤 방식에 포함되는 경우, <a lt="HTML element">HTML 요소(element)</a>의
  <dfn lt="directionality of the attribute|directionality of an attribute">속성(attribute)의 방향성</dfn>은
  다음 목록의 단계들의 첫 번째 적절한 설정에 따라 결정됩니다:

  <dl class="switch">
    <dt>
      속성(attribute)이 <a lt="directionality-capable attribute">방향성이 가능한 속성(attribute)</a>이고
      요소(element)의 <{global/dir}> 속성(attribute)이 <a state for="dir">auto</a> 상태에 있다면
    </dt>
    <dd>
      양방향성의 문자 유형 L, AL, R의 것인 속성(attribute) 값의 첫 번째 문자(논리 순서에 따라)를 
      찾습니다 [[!BIDI]]</a>

      그 문자가 발견되고 양방향성의 문자 유형 AL이나 R의 것이라면, 
      <a lt="directionality of the attribute">속성(attribute)의 방향성</a>은 
      &quot;<a attr-value for="global/dir"><code>rtl</code></a>&quot;입니다.

      그렇지 않으면, <a lt="directionality of the attribute">속성(attribute)의 방향성</a>은 
      &quot;<a attr-value for="global/dir"><code>ltr</code></a>&quot;입니다.
    </dd>

    <dt>그렇지 않으면</dt>
    <dd>
      <a lt="directionality of the attribute">속성(attribute)의 방향성</a>은 
      <a lt="the element's directionality">요소(element)의 방향성</a>과 동일합니다.
    </dd>
  </dl>

  다음 속성(attribute)들은 <dfn lt="directionality-capable attributes">방향성이 가능한 속성(attribute)들</dfn>:

  * <{th}> 요소(element)의 <code>abbr</code>
  * <{area}>, <{img}>, <{input}> 요소(element)들의 <code>alt</code>
  * <code>name</code> 속성(attribute)이 값이 주로 휴먼 리더블 보다는 머신 리더블에 의도된 메타데이터를 
    명시한다면, <{meta}> 요소(element)들의 <code>content</code>
  * <{menuitem}>, <{menu}>, <{optgroup}>, <{option}>, <{track}> 요소(element)들의 <code>label</code>
  * <{input}>과 <{textarea}> 요소(element)들의 <code>placeholder</code>
  * 모든 <a lt="html elements">html 요소(element)들</a>의 <code>title</code>

  <hr />

  <dl class="domintro">
    <dt><var>document</var> . <code>dir</code> [ = <var>value</var> ]</dt>
    <dd>
      <{html}> 요소(element)의 <{global/dir}> 속성(attribute)의 값이 있다면 이를 반환합니다.

      <{html}> 요소(element)의 <{global/dir}> 속성(attribute)을 바꾸기 위해 
      "<a attr-value for="global/dir"><code>ltr</code></a>"나 
	  "<a attr-value for="global/dir"><code>rtl</code></a>" 혹은
	  "<a attr-value for="global/dir"><code>auto</code></a>"로 설정 될 수 있습니다.

      <{html}> 요소(element)가 없다면, 빈 문자열을 반환하고 새로운 값을 무시합니다.
    </dd>
  </dl>

  <div class="impl">
    요소(element)의 <code>dir</code> IDL 속성(attribute)은 <a lt="limited to only known values">알려진 값으로만 제한된</a>
    그 요소(element)의 <{global/dir}> 콘텐트 속성(attribute)을 <a lt="reflect">반영</a>해야(must) 합니다.

    {{Document}} 객체의 {{Document/dir}} IDL 속성(attribute)은 <{html}> 요소(element)가 있다면 
    <a lt="limited to only known values">알려진 값으로만 제한된</a> 그 요소의 <{global/dir}> 콘텐트
    속성(attribute)을 <a lt="reflect">반영</a>해야(must) 합니다. 그러한 요소(element)가 없다면, 
    속성(attribute)은 빈 문자열을 반환해야(must)하고 설정 할 때 아무 것도 하지 않아야(must) 합니다.    
  </div>

  <p class="note">
    작성자는 텍스트 방향성을 나타내기 위해 CSS를 사용하는 것 보다 <{global/dir}> 속성(attribute)을 
    사용하도록 강력히 권장되는데, 이는 CSS가 없는 경우에도 (예를 들어, 검색 엔진에 의해 해석되는 것 같은)
    문서가 올바르게 계속해서 렌더링 되는 방법이기 때문입니다. 
  </p>

  <div class="example">
    이 마크업 코드 조각은 IM 대화 내용의 것입니다.

    <pre highlight="html">
      &lt;p dir=auto class="u1">&lt;b>&lt;bdi>Student&lt;/bdi>:&lt;/b> How do you write "What's your name?" in Arabic?&lt;/p>
      &lt;p dir=auto class="u2">&lt;b>&lt;bdi>Teacher&lt;/bdi>:&lt;/b> &#x645;&#x627; &#x627;&#x633;&#x645;&#x643;&#x61f;&lt;/p>
      &lt;p dir=auto class="u1">&lt;b>&lt;bdi>Student&lt;/bdi>:&lt;/b> Thanks.&lt;/p>
      &lt;p dir=auto class="u2">&lt;b>&lt;bdi>Teacher&lt;/bdi>:&lt;/b> That's written "&#x634;&#x643;&#x631;&#x64b;&#x627;".&lt;/p>
      &lt;p dir=auto class="u2">&lt;b>&lt;bdi>Teacher&lt;/bdi>:&lt;/b> Do you know how to write "Please"?&lt;/p>
      &lt;p dir=auto class="u1">&lt;b>&lt;bdi>Student&lt;/bdi>:&lt;/b> "&#x645;&#x646; &#x641;&#x636;&#x644;&#x643;", right?&lt;/p>
    </pre>

    <{p}> 요소(element)에 대한 주어진 적절한 스타일 시트와 기본 정렬 스타일, 즉, 텍스트를 문단의 
    <i>시작 모서리</i>에 정렬하기 위해, 결과 렌더링은 다음과 같을 수 있습니다:

    <img src="images/im.png" alt="오른쪽으로 정렬 될 두 번째 문단과 마지막 문단을 제외하고, 왼쪽으로 콜론, 그 왼쪽으로 텍스트 처음이 있는 오른쪽에 정렬된 사용자 이름을 (이 예제에서는 'Student'와 'Teacher') 가진 왼쪽 정렬된 문단을 가진 별개의 블럭으로 렌더링 된 각 문단" width="366" height="157" />

    앞서 언근한 바와 같이, <code>auto</code> 값은 만병통치약이 아닙니다. 이 예제에서 마지막 문단은
    아랍 문자를 가지고 시작되었기 때문에, "right?"가 아랍어 텍스트의 왼쪽에 있도록 되어, 오른쪽에서
    왼쪽 텍스트가 되는 것으로 잘못 해석됩니다 
  </div>

<h5 id="classes"><dfn element-attr for="global"><code>class</code></dfn> 속성(attribute)</h5>

  매 <a lt="HTML element">HTML 요소(element)</a>는 명시된 <code>class</code> 속성(attribute)을 가질 수 있습니다.

  속성(attribute)이 명시되었다면 이 속성(attribute)은 요소(element)가 속하는 다양한 클래스를 나타내는 
  <a lt="set of space-separated tokens">공백으로 분리된 토큰의 세트</a>인 값을 가져야(must) 합니다.

  <div class="impl">
    <a lt="HTML element">HTML 요소(element)</a>가 할당한 클래스는 <code>class</code> 속성(attribute)의 
    값이 <a lt="split a string on spaces">공백으로 분리</a>될 때 반환되는 모든 클래스로 구성됩니다 
    (중복은 무시합니다).
  </div>

  <p class="note">
    요소(element)에 클래스를 할당하는 것은 클래스가 CSS에서 선택자에, DOM에서 
    <code>getElementsByClassName()</code> 메서드에, 다른 그러한 기능들에 매칭하는데 영향을 줍니다.
  </p>

  작성자가 <code>class</code> 속성(attribute)에 사용할 수 있는 토큰에 추가적인 제한 사항은 없지만,
  콘텐트의 희망 표현을 기술하는 값보다 콘텐트의 특징을 기술하는 값을 사용하도록 권장됩니다.

  <div class="impl">
    <hr />

    <p class="note">
      DOM 명세에 정의된 {{className}}과 {{classList}} IDL 속성(attribute)은 <code>class</code> 콘텐트
      속성(attribute)을 <a lt="reflect">반영</a>합니다. [[!DOM]]
    </p>
  </div>

  <h5 id="the-style-attribute"><dfn element-attr for="global"><code>style</code></dfn> 속성(attribute)</h5>

  <p class="warning">CSP3 지시자에 기반한 <code>style</code> 콘텐트 속성(attribute)를 차단하는 네이티브 구현은 알려진 것이 없습니다. 따라서 이 기능은 신뢰되지 않아야(should) 합니다.</p>  
  
  모든 <a lt="html elements">html 요소(element)들</a>은 <code>style</code> 콘텐트 속성(attribute)
  세트를 가질 수 있습니다. 이것은 CSS 스타일링 속성(attribute) 구문 명세에 의해 정의된 <a lt="CSS styling attribute">CSS 스타일링 속성(attribute)</a>입니다. 
  [[!CSS-STYLE-ATTR]]

    CSS를 지원하는 유저 에이전트들에서, 속성(attribute)의 값은 속성(attribute)이 추가되거나 그 값이
    변경되는 경우, <a lt="CSS styling attributes">CSS 스타일링 속성(attribute)</a>에 대해 주어진 
    규칙을 따라 해석되어야(must) 합니다. [[!CSS-STYLE-ATTR]]

    그러나, <a lt="Should element's inline behavior be blocked by Content Security Policy?">요소(element)의 인라인 동작은 콘텐트 보안 정책에 의해 차단되어야(should) 하는가?</a>
    알고리즘이 속성(attribute)의 요소(element)와 "<code>style attribute</code>"에서 실행되는 경우
    "<code>Blocked</code>"를 반환한다면, 속성(attribute))의 값에 정의된 스타일 규칙은 요소(element)에
    적용되지 않아야(must) 합니다. [[!CSP3]]

  요소(element)들에 <{global/style}> 속성(attribute)들을 사용하는 문서는 그 속성(attribute)이 제거된
  경우에도 여전히 이해될 수 있고 사용될 수 있어야(must) 합니다.

  <p class="note">
    특히, 콘텐트를 숨기고 보여주기 위해, 혹은 문서에 포함되지 않은 의미(meaning)를 전달하기 위해 
    <{global/style}> 속성(attribute)을 사용하는 것은 적합하지 않습니다. (콘텐트를 숨기고 보여주기 
    위해서는, <code>hidden</code> 속성(attribute)을 사용하세요.)
  </p>

  <hr />

  <dl class="domintro">
    <dt><var>element</var> . <code>style</code></dt>
    <dd>
      요소(element)의 <{global/style}> 속성(attribute)에 대한 <code>CSSStyleDeclaration</code> 객체를 
      반환합니다.
    </dd>
  </dl>

  <div class="impl">
    <code>style</code> IDL 속성(attribute)은 CSS 객체 모델 (CSSOM) 명세에서 정의됩니다. [[!CSSOM]]
  </div>

  <div class="example">
    다음 예제에서, 색상을 참조하는 단어가 시각 매체에 관련 색상으로 표시되도록 하기 위해 <{span}>
    요소(element)와 <code>style</code> 속성(attribute)을 사용하여 마크업 됩니다. 

    <pre highlight="html">
      &lt;p>My sweat suit is &lt;span style="color: green; background:
      transparent">green&lt;/span> and my eyes are &lt;span style="color: blue;
      background: transparent">blue&lt;/span>.&lt;/p>
    </pre>
  </div>

<h5 id="embedding-custom-non-visible-data-with-the-data-attributes"><code>data-*</code> 속성(attribute)들로 <dfn lt="Embedding custom non-visible data">보이지 않는 커스텀 데이터 삽입하기</dfn></h5>

  <dfn lt="custom data attribute">커스텀 데이터 속성(attribute)</dfn>은 이름이 하이픈 뒤에 적어도
  하나의 문자를 가지고, <a lt="XML-compatible">XML 호환 가능</a>하며, <a lt="uppercase ASCII letters">대문자 ASCII 문자</a>를 포함하는, 
  문자열 "<dfn element-attr for="global" lt="data-|data-*"><code>data-</code></dfn>"로 시작하는
  네임스페이스 없는 속성(attribute)입니다. 

  <p class="note">
    <a lt="HTML documents">HTML 문서들</a>의 <a lt="html elements">html 요소(element)들</a>의 모든
    속성(attribute) 이름은 자동적으로 ASCII 소문자로 얻어지기 때문에, ASCII 대문자에 대한 제한 사항은
    그 문서들에 영향을 주지 않습니다. 
  </p>

  <a lt="Custom data attributes">커스텀 데이터 속성(attribute)들</a>은 페이지나 어플리케이션에 대해
  더 이상 적절한 속성(attribute)들이나 요소(element)들이 없는 커스텀 데이터를 저장하기 위해 의도됩니다.

  이 속성(attribute)들은 속성(attribute)들을 사용하는 사이트의 관리자가 모르는 소프트웨어에서 사용을
  위해 의도되지 않습니다. 여러 독립적인 도구에 의해 사용되는 일반적인 확장을 위해, 이 명세는
  명시적으로 기능을 제공하도록 확장되어야(should) 하거나, 마이크로데이터 같은 기술이 (표준화 된 표현
  형식을 사용하는) 사용되어야(should) 합니다.

  <div class="example">
    예를 들어, 음악 관련 사이트는 각 트랙의 길이를 포함하는 커스텀 데이터 속성(attribute)을 가진 
    앨범의 트랙을 나타내는 목록 항목을 표시할 수 있습니다. 이 정보는 이후에 사이트에 의해 사용자가
    트랙 길이로 목록을 정렬하거나 특정 길이의 트랙에 대한 목록을 필터링하는 것을 허용하는데 사용될
    수 있습니다.

    <pre highlight="html">
      &lt;ol>
        &lt;li data-length="2m11s">Beyond The Sea&lt;/li>
        ...
      &lt;/ol>
    </pre>

    하지만, 사용자가 이 데이터를 살펴봄으로 특정 길이의 트랙을 찾기 위해 그 음악 사이트와 관련되지
    않은 일반 소프트웨어를 사용하는 것은 적절하지 않을 것입니다.

    이것은 이 속성(attribute)들이 사이트의 자체 스크립트에 의해 사용되도록 의도되었고, 범용적으로
    사용가능한 메타데이터에 대한 일반적인 확장 메커니즘이 아니기 때문입니다.
  </div>

  <div class="example">
    비슷하게, 페이지 작성자는 사용하려는 번역 도구에 대한 정보를 제공하는 마크업을 작성할 수 있습니다:

    <pre highlight="html">
      &lt;p>The third &lt;span data-mytrans-de="Anspruch">claim&lt;/span> covers the case of
      &lt;span translate="no">HTML&lt;/span> markup.&lt;/p>
    </pre>

    이 예제에서, "<code>data-mytrans-de</code>" 속성(attribute)은 "claim"이라는 문구를 독일어로 번역  
    하는 MyTrans 제품에 사용할 특정 텍스트를 제공합니다. 하지만, 표준 <code>translate</code> 
    속성(attribute)은 모든 언어에서 "HTML"은 변경되지 않고 남기기 위한 것임을 알리기 위해 사용됩니다.
    표준 속성(attribute)이 사용 가능한 경우, <a lt="custom data attribute">커스텀 데이터 속성(attribute)</a>이
    사용될 필요가 없습니다. 
  </div>

  매 <a lt="HTML element">HTML 요소(element)</a>는 임의의 값을 가지고 명시된 
  <a lt="custom data attributes">커스텀 데이터 속성(attribute)들</a>을 얼마든지 가질 수 있습니다. 

  <hr />

  <dl class="domintro">
    <dt><var>element</var> . <code>dataset</code></dt>
    <dd>
      요소(element)의 <code>data-*</code> 속성(attribute)들에 대한 <code>DOMStringMap</code> 객체를 반환합니다.

      하이픈으로 연결된 이름들은 카멜-케이스가 됩니다. 
      예를 들어, <code>data-foo-bar=""</code>는 <code>element.dataset.fooBar</code>가 됩니다.
    </dd>

  </dl>

  <div class="impl">
    {{HTMLElement/dataset}} IDL 속성(attribute)은 요소의 모든 <code>data-*</code> 속성(attribute)들에
    대한 편리한 접근자를 제공합니다. 가져올 때, <code>dataset</code> IDL 속성(attribute)은 그들의
    요소(element)에 이 속성(attribtue)들을 노출하는 다음 알고리즘과 연관된 <code>DOMStringMap</code>
    객체를 반환해야(must) 합니다:

    : 이름-값 쌍의 목록을 가져오기 위한 알고리즘
    :: 1. <var>list</var>를 이름-값 쌍의 빈 목록으로 둡니다.
        2. 첫 다섯 문자가 문자열 "<code>data-</code>"이고 나머지 문자들이 (있다면) 
            <a lt="uppercase ASCII letters">대문자 ASCII 글자들</a>을 포함하지 않는 요소(element)의 
            각 콘텐트  속성(attribute)에 대해, 그 속성(attribute)들이 요소(element)의
            <a lt="element attribute">속성(attribute) 목록</a>에 나열된 순서에 따라, 이름이 처음 다섯 
            글자가 삭제 된 속성(attribute)의 이름과 값이 속성(attribute)의 값인 이름-값 쌍을 
            <var>list</var>에 추가합니다.
        3. <var>list</var>의 각 이름에 대해, 이름에 <a lt="lowercase ASCII letter">소문자 ASCII 글자</a>가 
            뒤따르는 각 U+002D HYPHEN-MINUS 문자 (-)에 대해, U+002D HYPHEN-MINUS 문자 (-)를 삭제하고 
            그 뒤에 오는 글자를 <a lt="converted to ASCII uppercase">ASCII 대문자로 변환 된</a> 동일한
            글자로 변경합니다.
        4. <var>list</var>를 반환합니다.

    : 이름을 특정 값으로 설정하기 위한 알고리즘
    :: 1. <var>name</var>을 알고리즘에 전달되는 이름으로 둡니다.
        2. <var>value</var>를 알고리즘에 전달되는 값으로 둡니다.
        3. <var>name</var>이 <a lt="lowercase ASCII letter">소문자 ASCII 글자</a>가 뒤따르는 U+002D
            HYPHEN-MINUS 문자 (-)를 포함한다면, "{{SyntaxError}}" {{DOMException}}을 던지고 이
            단계들을 중단합니다.
        4. <var>name</var>에 각 <a lt="uppercase ASCII letter">대문자 ASCII 글자</a>에 대해, 글자 앞에 
            U+002D HYPHEN-MINUS 문자 (-)를 추가하고 글자를 <a lt="converted to ASCII lowercase">ASCII 소문자로 변환 된</a>
            동일한 글자로 바꿉니다.
        5. <var>name</var>의 맨 앞에 문자열 <code>data-</code>를 추가합니다.
        6. 이름 <var>name</var>을 가진 속성(attribute)의 값을 속성이 이미 존재한다면 이전 값을 
            교체하여, 값 <var>value</var>으로 설정합니다. <code>setAttribute()</code>가 속성을 이름
            <var>name</var>으로 설정할 때 예외를 던졌다면, 이것은 동일한 예외를 던져야(must) 합니다.

    : 이름을 삭제하기 위한 알고리즘
    :: 1. <var>name</var>을 알고리즘에 전달될 이름으로 둡니다.
        2. <var>name</var>의 각 <a lt="uppercase ASCII letter">대문자 ASCII 글자</a>에 대해, 글자 앞에
            U+002D HYPHEN-MINUS 문자 (-)를 추가하고 글자를 <a lt="converted to ASCII lowercase">ASCII 소문자로 변환 된</a>
            동일한 글자로 바꿉니다.
        3. <var>name</var>의 맨 앞에 문자열 <code>data-</code>를 추가합니다.
        4. 이름 <var>name</var>을 가진 속성(attribute)가 있다면, 그 속성(attribute)을 제거합니다.
            달리 아무 것도 하지 않습니다.

        <p class="note">
          이 알고리즘은 이름-값 쌍의 목록을 가져오는 앞선 알고리즘에 의해 주어진 이름에 대해서만 웹 
          IDL 명세에 의해 호출 될 것입니다. [[!WEBIDL]]
        </p>
  </div>

  <div class="example">
    웹 페이지가 우주선을 나타내기 위한 요소(element)를 원한다면, 예를 들어 게임의 일부분으로, 
    <code>data-*</code> 속성(attribute)들과 함께 <code>class</code> 속성(attribute)을 사용해야(have to)
    할 것입니다:

    <pre highlight="html">
      &lt;div class="spaceship" data-ship-id="30">
        &lt;button class="fire" onclick="spaceships[this.parentNode.dataset.shipId].fire()">
          Fire
        &lt;/button>
      &lt;/div>
    </pre>

    API에서 하이픈으로 연결된 속성(attribute)이름이 카멜 케이스로 되는 방식에 주목하세요.
  </div>

  작성자는 속성(attribute)들이 무시되고 관련된 CSS가 사라지는 경우, 페이지가 여전히 사용 가능 하도록
  이러한 확장을 신중하게 설계해야 합니다.

  <div class="impl">
    유저에이전트들은 이 속성(attribute)들이나 값들로부터 구현 행동을 파생하지 않아야(must) 합니다.
    유저 에이전트들을 위해 의도된 명세는 이 속성(attribute)들이 의미있는 값을 가지도록 정의하지
    않아야(must) 합니다.
  </div>

  자바스크립트 라이브러리들은 그것들이 사용 되는 페이지의 일부로 간주되기 때문에
  <a lt="custom data attributes">커스텀 데이터 속성(attribute)들</a>을 사용할 수 있습니다. 많은
  작성자들에 의해 재사용되는 라이브러리의 작성자는 충돌 위험을 줄이기 위해 속성(attribute) 이름에
  그들의 이름을 포함하도록 권장됩니다. 그것이 말이 된다면, 라이브러리 작성자는 또한 정확한 이름이
  커스텀 가능한 속성(attribute) 이름으로 사용되도록 권장되기 때문에, 모르고 동일한 이름을 고른 
  작성자의 라이브러리가 같은 페이지에 사용될 수 있고, 특정 라이브러리의 여러 버전이, 그 버전이 서로 
  호환이 되지 않는 경우에서 조차 동일한 페이지에서 사용 될 수 있습니다.

  <div class="example">
    예를 들어, "DoQuery"라 불리는 라이브러리는 <code>data-doquery-range</code>와 같은 속성(attribute) 
    이름을 사용할 수 있고, "jJo"라 불리는 라이브러리는 <code>data-jjo-range</code>와 같은 속성(attribute) 
    이름을 사용할 수 있습니다. jJo 라이브러리는 사용할 접두어를 설정하기 위한 API를 제공 할 수도
    있습니다 (예를 들어, <code>data-j2-range</code>와 같은 이름을 가진 속성(attribute)을 만드는
    <code>J.setDataPrefix("j2")</code>).
  </div>

<h4 id="requirements-relating-to-the-bidirectional-algorithm">
  양방향 알고리즘에 관한 요구사항
</h4>

<h5 id="authoring-conformance-criteria-for-bidirectional-algorithm-formatting-characters">
  양방향 알고리즘 서식 문자에 대한 작성 적합성 기준
</h5>

  <a lt='html-contents'>콘텐츠</a>에 <code>Text</code> 노드들이 있는 
  <a lt="html elements">html 요소(element)들</a>의 <a lt="Text content">텍스트 콘텐트</a>와 자유 
  형식 텍스트를 허용하는 <a lt="html elements">html 요소(element)들</a>의 속성(attribute)의 텍스트는 
  U+202A부터 U+202E까지 그리고 U+2066부터 U+2069까지 범위의 문자들을 (양방향 알고리즘 서식 문자들) 
  포함할 수 있습니다. 하지만, 이 문자들의 사용은 이 문자들에 의해 생성된 모든 삽입 혹은 재정의들이 
  다른 부모 요소(element)로 시작하고 끝나지 않도록 제한되기 때문에, 모든 그러한 삽입과 재정의들은 
  명시적으로 U+202C POP 방향성 형식 문자로 끝납니다. 이것은 양방향 알고리즘에 예기치 않은 영향을 
  가지는 방법으로 재사용되는 텍스트의 발생을 줄일 수 있습니다. [[!BIDI]]

  앞서 언급된 제한사항들은 문서의 특정 부분이 
  <a lt="bidirectional-algorithm formatting character ranges">양방향 알고리즘 서식 문자 범위들</a>을 
  구성하는 것을 명시하는 것에 의해 정의되고, 그러한 범위에 요구사항을 도입하고 있습니다.

  다음 알고리즘을 <a lt="HTML element">HTML 요소(element)</a> <var>element</var>에 적용한 결과 문자열은
  <a lt="bidirectional-algorithm formatting character ranges">양방향 알고리즘 서식 문자 범위들</a> 입니다:

  1. <var>output</var>을 문자열의 빈 목록으로 둡니다.
  2. <var>string</var>을 빈 문자열로 둡니다.
  3. <var>node</var>를 <var>element</var>의 첫 번째 자식 노드가 있다면 그것으로, 그렇지 않으면 null로 둡니다.
  4. <i>Loop</i>: <var>node</var>가 null이라면, <i>end</i>로 라벨링 된 단계로 건너뜁니다.
  5. 다음 목록에 처음 매칭되는 단계에 따라 <var>node</var>를 처리합니다:

      <dl class="switch">
        <dt><var>node</var>가 <code>Text</code> 노드라면</dt>
        <dd><var>node</var>의 텍스트 데이터를 <var>string</var>에 추가(append)합니다.</dd>

        <dt><var>node</var>가 <{br}> 요소(element)라면</dt>
        <dt>
          <var>node</var>가 <a lt="flow content">흐름 콘텐트</a>이고 
          <a lt="phrasing content">어구 콘텐트</a>는 아닌 <a lt="HTML element">HTML 요소(element)</a>라면
        </dt>
        <dd>
          <var>string</var>이 빈 문자열이 아니라면, <var>output</var>에 <var>string</var>을 넣고(push)
          <var>string</var>를 빈 문자열로 둡니다.
        </dd>

        <dt>그렇지 않으면</dt>
        <dd>아무 것도 하지 않습니다.</dd>
      </dl>
  6. <var>node</var>를 <var>node</var>의 다음 형제가 있다면 그것으로, 그렇지 않으면 null로 둡니다.
  7. <i>loop</i>로 라벨링 된 단계로 건너 뜁니다.
  8. <i>End</i>: <var>string</var>이 빈 문자열이 아니라면, <var>output</var>에 <var>string</var>를
      넣습니다(push).
  9. <a lt="bidirectional-algorithm formatting character ranges">양방향 알고리즘 서식 문자 범위들</a>로서
      <var>output</var>를 반환합니다.

  <a lt="HTML element">HTML 요소(element)</a>의 네임스페이스 없는 속성(attribute)의 값은 
  <a lt="bidirectional-algorithm formatting character range">양방향 알고리즘 서식 문자 범위</a>입니다.

  위에 설명된 대로, 
  <dfn lt="bidirectional-algorithm formatting character ranges">양방향 알고리즘 서식 문자 범위</dfn>인
  모든 문자열은 다음 유니코드인 문자 세트인 ABNF의 <code>string</code> 문자열과 일치해야(must) 합니다. [[!ABNF]]

  <pre data-highlight="abnf">
    string        = *( plaintext ( embedding / override / isolation ) ) plaintext
    embedding     = ( lre / rle ) string pdf
    override      = ( lro / rlo ) string pdf
    isolation     = ( lri / rli / fsi ) string pdi
    lre           = %x202A ; U+202A LEFT-TO-RIGHT EMBEDDING
    rle           = %x202B ; U+202B RIGHT-TO-LEFT EMBEDDING
    lro           = %x202D ; U+202D LEFT-TO-RIGHT OVERRIDE
    rlo           = %x202E ; U+202E RIGHT-TO-LEFT OVERRIDE
    pdf           = %x202C ; U+202C POP DIRECTIONAL FORMATTING
    lri           = %x2066 ; U+2066 LEFT-TO-RIGHT ISOLATE
    rli           = %x2067 ; U+2067 RIGHT-TO-LEFT ISOLATE
    fsi           = %x2068 ; U+2068 FIRST STRONG ISOLATE
    pdi           = %x2069 ; U+2069 POP DIRECTIONAL ISOLATE
    plaintext     = *( %x0000-2029 / %x202F-2065 / %x206A-10FFFF )
                    ; 양방향 서식 문자가 없는 모든 문자열
  </pre>

  <p class="note">
    U+2069 POP 방향성 구분 문자가 열린 삽입과 재정의를 암묵적으로 종료하는데 반해, 이 암묵적 범위
    클로저에 의존하는 텍스트는 이 명세에 적합하지 않습니다. 이 섹션의 요구사항에 따르기 위해 삽입, 
    재정의, 구분의 모든 문자열은 암묵적으로 종료될 필요가 있습니다.
  </p>

  <p class="note">
    작성자는 양방향 알고리즘 서식 문자를 수동으로 관리하는 것 보다 <code>dir</code> 속성(attribute), 
    <{bdo}> 요소(element), <{bdi}> 요소(<{bdi}>)를 사용하도록 권장됩니다. 양방향 알고리즘 서식 문자는
    CSS와 충분히 상호작용 하지 않습니다.
</p>

  <div class="impl">
    <h5 id="user-agent-conformance-criteria">유저 에이전트 적합 기준</h5>

    유저 에이전트들은 문서와 문서의 일부를 렌더링 할 때 문자의 적절한 순서를 결정하기 위해 유니코드 
    양방향성 알고리즘을 구현해야 합니다. [[!BIDI]]

    HTML의 유니코드 양방향 알고리즘으로의 매핑은 3가지 방법 중 하나로 수행 되어야(must) 합니다. 유저 
    에이전트는 특별한 CSS 'unicode-bidi', 'direction', 'content' 속성(property)들을 사용하여 CSS를
    구현해야(must) 하고 그것의 유저 에이전트 스타일 시트에 이 명세의 [[#rendering]] 섹션에 주어진 그
    속성(property)들을 사용하는 규칙을 가져야(must) 하거나, 혹은 그 대신에, 유저 에이전트는 앞서 언급된
    속성(property)들이 구현되고 모든 앞서 언급된 규칙들을 포함하는 유저 에이전트 스타일 시트를 가지면서
    문서에 명시된 스타일 시트가 그것들을 재정의 하도록 두지 않는 것 처럼 동작해야(must) 하거나, 혹은
    그 대신에, 유저 에이전트는 동등한 의미(semantics)를 가진 다른 스타일링 언어를 구현해야(must) 합니다.
    [[CSS-WRITING-MODES-3]] [[CSS3-CONTENT]]    

    <p id="bidireq">
      다음 요소(element)들과 속성(attribute)들은 [[#rendering]] 섹션에 의해 정의된, 이 섹션의 요구사항
      때문에 모든 유저 에이전트들에 대한 요구사항인 
      (<a lt="support the suggested default rendering">제안된 기본 렌더링을 지원</a>하는 것뿐 
      아니라), 요구사항을 가집니다:
    </p>

    * <{global/dir}> 속성(attribute)
    * <{bdi}> 요소(element)
    * <{bdo}> 요소(element)
    * <{br}> 요소(element)
    * <{pre}> 요소(element)
    * <{textarea}> 요소(element)
    * <{wbr}> 요소(element)
  </div>

  <section>
  <h4 id="wai-aria">WAI-ARIA와 HTML 접근성 API 매핑</h4>
  <section>
  <h5 id='aria-authoring-requirements'>ARIA 작성 요구사항들</h5>
  작성자는 <a lt="HTML elements">HTML 요소(element)들</a>에 ARIA in HTML [[!html-aria]]에 명시된
  요구사항과 충돌하는 것들을 제외하고 ARIA 명세에 기술된 요구사항에 부합되게 ARIA <code>role</code>과
  <code>aria-*</code> 속성(attribute)을 사용할 수 있습니다. 이 예외 사항들은 보조 기술 제품이 문서의
  실제 상태를 나타내지 않는 무의미한 상태를 보고하는 것으로부터 작성자를 방지하기 위한 것입니다.
  [[!WAI-ARIA]]

 <p class="note" id="aria-usage-note">
   <dfn lt="do not set"></dfn> 대부분의 경우에 기본 암묵적 ARIA 의미(semantics)에 일치하는 ARIA 
   <code>role</code>과/혹은 <code>aria-*</code> 속성(attribute)을 설정하는 것은 불필요하고 이 
   속성(property)들은 이미 브라우저에 의해 설정되어 있기 때문에 권장되지 않습니다.
 </p>

  <div class="note">
    <p>작성자들은 이 섹션에 제공된 것 이상으로 ARIA in HTML 사용에 대한 지침을 위해 다음 문서의
  사용이 권장됩니다:</p>
    <ul>
      <li><a href="https://w3c.github.io/aria-in-html/">Notes on Using ARIA in HTML</a> - 접근  
    가능한 리치 인터넷 어플리케이션 명세를 사용하여 HTML 요소(element)들에 접근성 정보를 추가하는  
    방법에 대한 개발자를 위한 실질적인 지침 [[!WAI-ARIA]].</li>
      <li><a href="https://w3c.github.io/aria/practices/aria-practices.html">WAI-ARIA 1.1 Authoring Practices</a> -
    접근 가능한 리치 인터넷 어플리케이션을 이해하고 구현하기 위한 작성자의 지침.</li>
    </ul>
  </div>
  </section>
  <section class="impl">
   <h5 id='aria-conformance-requirements'>적합성 검사기 구현 요구사항들</h5>
  <p>적합성 검사기는 ARIA in HTML에 정의된 대로 <a lt="HTML elements">HTML 요소(element)들</a>에
  ARIA <code>role</code>과 <code>aria-*</code> 속성(attribute)들의 사용에 대한 문서 적합성
  요구사항을 구현하도록 요구됩니다. [[!html-aria]] </p>
  </section>
  <section class="impl">
  <h5 id='user-agent-requirements'>유저 에이전트 구현 요구사항들</h5>
  <div>
    <p>유저 에어전트들은 ARAI 명세 [[!WAI-ARIA]]와
  <a href="https://w3c.github.io/aria/core-aam/core-aam.html">[core-aam-1.1]</a>에 정의된 대로,
  모든 <a lt="HTML elements">HTML 요소(element)들</a>에 ARIA 의미론을 구현하도록 요구됩니다. </p>
    <p>유저 에어전트들은 HTML 접근성 API 매핑 명세
  <a href="https://w3c.github.io/aria/html-aam/html-aam.html">[html-aam-1.0]</a>에 정의된 대로,
  모든 <a lt="HTML elements">HTML 요소(element)들</a>에 접근성 API 의미론을 구현하도록 요구됩니다.</p>
    <p>ARIA 명세에 정의된 ARIA 속성(attribute)들은 CSS 가상 클래스 매칭이나, 보조 기술을 사용하지 
  않는 유저 인터페이스 양상이나, 이 명세어 정의된 유저 인터랙션 이벤트의 기본 동작에 어떠한 
  영향도 가지지 않습니다.</p>
  </div>
  <section>
  <h6 id="aria-role-attribute">ARIA 역할(Role) 속성(Attribute)</h6>
  모든 HTML 요소(element)는 명시된 ARIA <code>role</code> 속성(attribute)을 가질 수 있습니다.
  이것은 [[!WAI-ARIA]]에 의해 정의된 ARIA 역할(Role) 속성(attribute) 입니다.

  속성(attribute)이 명시되었다면, 공백으로 구분된 토큰의 세트인 값을 가져야(must)합니다;
  각 토큰은 WAI-ARIA 명세 [[!WAI-ARIA]]에 정의된 비 추상 역살(role)이어야(must) 합니다.

  <div class="impl">
    HTML 요소(element)에 할당 된 WAI-ARIA 역할(role)은 <code>role</code> 속성(attribute)이 공백으로
    분리되는 경우 생성된 값의 목록에서 발견 된 첫 번째 비 추상 역할(role) 입니다.
  </div>
  </section>
  <section>
  <h6 id="state-and-property-attributes">상태(State)와 속성(Property) 속성(Attribute)들</h6>
  모든 HTML 요소(element)는 명시된 ARIA 상태(state)와 속성(property) 속성(attribute)들을 가질 수 있습니다.
  이 속성(attribute)들은 [[!WAI-ARIA]]에 의해 정의됩니다.

  ARIA 상태(State)와 속성(Property) 속성(attribute)들의 부분 집합은 [[!WAI-ARIA]] 명세의
  "<dfn lt="global aria-* attributes|global States and properties">범용 상태(State)들과 속성(Property)들</dfn>"로
  정의된 것입니다.

  이 속성(attribute)들이 명시되었다면 [[!WAI-ARIA]]에 따라 적절한 HTML 값 유형에 매핑된, 상태(state)
  혹은 속성(property)에 대한 정의의 "Value" 필드에 있는 ARIA 값 유형인 값을 가져야(must) 합니다.

  ARIA 상태(State)와 속성(Property) 속성(attribute)들은 모든 요소(element)에 사용될 수 있습니다. 
  하지만, 그것들이 항상 의미있는 것은 아니며, 그러한 경우 유저 에어전트들은 DOM에 그것들을 포함하는
  것과 별개로 처리하는 것을 수행하지 않을 수 있습니다. 상태(State)와 속성(Property) 속성(attribute)들은
  [[!WAI-ARIA]] 뿐만 아니라 HTML 접근성 API 매핑 명세 <a href="https://w3c.github.io/aria/html-aam/html-aam.html">[html-aam-1.0]</a>의 
  요구사항, 그리고 ARIA 명세들 [[!WAI-ARIA]]과 <a href="https://w3c.github.io/aria/core-aam/core-aam.html">[core-aam-1.1]</a>에 
  정의된 대로 처리 됩니다.

  </section>
  </section>
</section>
<section>
 <h5 id="allowed-aria-roles-states-and-properties">허용된 ARIA 역할(role)들, 상태(state)들, 속성(property)들</h5>

  <em>이 섹션은 비 규범적입니다.</em>

  <p class="note">
    다음 표는 HTML에 사용에 대해 허용된 ARIA 역할(role)들, 상태(state)들, 속성(property)들에 대한 
    유용한 참고 사항을 제공합니다. 모든 ARIA 역할(role)들, 상태(state)들, 속성(property)들은 
    규범적으로 [[!WAI-ARIA]] 명세에 정의됩니다. 표의 ARIA 역할(role)들, 상태(state)들, 속성(property)들에
    대한 링크는 규범적인 [[!WAI-ARIA]] 정의를 참조합니다.
  </p>

 <table>
    <caption>
      <abbr title="Accessible Rich Internet Applications">ARIA</abbr> 역할(role)들, 상태(state)들, 속성(property)들
    </caption>
    <thead>
      <tr>
        <th>역할(role)</th>
        <th>설명</th>
        <th>요구되는 속성(property)들</th>
        <th>지원되는 속성(property)들</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>any</td>
        <td>ARIA <a lt="global states and properties">범용 상태(state)들과 속성(property)들</a>은 모든 HTML 요소(element)에 사용될 수 있습니다.</td>
        <td>없음</td>
        <td>

          * <code>aria-atomic</code>
          * <code>aria-busy (state)</code>
          * <code>aria-controls</code>
          * <code>aria-describedby</code>
          * <code>aria-disabled (state)</code>
          * <code>aria-dropeffect</code>
          * <code>aria-flowto</code>
          * <code>aria-grabbed (state)</code>
          * <code>aria-haspopup</code>
          * <code>aria-hidden (state)</code>
          * <code>aria-invalid (state)</code>
          * <code>aria-label</code>
          * <code>aria-labelledby</code>
          * <code>aria-live</code>
          * <code>aria-owns</code>
          * <code>aria-relevant</code>

        </td>
      </tr>
      <tr>
        <td><code>alert</code></td>
        <td>
          중요한 메세지, 그리고 대개 시간에 민감한 정보. 관련된 <code>alertdialog</code>와
          <code>status</code>를 참고하세요.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>alertdialog</code></td>
        <td>
          초기 초점이 대화상자 안의 요소(element)에 가는, 경고 메세지를 포함하는 대화상자 유형.
          관련된 <code>alert</code>과 <code>dialog</code>를 참고하세요.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>application</code></td>
        <td>웹 문서와 다른, 웹 어플리케이션으로 선언된 영역</td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>article</code></td>
        <td>
          문서, 페이지, 사이트의 독립적인 부분을 구성하는 구성 요소로 구성된 페이지의 섹션.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>banner</code></td>
        <td>
          페이지에 한정된 콘텐트 보다는 대부분 사이트 지향적인 콘텐트를 포함하는 영역.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>button</code></td>
        <td>
          클릭되거나 눌려질 경우 사용자 발생 동작을 허용하는 입력. 관련된 <code>link</code>를 
          참고하세요.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>
          * <code>aria-pressed (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>checkbox</code></td>
        <td>세 가지 가능한 값을 가지는 체크 가능한 입력: true, false, 혹은 mixed.</td>
        <td>

          * <code>aria-checked (state)</code>

        </td>
        <td></td>
      </tr>
      <tr>
        <td><code>columnheader</code></td>
        <td>컬럼에 대한 제목(header) 정보를 포함하는 셀.</td>
        <td>없음</td>
        <td>

          * <code>aria-sort</code>
          * <code>aria-readonly</code>
          * <code>aria-required</code>
          * <code>aria-selected (state)</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>combobox</code></td>
        <td>
          선택의 표현; 일반적으로 사용자가 옵션을 선택하기 위해 앞서 타이핑 할 수 있는 텍스트 상자와 
          유사하거나, 혹은 목록 내 새로운 항목으로 임의의 텍스트를 입력하기 위한 유형. 관련된
          <code>listbox</code>를 참고하세요.
        </td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
        <td>

          * <code>aria-autocomplete</code>
          * <code>aria-required</code>
          * <code>aria-activedescendant</code>

        </td>
      </tr>
      <tr>
        <td><code>complementary</code></td>
        <td>
          DOM 계층에서 비슷한 수준에 있는 주 콘텐트를 보완하도록 설계되고, 주 콘텐트와 분리되는 
          경우에도 여전히 의미가 있는, 문서의 지원 섹션.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>contentinfo</code></td>
        <td>부모 문서에 대한 정보를 포함하는 인식 가능한 큰 영역.</td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>definition</code></td>
        <td>용어나 개념의 정의.</td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>dialog</code></td>
        <td>
          대화상자는 사용자가 정보를 입력하거나 응답할 것을 요구하도록 유도하기 위해 어플리케이션의
          현재 처리를 중단시키도록 설계된 어플리케이션 윈도우 입니다. 관련된 <code>alertdialog</code>를 
          참고하세요.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>directory</code></td>
        <td>콘텐트의 정적 테이블과 같은, 그룹의 멤버들에 대한 참조 목록.</td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>document</code></td>
        <td>
          웹 어플리케이션과 다른, 문서 콘텐트로서 선언된 연관된 정보를 포함하는 영역.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>form</code></td>
        <td>
          전체적으로 양식을 생성하기 위해 결합하는 항목들과 객체들의 컬렉션을 포함하는 랜드마크(landmark) 
          영역. 관련된 <code>search</code>를 참고하세요.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>grid</code></td>
        <td>
          그리드는 표 처럼, 행과 열로 배치되는 표로 나타낸 데이터의 칸들을 포함하는 
          대화형(interactive) 컨트롤 입니다.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-level</code>
          * <code>aria-multiselectable</code>
          * <code>aria-readonly</code>
          * <code>aria-activedescendant</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>gridcell</code></td>
        <td>grid나 treegrid에 있는 칸.</td>
        <td>없음</td>
        <td>

          * <code>aria-readonly</code>
          * <code>aria-required</code>
          * <code>aria-selected (state)</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>group</code></td>
        <td>
          보조 기술에 의해 페이지 요약이나 콘텐트 목차에 포함되도록 의도되지 않은 사용자 인터페이스
          객체의 집합
        </td>
        <td>없음</td>
        <td>

          * <code>aria-activedescendant</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>heading</code></td>
        <td>페이지의 섹션에 대한 제목(heading)</td>
        <td>없음</td>
        <td>

          * <code>aria-level</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>img</code></td>
        <td>이미지를 구성하는 요소(element)의 컬렉션에 대한 컨테이너.</td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>link</code></td>
        <td>
          내부 혹은 외부 리소스가 활성화 될 때 유저 에이전트가 그 리소스를 탐색하도록 하는 내부 혹은 
          외부 리소스에 대한 대화형(interactive) 참조. 관련된 <code>button</code>을 참고하세요.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>list</code></td>
        <td>
          비 대화형(non-interactive) 목록 항목들의 그룹. 관련된 <code>listbox</code>를 참고하세요.</td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

          </td>
      </tr>
      <tr>
        <td><code>listbox</code></td>
        <td>
          사용자가 선택 목록으로부터 하나 이상의 항목을 선택하도록 허용하는 위젯. 관련된
          <code>combobox</code>와 <code>list</code>를 참고하세요.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-multiselectable</code>
          * <code>aria-required</code>
          * <code>aria-expanded (state)</code>
          * <code>aria-activedescendant</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>listitem</code></td>
        <td><code>list</code>나 <code>directory</code>의 단일 항목.</td>
        <td>없음</td>
        <td>

          * <code>aria-level</code>
          * <code>aria-posinset</code>
          * <code>aria-setsize</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>log</code></td>
        <td>
          새로운 정보가 의미있는 순서로 추가되고 오래된 정보가 사라질 수 있는 라이브 영역의 유형.
          관련된 <code>marquee</code>를 참고하세요.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>main</code></td>
        <td>문서의 주요 콘텐트.</td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>marquee</code></td>
        <td>
          중요하지 않은 정보가 자주 변경되는 라이브 영역의 유형. 관련된 <code>log</code>를 참고하세요.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>math</code></td>
        <td>수학적 표현을 나타내는 콘텐트. </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>menu</code></td>
        <td>사용자에게 선택 목록을 제공하는 위젯 유형.</td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>
          * <code>aria-activedescendant</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>menubar</code></td>
        <td>
          대개 보이는 상태로 유지되고 대개 가로로 표현되는 메뉴의 표현.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>
          * <code>aria-activedescendant</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>menuitem</code></td>
        <td>
          <code>menu</code>나 <code>menubar</code>에 의해 포함되는 선택 그룹의 옵션.
        </td>
        <td>없음</td>
        <td></td>
      </tr>
      <tr>
        <td><code>menuitemcheckbox</code></td>
        <td>3가지 가능한 값을 가지는 체크 가능한 menuitem: true, false, 혹은 mixed.</td>
        <td>

          * <code>aria-checked (state)</code>

        </td>
        <td></td>
      </tr>
      <tr>
        <td><code>menuitemradio</code></td>
        <td>
          한 번에 하나만 체크될 수 있는, <code>menuitemradio</code> 역할(role)들의 그룹에 있는 체크
          가능한 menuitem
        </td>
        <td>

          * <code>aria-checked (state)</code>

        </td>
        <td>

          * <code>aria-posinset</code>
          * <code>aria-selected (state)</code>
          * <code>aria-setsize</code>

        </td>
      </tr>
      <tr>
        <td><code>navigation</code></td>
        <td>
          문서를 탐색하거나 문서에 관련된 탐색 요소(대개 링크들)의 컬렉션.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

          </td>
      </tr>
      <tr>
        <td><code>note</code></td>
        <td>
          콘텐트가 설명적이거나 리소스의 주요 콘텐트에 보조적인 섹션.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>option</code></td>
        <td>선택 목록 내 선택 가능한 항목.</td>
        <td>없음</td>
        <td>

          * <code>aria-checked (state)</code>
          * <code>aria-posinset</code>
          * <code>aria-selected (state)</code>
          * <code>aria-setsize</code>

        </td>
      </tr>
      <tr>
        <td><code>presentation</code></td>
        <td>
          암묵적 네이티브 역할(role) 의미(semantics)가 접근성 API에 매핑되지 않는 요소(element)
        </td>
        <td>없음</td>
        <td></td>
      </tr>
      <tr>
        <td><code>progressbar</code></td>
        <td>오랜 시간이 걸리는 작업에 대한 진행 상태를 표시하는 요소(element).</td>
        <td>없음</td>
        <td>

          * <code>aria-valuemax</code>
          * <code>aria-valuemin</code>
          * <code>aria-valuenow</code>
          * <code>aria-valuetext</code>

        </td>
      </tr>
      <tr>
        <td><code>radio</code></td>
        <td>
          한 번에 하나만 체크 될 수 있는, radio 역할(role)들의 그룹의 체크 가능한 입력.
        </td>
        <td>

          * <code>aria-checked (state)</code>

        </td>
        <td>

          * <code>aria-posinset</code>
          * <code>aria-selected (state)</code>
          * <code>aria-setsize</code>

        </td>
      </tr>
      <tr>
        <td><code>radiogroup</code></td>
        <td>라디오 버튼들의 그룹.</td>
        <td>없음</td>
        <td>

          * <code>aria-required</code>
          * <code>aria-activedescendant</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>region</code></td>
        <td>
          작성자가 페이지 요약이나 콘텐트 목록에 포함되기에 충분히 중요하다고 느끼는, 예를 들어, 
          라이브 스포츠 경기 이벤트 통계를 포함하는 페이지의 영역, 웹 페이지나 문서의 큰 인식 가능한 
          섹션.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>row</code></td>
        <td>grid에 있는 칸의 행.</td>
        <td>없음</td>
        <td>

          * <code>aria-level</code>
          * <code>aria-selected (state)</code>
          * <code>aria-activedescendant</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>rowgroup</code></td>
        <td>grid에 있는 하나 이상의 행 요소(element)를 포함하는 그룹.</td>
        <td>없음</td>
        <td>

          * <code>aria-activedescendant</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>rowheader</code></td>
        <td>grid에 있는 행에 대한 제목(header) 정보를 포함하는 칸.</td>
        <td>없음</td>
        <td>

          * <code>aria-sort</code>
          * <code>aria-readonly</code>
          * <code>aria-required</code>
          * <code>aria-selected (state)</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>scrollbar</code></td>
        <td>
          콘텐트가 뷰 영역에 꽉 차게 보이는지에 관계 없이, 뷰 영역에 있는 콘텐트의 스크롤을 제어하는 
          그래픽 객체.
        </td>
        <td>

          * <code>aria-controls</code>
          * <code>aria-orientation</code>
          * <code>aria-valuemax</code>
          * <code>aria-valuemin</code>
          * <code>aria-valuenow</code>

        </td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>search</code></td>
        <td>
          전체적으로 검색 기능을 생성하기 위해 결합하는 항목들과 객체들의 컬렉션을 포함하는 
          랜드마크(landmark) 영역. 관련된 <code>form</code>를 참고하세요.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>
          * <code>aria-orientation</code>

        </td>
      </tr>
      <tr>
        <td><code>separator</code></td>
        <td>
          콘텐트의 섹션이나 메뉴항목들의 그룹을 분리하고 구별하는 구분자.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-valuetext</code>

        </td>
      </tr>
      <tr>
        <td><code>slider</code></td>
        <td>주어진 범위에서 사용자가 값을 선택하는 사용자 입력.</td>
        <td>

          * <code>aria-valuemax</code>
          * <code>aria-valuemin</code>
          * <code>aria-valuenow</code>

        </td>
        <td>

          * <code>aria-orientation</code>
          * <code>aria-valuetext</code>

        </td>
      </tr>
      <tr>
        <td><code>spinbutton</code></td>
        <td>사용자가 이산 선택 중에서 선택할 것이라고 예상하는 범위의 형식.</td>
        <td>

          * <code>aria-valuemax</code>
          * <code>aria-valuemin</code>
          * <code>aria-valuenow</code>

        </td>
        <td>

          * <code>aria-required</code>
          * <code>aria-valuetext</code>

        </td>
      </tr>
      <tr>
        <td><code>status</code></td>
        <td>
          종종 상태 표시줄로 필연적으로 표시되지 않는, 콘텐트가 사용자를 위한 조언 정보이지만 경고를
          합리화 할 만큼 중요하지 않은 컨테이너. 관련된 <code>alert</code>를 참고하세요.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>tab</code></td>
        <td>
          사용자에게 렌더링 될 수 있는 탭 콘텐트를 선택하기 위한 메커니즘을 제공하는 그루핑 레이블.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-selected (state)</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>tablist</code></td>
        <td>탭 패널 요소(element)를 참조하는 탭 요소(element)의 목록.</td>
        <td>없음</td>
        <td>

          * <code>aria-level</code>
          * <code>aria-activedescendant</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>tabpanel</code></td>
        <td>
          각 <code>tab</code>이 <code>tablist</code>에 포함 된 <code>tab</code>과 연관된 리소스에 
          대한 컨테이너.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>textbox</code></td>
        <td>값으로 자유 형식 텍스트를 허용하는 입력.</td>
        <td>없음</td>
        <td>

          * <code>aria-activedescendant</code>
          * <code>aria-autocomplete</code>
          * <code>aria-multiline</code>
          * <code>aria-readonly</code>
          * <code>aria-required</code>

        </td>
      </tr>
      <tr>
        <td><code>timer</code></td>
        <td>
          시작점으로부터 지나간 시간의 양이나 종료점까지 남은 시간을 나타내는 숫자 카운터를 포함하는 
          라이브 영역의 유형.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>toolbar</code></td>
        <td>소형 시각적 양식으로 표현 된 이란저그올 사용되는 기능 버튼의 컬렉션.</td>
        <td>없음</td>
        <td>

          * <code>aria-activedescendant</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>tooltip</code></td>
        <td>요소(element)에 대한 설명을 나타내는 문맥상의 팝업.</td>
        <td>없음</td>
        <td>

          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>tree</code></td>
        <td>
          접히고 확장될 수 있는 중첩된 그룹 하위 수준을 포함할 수 있는 목록의 유형.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-multiselectable</code>
          * <code>aria-required</code>
          * <code>aria-activedescendant</code>
          * <code>aria-expanded (state)</code>

        </td>
      </tr>
      <tr>
        <td><code>treegrid</code></td>
        <td>tree에 대한 것과 동일한 방법으로 확장되고 접힐 수 있는 행의 grid</td>
        <td>없음</td>
        <td>

          * <code>aria-level</code>
          * <code>aria-multiselectable</code>
          * <code>aria-readonly</code>
          * <code>aria-activedescendant</code>
          * <code>aria-expanded (state)</code>
          * <code>aria-required</code>

        </td>
      </tr>
      <tr>
        <td><code>treeitem</code></td>
        <td>
          tree의 선택 항목. 이것은 treeitem들의 하위 수준 그룹을 포함한다면, 확장되거나 접힐 수 있는 
          tree 안의 요소(element)입니다.
        </td>
        <td>없음</td>
        <td>

          * <code>aria-level</code>
          * <code>aria-posinset</code>
          * <code>aria-setsize</code>
          * <code>aria-expanded (state)</code>
          * <code>aria-checked (state)</code>
          * <code>aria-selected (state)</code>

        </td>
      </tr>
    </tbody>
  </table>

</section>
