<section>

<h3 id="document-metadata">문서 메타데이터</h3>

<h4 id="the-head-element"><dfn element><code>head</code></dfn> 요소(element)</h4>

  <dl class="element">
    <dt><a lt="Categories">카테고리</a>:</dt>
    <dd>없음.</dd>
    <dt><a lt="Contexts in which this element can be used">이 요소(element)가 사용될 수 있는 컨텍스트</a>:</dt>
    <dd><{html}> 요소(element) 내 첫 번째 요소(element).</dd>
    <dt><a lt="Content model">콘텐트 모델</a>:</dt>
    <dd>
      문서가 <a lt="iframe srcdoc document"><code>iframe</code> <code>srcdoc</code> 문서</a>이거나 
      제목(title) 정보가 상위 프로토콜에서 사용 가능하다면: <a element for="html"><code>title</code></a> 
      요소(element)가 한 개를 초과하지 않고 <{base}> 요소(element)가 한 개를 초과하지 않는, 
      <a lt="metadata content">메타데이터 콘텐트</a>의 0개 이상의 요소(element).
    </dd>
    <dd>
      그렇지 않으면: 정확히 하나가 <a element for="html"><code>title</code></a> 요소(element)와
      <{base}> 요소(element)가 한 개를 초과하지 않는, <a lt="metadata content">메타데이터 콘텐트</a>의 
      한 개 이상의 요소(element).
    </dd>
    <dt><a lt="Tag omission in text/html">text/html에서 태그 생략</a>:</dt>
    <dd>
      <{head}> 요소(element)의 <a lt="start tag">시작 태그</a>는 요소(element)가 비어있거나 <{head}>
      요소(element) 내의 첫 번째 것이 요소(element)라면 생략될 수 있습니다.
    </dd>
    <dd>
      <{head}> 요소(element)의 <a lt="end tag">종료 태그</a>는 <{head}> 요소(element)에 <a lt="space character">공백 문자</a>나
      <a lt="comment">주석</a>이 즉시 따르지 않는다면 생략될 수 있습니다.
    </dd>
    <dt><a lt="Content attributes">콘텐트 속성(attribute)들</a>:</dt>
    <dd><a lt="Global attributes">범용 속성(attribute)들</a></dd>
    <dt>허용된 <a href="#aria-role-attribute">ARIA 역할(role) 속성(attribute)</a> 값들:</dt>
    <dd>없음</dd>
    <dt>허용된 <a href="#state-and-property-attributes">ARIA 상태(state)와 속성(property) 속성(attribute)들</a>:</dt>
    <dd><a lt="Global aria-* attributes">범용 aria-* 속성(attribute)들</a></dd>
    <dt><a lt="DOM interface">DOM 인터페이스</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl" dfn-for="HTMLHeadElement">
        interface HTMLHeadElement : HTMLElement {};
      </pre>
    </dd>
  </dl>

  <{head}> 요소(element)는 {{Document}}에 대한 메타데이터의 컬렉션을 <a lt="represents">나타냅니다</a>.

  <div class="example">
    <{head}> 요소(element) 내 메타데이터의 컬렉션은 많거나 적을 수 있습니다. 여기 매우 짧은 것의 
    예가 있습니다:

    <pre highlight="html">
      &lt;!doctype html>
      &lt;html>
        &lt;head>
          &lt;title>A document with a short head&lt;/title>
        &lt;/head>
        &lt;body>
          ...
    </pre>

    여기 긴 것의 예가 있습니다:

    <pre highlight="html">
      &lt;!DOCTYPE HTML>
        &lt;HTML>
        &lt;HEAD>
          &lt;META CHARSET="UTF-8">
          &lt;BASE HREF="https://www.example.com/">
          &lt;TITLE>An application with a long head&lt;/TITLE>
          &lt;LINK REL="STYLESHEET" HREF="default.css">
          &lt;LINK REL="STYLESHEET ALTERNATE" HREF="big.css" TITLE="Big Text">
          &lt;SCRIPT SRC="support.js">&lt;/SCRIPT>
          &lt;META NAME="APPLICATION-NAME" CONTENT="Long headed application">
        &lt;/HEAD>
        &lt;BODY>
          ...
    </pre>
  </div>

  <p class="note">
    <a element for="html"><code>title</code></a> 요소(element)는 대부분 상황에서 요구된 자식이지만, 
    상위 레벨 프로토콜이 제목(title) 정보를 제공하는 경우, 예를 들어 HTML이 이메일 작성 서식으로 
    사용되는 경우 이메일의 제목 줄에, <a element for="html"><code>title</code></a> 요소(element)는
    생략 될 수 있습니다.
  </p>

  <p class="note">
    처음 1024바이트 내에서 <a lt="character encoding declaration">문자 인코딩 선언</a>의 적절한 감지를
    허용하기 위해 <{head}> 요소(element)에 정의된 속성(attribute)들과 그 값들의 사용을 최소한으로
    유지하는 것이 권장됩니다.
  </p>

<h4 id="the-title-element"><dfn element><code>title</code></dfn> 요소(element)</h4>

  <dl class="element">
    <dt><a lt="Categories">카테고리</a>:</dt>
    <dd><a lt="Metadata content">메타데이터 콘텐트</a>.</dd>
    <dt><a lt="Contexts in which this element can be used">이 요소(element)가 사용될 수 있는 컨텍스트</a>:</dt>
    <dd>다른 <a element for="html"><code>title</code></a> 요소(element)를 포함하지 않는 <{head}>요소(element) 안.</dd>
    <dt><a lt="Content model">콘텐트 모델</a>:</dt>
    <dd><a lt="inter-element whitespace">요소(element) 간 여백</a>이 아닌 <a lt="Text">텍스트</a>.</dd>
    <dt><a lt="Tag omission in text/html">text/html에서 태그 생략</a>:</dt>
    <dd>어느 태그도 생략 가능하지 않습니다.</dd>
    <dt><a lt="Content attributes">콘텐트 속성(attribute)들</a>:</dt>
    <dd><a lt="Global attributes">범용 속성(attribute)들</a></dd>
    <dt>허용된 <a href="#aria-role-attribute">ARIA 역할(role) 속성(attribute)</a> 값들:</dt>
    <dd>없음</dd>
    <dt>허용된 <a href="#state-and-property-attributes">ARIA 상태(state)와 속성(property) 속성(attribute)들</a></a>:</dt>
    <dd><a lt="Global aria-* attributes">범용 aria-* 속성(attribute)들</a></dd>
    <dt><a lt="DOM interface">DOM 인터페이스</a>:</dt>
    <dd>
      <pre class="idl" data-hightlight="webidl" dfn-for="HTMLTitleElement">
        interface HTMLTitleElement : HTMLElement {
          attribute DOMString text;
        };
      </pre>
    </dd>
  </dl>

  <a element for="html"><code>title</code></a> 요소(element)는 문서의 제목(title)이나 이름을 
  <a lt="represents">나타냅니다</a>. 작성자는 문서가 문맥 밖에서, 예를 들어 사용자의 방문 기록이나 
  북마크에 혹은 검색 결과에 사용될 때 조차도 문서를 알아보게 하는 제목을 사용해야(should) 합니다. 
  문서의 첫 번째 제목(heading)은 문맥에서 벗어날 경우 혼자 있을 필요가 없기 때문에, 문서의 제목(title)은
  종종 문서의 첫 번째 제목(heading)과 다릅니다.

  문서 당 하나의 <a element for="html"><code>title</code></a> 요소(element)만 있어야(must) 합니다.

  <p class="note">
    {{Document}}가 제목을 가지 않는 것이 타당하다면, <code>title</code> 요소(element)는 아마도 요구 
    되지 않습니다. 요소(element)가 요구되는 경우의 설명에 대한 <{head}> 요소(element)의 콘텐트 모델을 
    참고하세요.
  </p>

  <dl class="domintro">
    <dt><var>title</var> . <code>text</code> [ = <var>value</var> ]</dt>
    <dd>
      <code>Text</code> 노드가 아닌 자식 노드들을 무시하여, 요소(element)의 콘텐트를 반환합니다.

      주어진 값으로 요소(element)의 자식을 바꾸기 위해, 설정 될 수 있습니다.
    </dd>
  </dl>

  <div class="impl">
    IDL 속성(attribute) <dfn attribute for="HTMLTitleElement"><code>text</code></dfn>는 
    <a lt="tree order">트리 순서</a>에 따라 <a element for="html"><code>title</code></a> 요소(element)의 
    자식인 (주석이나 요소(element) 같은 다른 노드들은 무시하여) 모든 <code>Text</code> 노드의 콘텐트의 
    연결을 반환해야(must) 합니다. 설정할 때, {{Node/textContent}} IDL 속성(attribute)과 동일한 
    방법으로 동작해야(must) 합니다.
  </div>

  <div class="example">
    여기 최상위 동일한 페이지에 사용될 수 있는 제목(heading)과 대조되는 적절한 제목의 몇 가지 예가 
    있습니다.

    <pre highlight="html">
      &lt;title>Introduction to The Mating Rituals of Bees&lt;/title>
      ...
      &lt;h1>Introduction&lt;/h1>
      &lt;p>This companion guide to the highly successful
      &lt;cite>Introduction to Medieval Bee-Keeping&lt;/cite> book is...
    </pre>

    다음 페이지는 동일한 사이트의 일부입니다. 첫 번째 제목(heading)이 독자가 문맥이 무엇인지 알고
    따라서 춤이 살사인지 알츠인지 궁금해하지 않는다고 가정하면서 제목(title)이 주제를 분명하게 
    설명하는 방법에 주목하세요:

    <pre highlight="html">
      &lt;title>Dances used during bee mating rituals&lt;/title>
      ...
      &lt;h2>The Dances&lt;/h2>
    </pre>
  </div>

  문서의 제목(title)로 사용하기 위한 문자열은 <code>document.title</code> IDL 속성(attribute)에 의해
  주어집니다.

  <div class="impl">
    유저 에이전트는 유저 인터페이스에서 문서로 참조할 때 문서의 제목(title)을 사용해야(should) 합니다.
    <a element for="html"><code>title</code></a> 요소(element)의 콘텐트가 이 방법으로 사용되는 경우,
    그 <a element for="html"><code>title</code></a> 요소(element)의 <a lt="the directionality">방향성</a>은
    유저 인터페이스에서 문서의 제목(title)의 방향성을 설정하는데 사용되어야(should) 합니다.
  </div>

<h4 id="the-base-element"><dfn element><code>base</code></dfn> 요소(element)</h4>

  <dl class="element">
    <dt><a lt="Categories">카테고리</a>:</dt>
    <dd><a lt="Metadata content">메타데이터 콘텐트</a>.</dd>
    <dt><a lt="Contexts in which this element can be used">이 요소(element)가 사용될 수 있는 컨텍스트</a>:</dt>
    <dd>다른 <{base}> 요소(element)들을 포함하지 않는 <{head}> 요소(element) 안.</dd>
    <dt><a lt="Content model">콘텐트 모델</a>:</dt>
    <dd><a lt="Nothing">없음</a>.</dd>
    <dt><a lt="Tag omission in text/html">text/html에서 태그 생략</a>:</dt>
    <dd><a lt="end tag">종료 태그</a> 없음.</dd>
    <dt><a lt="Content attributes">콘텐트 속성(attribute)들</a>:</dt>
    <dd><a lt="Global attributes">범용 속성(attribute)들</a></dd>
    <dd><code>href</code> — <a lt="Document base URL">문서 기본 URL</a></dd>
    <dd>
      <code>target</code> — <a lt="hyperlink">하이퍼링크</a> <a lt="navigation">탐색(navigation)</a>과 
      [[#forms-form-submission]]에 대한 기본 <a lt="browsing context">브라우징 컨텍스트</a>
    </dd>
    <dt>허용된 <a href="#aria-role-attribute">ARIA 역할(role) 속성(attribute)</a> 값들:</dt>
    <dd>없음</dd>
    <dt>허용된 <a href="#state-and-property-attributes">ARIA 상태(state)와 속성(property) 속성(attribute)들</a>:</dt>
    <dd><a lt="Global aria-* attributes">범용 aria-* 속성(attribute)들</a>.</dd>
    <dt><a lt="DOM interface">DOM 인터페이스</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl" dfn-for="HTMLBaseElement">
        interface HTMLBaseElement : HTMLElement {
          attribute DOMString href;
          attribute DOMString target;
        };
      </pre>
    </dd>
  </dl>

  <{base}> 요소(element)는 작성자가 <a lt="parsing relative URLs">상대 URL들 해석</a>의 목적에 대한
  <a lt="document base URL">문서 기본 URL</a>과 <a lt="following hyperlinks">하이퍼링크들을 따라가는 것</a>의
  목적에 대한 기본 <a lt="browsing context">브라우징 컨텍스트</a>의 이름을 명시하는 것을 허용합니다.
  요소(element)는 이 정보를 넘어 어떤 컨텐트도 <a lt="represent">나타내지</a> 않습니다.

  문서 당 하나의 <{base}> 요소(element)만 있어야(must) 합니다.

  <{base}> 요소(element)는 <{base/href}> 속성(attribute)이나 <code>target</code> 속성(attribute), 
  혹은 둘 모두를 가져야(must) 합니다.

  <dfn element-attr for="base"><code>href</code></dfn> 콘텐트 속성(attribute)이 명시되었다면, 이 
  속성(attribute)은 <a lt="valid URL potentially surrounded by spaces">유효한 잠정적으로 공백으로 
  둘러 싸일 수 있는 비어있지 않은 URL</a>을 포함해야(must) 합니다.

  <{base}> 요소(element)가 <{base/href}> 속성(attribute)을 가진다면 <{base}> 요소(element)는 <{html}> 
  요소를 제외하고 <a for="url" lt="URLs">URL들</a>을 취하는 것으로 정의된 속성을 가지는 트리 내의 
  다른 요소들(element) 앞에 와야(must) 합니다.

  <div class="impl">
    <p class="note">
      <{base/href}> 속성(attribute)들을 가진 여러 개의 <{base}> 요소(element)들이 있다면, 첫 번째를
      제외하고 모두 무시됩니다.
    </p>
  </div>

  <dfn element-attr for="base"><code>target</code></dfn> 속성(attribute)가 명시되었다면, 이 속성은 
  {{Document}}의 <a lt="hyperlinks">하이퍼링크</a>들과 <a lt="forms">양식들</a>이 
  <a lt="navigation">탐색(navigation)</a>을 야기하는 경우 어느 
  <a lt="browsing context">브라우징 컨텍스트</a>가 기본으로 사용되는지를 명시하는 
  <a lt="valid browsing context name or keyword">유효한 브라우징 컨텍스트 이름이나 키워드</a>를 
  포함해야(must) 합니다.

  <{base}> 요소(element)가 <code>target</code> 속성(attribute)을 가진다면 <{base}> 요소(element)는 
  elements in the tree that represent <a lt="hyperlinks">하이퍼링크들</a>을 나타내는 트리 내 모든 
  요소(element)들 앞에 와야(must) 합니다.

  <div class="impl">
    <p class="note">
      <code>target</code> 속성(attribute)들을 가진 여러 개의 <{base}> 요소(element)들이 있다면, 첫 번째를
      제외하고 모두 무시됩니다.
    </p>

    특정 {{Document}}의 <{base/href}> 콘텐트 속성(attribute)을 가진 첫 번째 <{base}> 요소(element)인
    <{base}> 요소(element)는 <dfn lt="frozen base URL">고정(frozen) 기본 URL</dfn>을 가집니다.
    <a lt="frozen base URL">고정(frozen) 기본 URL</a>은 다음 상황의 어떤 것이 발생될 때에든지
    요소(element)에 대해 <a lt="immediately">즉시</a> <a lt="set the frozen base URL">설정</a>되어야(must)
    합니다:

    * <{base}> 요소(element)가 그것의 {{Document}}에 <a lt="tree order">트리 순서</a>에 따라
        <{base/href}> 콘텐트 속성(attribute)을 가진 첫 번째 <{base}> 요소(element)가 되는 경우.
    * <{base}> 요소(element)가 그것의 {{Document}}에 <a lt="tree order">트리 순서</a>에 따라 
        <{base/href}> 콘텐트 속성(attribute)을 가진 첫 번째 <{base}> 요소(element)이고, 그것의
        <{base/href}>콘텐트 속성(attribute)이 변경되는 경우.

    요소(element) <var>element</var>에 대해, 
	<dfn lt="set the frozen base URL">고정(frozen) 기본 URL을 설정</dfn>하기 위해:

    1. <var>document</var>를 <var>element</var>의 <a lt="node document">노드 문서</a>로 둡니다.
    2. <var>urlRecord</var>를 <var>element</var>의 <var>document</var>의
        <a lt="fallback base URL">폴백 기본 URL</a>과 <var>document</var>의 
        <a lt="character encoding">문자 인코딩</a>을 가진 <{base/href}> 콘텐트 속성(attribute)의 값을 
        <a lt="parsing">해석</a>한 결과로 둡니다. (따라서 <{base}> 요소(element)는 자신에 의해 영향을 
        받지 않습니다.)
    3. <var>elements</var>의 <a lt="frozen base URL">고정(frozen) 기본 URL</a>을 <var>urlRecord</var>이
        실패하거나 <a lt="resulting URL record">결과 URL 레코드</a>에
        <a lt="Is base allowed for Document?">기본(base)이 문서에 대해 허용되는가?</a>를 실행 중이고
        <var>document</var>가 "<code>Blocked</code>"를 반환한다면 <var>document</var>의
        <a lt="fallback base URL">폴백 기본 URL</a>로 설정하고, 그렇지 않으면 <var>urlRecord</var>로
        설정합니다.

    <dfn attribute for="HTMLBaseElement"><code>href</code></dfn> IDL 속성(attribute)은 가져올 때
    다음 알고리즘을 수행한 결과를 반환해야(must) 합니다:

    1. <var>document</var>를 <var>element</var>의 <a lt="node document">노드 문서</a>로 둡니다.
    2. <var>url</var>을 <{base}> 요소(element)의 <{base/href}> 속성(attribute)의 값을 가진다면
        그 값으로 두고, 그렇지 않으면 빈 문자열로 둡니다.
    3. <var>urlRecord</var>를 <var>url</var>을 <var>document</var>의 
        <a lt="fallback base url">폴백 기본 URL</a>과 <var>document</var>의 
        <a lt="character encoding">문자 인코딩</a>을 가지고 <a lt="parsing">해석</a>한 결과로 둡니다. 
        (따라서, <{base}> 요소(element)는 다른 <{base}> 요소(element)나 자신에 의해서 영향을 받지 
        않습니다.)
    4. <var>urlRecord</var>이 실패라면, <var>url</var>을 반환합니다.
    5. <var>urlRecord</var>의 <a for="url" lt="serialization">직렬화</a>를 반환합니다.

    {{HTMLBaseElement/href}} IDL 속성(attribute)은 설정할 때 <{base/href}> 콘텐트 속성(attribute)을 
    주어진 새로운 값으로 설정해야(must) 합니다.

    <dfn attribute for="HTMLBaseElement"><code>target</code></dfn> IDL 속성(attribute)은 동일한 
    이름의 콘텐트 속성(attribute)을 <a lt="reflect">반영</a>해야(must) 합니다.
  </div>

  <div class="example">
    이 예제에서, <{base}> 요소(element)는 <a lt="document base URL">문서 기본 URL</a>을 설정하는데 
    사용됩니다:

    <pre highlight="html">
      &lt;!DOCTYPE html>
      &lt;html>
        &lt;head>
          &lt;title>This is an example for the &amp;lt;base&amp;gt; element&lt;/title>
          &lt;base href="https://www.example.com/news/index.html">
        &lt;/head>
        &lt;body>
          &lt;p>Visit the &lt;a href="archives.html">archives&lt;/a>.&lt;/p>
        &lt;/body>
      &lt;/html>
    </pre>

    위 예제에서 링크는 "<code>https://www.example.com/news/archives.html</code>"로의 링크가 될 것입니다.
  </div>

<h4 id="the-link-element"><dfn element><code>link</code></dfn> 요소(element)</h4>

  <dl class="element">
    <dt><a lt="Categories">카테고리</a>:</dt>
    <dd><a lt="Metadata content">메타데이터 콘텐트</a>.</dd>
    <dt><a lt="Contexts in which this element can be used">이 요소(element)가 사용될 수 있는 컨텍스트</a>:</dt>
    <dd><a lt="metadata content">메타데이터 콘텐트</a>가 기대되는 곳.</dd>
    <dd><{head}> 요소(element)의 자식인 <{noscript}> 요소(element) 내.</dd>
    <dt><a lt="Content model">콘텐트 모델</a>:</dt>
    <dd><a lt="Nothing">없음</a>.</dd>
    <dt><a lt="Tag omission in text/html">text/html에서 태그 생략</a>:</dt>
    <dd><a lt="end tag">종료 태그</a> 없음.</dd>
    <dt><a lt="Content attributes">콘텐트 속성(attribute)들</a>:</dt>
    <dd><a lt="Global attributes">범용 속성(attribute)들</a></dd>
    <dd><code>href</code> — <a lt="hyperlink">하이퍼링크</a>의 주소</dd>
    <dd><code>crossorigin</code> — 요소(element)가 교차출처(crossorigin) 요청들을 처리하는 방법</dd>
    <dd><{link/rel}> — 이 문서 (또는 하위 섹션/주제)에서 목적지 리소스로의 관계</dd>
    <dd><{link/rev}> — 목적지 리소스에서 이 문서 (또는 하위 섹션/주제)로의 <a lt="Reverse link">역방향 링크</a> 관계</dd>
    <dd><code>media</code> — 적용가능한 매체</dd>
    <dd><code>hreflang</code> — 연결된 리소스의 언어</dd>
    <dd><code>type</code> — 참조된 리소스의 유형에 대한 힌트</dd>
    <dd><code>sizes</code> — 아이콘의 (for <{link/rel}>="<code>icon</code>"에 대한) 크기</dd>
    <dd>
      또한, <{link/title}> 속성(attribute)은 이 요소(elemnt)에 특별한 의미를 가집니다: 링크의 제목(title);
      ; 대체 스타일 시트의 이름을 설정합니다.
    </dd>
    <dt>허용된 <a href="#aria-role-attribute">ARIA 역할(role) 속성(attribute)</a> 값들:</dt>
    <dd><a><code>link</code></a> (기본 값 - <a lt="do not set"><em>설정 하지 마세요</em></a>).</dd>
    <dt>허용된 <a href="#state-and-property-attributes">ARIA 상태(state)와 속성(property) 속성(attribute)들</a>:</dt>
    <dd><a lt="Global aria-* attributes">범용 aria-* 속성(attribute)들</a></dd>
    <dd><a href="#allowed-aria-roles-states-and-properties">허용된 역할(role)들에 적용 가능한</a> 모든 <code>aria-*</code> 속성(attribute)들.</dd>
    <dd><code>role</code> 값에 대한 </dd>
    <dt><a lt="DOM interface">DOM 인터페이스</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl" dfn-for="HTMLLinkElement">
        interface HTMLLinkElement : HTMLElement {
          attribute DOMString href;
          attribute DOMString? crossOrigin;
          attribute DOMString rel;
          attribute DOMString rev;
          [SameObject, PutForwards=value]readonly attribute DOMTokenList relList;
          attribute DOMString media;
          attribute DOMString hreflang;
          attribute DOMString type;
          [SameObject, PutForwards=value] readonly attribute DOMTokenList sizes;
        };
        HTMLLinkElement implements LinkStyle;
      </pre>
    </dd>
  </dl>

  <{link}> 요소(element)는 작성자가 그들의 문서를 다른 리소스들에 연결시키는 것을 허용합니다.

  링크(들)의 목적지는 <dfn element-attr for="link"><code>href</code></dfn> 속성(attribute)에 의해 
  주어지고, 이 속성(attribute)는 존재해야(must) 하고 
  <a lt="valid non-empty URL potentially surrounded by spaces">유효한 잠정적으로 공백으로 둘러 싸일 수 있는 비어있지 않은 URL</a>을 
  포함해야(must) 합니다. <span class="impl"><{link/href}> 속성이 존재하지 않ㄴ흔다면, 요소(element)는 
  링크를 정의하지 않습니다.</span>

  <{link}> 요소(element)는 <{link/rel}> 속성(attribute)을 가져야(must) 합니다.

  <p class="note">
    <{link/rel}> 속성(attribute)이 사용되었다면, 요소(element)는 <code>head</code> 요소(element)에 
    제한됩니다.
  </p>

  표현된 링크의 유형 (관계)는 <dfn element-attr for="link"><code>rel</code></dfn> 속성(attribute)의 
  값에 의해 주어지고, 이것이 존재한다면, <a lt="set of space-separated tokens">공백으로 분리된 토큰 집합</a>인
  값을 가져야(must) 합니다. <a lt="allowed keywords and their meanings">허용된 키워드와 그것들의 의미</a>는
  이후 섹션에서 정의됩니다.  <{link/rel}> 속성(attribute)이 존재하지 않는다면 키워드를 가지지 않거나,
  사용된 어떤 키워드도 이 명세에서의 정의를 따라 허용된 것이 아니라면, 요소(element)는 어떤 연결도 
  생성하지 않습니다.

  링크의 두 카테고리들은 <{link}> 요소(element)를 사용하여 생성될 수 있습니다:
  <a lt="Links to external resources">외부 리소스들로의 링크들</a>과 <a lt="hyperlinks">하이퍼링크들</a>.
  [[#sec-link-types]] 섹션은 특정 링크 유형이 외부 리소스인지 하이퍼링크인지를 정의합니다.
  한 개 <code>link</code> 요소(element)는 여러 개의 링크들을 (일부는 외부 리소스 링크일 수 있고
  일부는 하이퍼링크일 수 있습니다) 생성할 수 있습니다; 정확히 어떤 그리고 몇 개의 링크들이 생성 되는지는
  <{link/rel}> 속성(attribute)에 주어진 키워드에 달려 있습니다. 유저 에이전트는 요소(element) 단위가 
  아닌 링크 단위로 처리해야(must) 합니다.

  <p class="note">
    <{link}> 요소(element)에 대해 생성 된 각 링크는 별도로 처리됩니다. 예를 들어, <code>rel="stylesheet"</code>를
    가진 두 개의 <{link}> 요소(element)가 있따면, 각각은 독립적으로 자신의 속성(attbribute)에 의해
    영향을 받습니다. 마찬가지로, <code>next stylesheet</code> 값을 가진 <{link/rel}> 속성(attribute)을
    가진 단일 <{link}> 요소(element)가 있다면, 이것은 (<code>next</code> 키워드에 대한) <a lt="hyperlink">하이퍼링크</a>와
    (<code>stylesheet</code> 키워드에 대한) <a lt="external resource link">외부 리소스 링크</a>를 
    생성하고, 그것들은 다른 속성(attribute)들에 의해 (<code>media</code>나 <code>title</code> 같은)
    다르게 영향을 받습니다.
  </p>

  <div class="example">
    예를 들어, 다음 <{link}> 요소(element)는 두 하이퍼링크들을 (동일한 페이지에 대한) 생성합니다 :

    <pre highlight="html">&lt;link rel="author license" href="/about"></pre>

    이 요소(element)에 의해 생성된 두 링크들은 의미가 현재 페이지의 작성자에 대한 정보를 가진 대상 
    페이지인 하나와, 의미가 현재 페이지가 어떤 라이센스 하에 제공되는지에 관한 정보를 가지는 대상
    페이지인 하나입니다.
  </div>

  <{link}>와 <{a}> 요소(element)들은 <{links/href}>에 의해 명시된 리소스로부터 현재 문서로의
  <a lt="reverse link">역방향 연결</a> 관계를 설명하는데 사용되는 
  <dfn element-attr for="a,link,links"><code>rev</code></dfn> 속성(attribute)도 가질 수 있습니다.
  이것이 존재한다면 이 속성(attribute)의 값은
  <a lt="set of space-separated tokens">공백으로 분리된 토큰 집합</a>이어야 합니다. <{links/rel}> 
  속성(attribute)처럼, [[#sec-link-types]]은 <{links/rev}> 속성(attribute)에 대한
  <a lt="allowed keywords and their meanings">허용된 키워드와 그것들의 의미</a>를 설명합니다.
  <{links/rel}>과 <{links/rev}> 속성(attribute)들은 동일 요소(element)에 모두 존재할 수 있습니다.

  <dfn lt="reverse link|Reverse links">역방향 링크</dfn>는 링크의 역방향 관계를 나타내는 방법입니다.
  값이 정방향 관계를 ("링크가 나에게 관계되는 방법") 전달하는 <{links/rel}> 속성(attribute)과는
  대조적으로, <{links/rev}> 속성(attribute)은 유사한 관계들이 역방향으로 ("내가 이 링크에 관계되는 
  방법") 노출되도록 허용합니다. 이 값들은 유저 에이전트가 연결된 문서의 보다 포괄적인 지도를 만들 수 
  있게 할 수 있습니다.

  <div class="example">책의 챕터를 각각 포함하는 두 개의 문서가 주어지면, 그것들 사이의 링크는 다음과
  같이 <{link/rel}>과 <{links/rev}> 속성(attribute)들을 가지고 기술될 수 있습니다:

  "chapter1.html" URL를 가진 문서
  <pre highlight="html">&lt;link href="chapter2.html" rel="next" rev="prev"&gt;</pre>

  "chapter2.html" URL를 가진 문서
  <pre highlight="html">
&lt;link href="chapter1.html" rel="prev" rev="next"&gt;
&lt;link href="chapter3.html" rel="next" rev="prev"&gt;</pre>

  chapter1.html에서 chapter2.html로의 연결은  정방향으로 시리즈에서 "<code>next</code>" 챕터이고,
  역방향으로는 (chapter2.html에서 chapter1.html으로) "<code>previous</code>" 챕터 입니다.
  </div>

  <div class="example">콘텐트 목록 문서에서 링크들은 <{links/rel}>과 <{links/rev}>를 사용하여
  다음과 같이 기술 될 수 있습니다:
  <pre highlight="html">
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="chapter1.html" rev="toc" rel="next"&gt;chapter 1&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="chapter2.html" rev="toc"&gt;&lt;/a&gt;chapter 2&lt;/li&gt;
    &lt;li&gt;&lt;a href="chapter3.html" rev="toc"&gt;&lt;/a&gt;chapter 3&lt;/li&gt;
  &lt;/ol&gt;
  </pre>

  콘텐트 목록에서 "<code>next</code>" 논리 경로는 <{links/rel}>을 사용하여 노출 된 첫 번째 챕터 입니다.
  각 챕터 링크는 현재 문서가 매 챕터에 대한 콘텐트 목록 문서 임을 나타내는 "<code>toc</code>"
  <{links/rev}> 값을 가집니다.

  </div>

  <dfn element-attr for="link"><code>crossorigin</code></dfn> 속성(attribute)은 
  <a lt="CORS settings attribute">CORS 설정 속성(attribute)</a>입니다. 이것은 외부 리소스 링크와 
  함께 사용하도록 의도된 것입니다.

  외부 리소스로의 링크에 대한 정확한 동작은 관련 링크 유형에 대해 정의된 정확한 관계에 달려있습니다.
  일부 속성(attribute)들은 외부 리소스가 적용 될지 (아래 정의된 대로) 여부를 제어합니다.

  DOM에 표현되는 외부 리소스에 대해 (예를 들어, 스타일시트), DOM 표현은 리스소가 적용 되지 않는다
  하더라도 사용 가능 하게 되어야(must) 합니다 (모듈 교차 출처 제한).
  <dfn lt="obtain|obtain the resource">리소스를 획득</dfn>하기 위해, 유저 에이전트는 다음 단계들을 
  수행해야(must) 합니다:


  1. <{link/href}> 속성(attribute)의 값이 빈 문자열이라면, 이 단계들을 중단합니다.
  2. 요소(element)의 <a lt="node document">노드 문서</a>에 관련하여, <{link/href}> 속성(attribute)에
      의해 주어진 <a for="url">URL</a>을 <a lt="parse">해석</a>합니다. 그것이 실패한다면, 이 단계들을
      중단합니다. 그렇지 않으면, <var>url</var>을 <a lt="resulting URL record">결과 URL 레코드</a>로 
      둡니다.
  3. <var>corsAttributeState</var>를 요소(element)의 <{link/crossorigin}> 콘텐트 속성(attribute)의 
      현재 상태로 둡니다.
  4. <var>request</var>를 <var>url</var>과 <var>corsAttributeState</var>가 주어진 
      <a lt="creating a potential-CORS request">잠재적 CORS 요청 생성</a>의 결과로 둡니다.
  5. <var>request</var>의 <a lt="client">클라이언트</a>를 <{link}> 요소(element)의
      <a lt="node document">노드 문서</a>의 {{Window}} 객체의 
      <a lt="environment settings object">환경 설정 객체</a>로 둡니다.
  6. <var>request</var>를 <a lt="fetch">가져옵니다</a>.

  유저 에이전트는 적용되지 않은 모든 리소스들을 능동적으로 가져오는 대신, 그것들이 필요할 경우 그
  리소스를 얻기 위해 시도하기로 선택할 수 있습니다.

  외부 리소스를 가져올 때 사용된 프로토콜의 (예를 들어, HTTP) 의미를 따라야(must) 합니다. (예를 들어,
  리다이렉트가 뒤따르는 것과 404 응답은 외부 리소스가 적용되지 않는 것을 야기합니다.)

  일단 리소스를 얻으려는 시도와 그것의 <a lt="critical subresources">중요한 하위 리소스들</a>이 완료되면,
  유저 에이전트는 로드가 성공적이었다면, <{link}> 요소(element)에 <code>load</code>라고 이름이
  붙은 <a lt="fire a simple event">단순 이벤트를 발생</a>시키기 위한 <a lt="queue a task">작업을 대기열에 넣거나</a>,
  리소스나 그것의 <a lt="critical subresources">중요한 하위 리소스들</a>의 하나가 어떤 이유로
  (예를 들어, DNS 오류, HTTP 404 응답, 너무 빨리 닫히는 연결, 지원되지 않은 Content-Type) 완전한
  로드가 실패되었다면, <{link}> 요소(element)에 <code>error</code>라고 이름이 붙은
  <a lt="fire a simple event">단순 이벤트를 발생</a>시키기 위한 <a lt="queue a task">작업을 대기열에 넣습니다</a>.
  리소스나 하위 리소스들 처리에 비 네트워크 오류들은 (예를 들어, CSS 해석 오류, PNG 디코딩 오류)
  이 문단의 목적을 위한 실패가 아닙니다.

  이 <a lt="tasks">작업들</a>에 대한 <a lt="task source">작업 소스</a>는 
  <a lt="DOM manipulation task source">DOM 조작 작업 소스</a>입니다.

  요소(element)는 리소스와 그것의 <a lt="critical subresources">중요한 하위 리소스들</a>을 얻기 위한 
  모든 시도가 완료될 때까지 요소(element)의 <a lt="node document">노드 문서</a>의
  <a lt="delay the load event">로드 이벤트를 지연</a>시켜야(must) 합니다. (유저 에이전트가 아직 얻으려고
  시도하지 않은 리소스는, 예를 들어 리소스가 필요하기를 기다리고 있기 때문에,
  <a lt="delay the load event">로드 이벤트를 지연</a>시키지 않습니다.)

  <hr />

  대화형 유저 에이전트는 유저 인터페이스의 어딘가에서 <{link}> 요소(element)를 사용하여 생성된
  <a lt="follow the hyperlinks">하이퍼링크들을 따르기</a> 위한 방법을 사용자에게 제공할 수 있습니다.
  정확한 인터페이스는 이 명세에 정의되지 않지만, 문서 내 각 <{link}> 요소(element)를 가지고 생성된 각
  하이퍼링크에 대해, 일부 형식이나 다른 것에서 (아마도 간소화 된), 다음 정보를 (아래 정의된 대로,
  요소(element)의 속성으로부터 얻어진) 포함할 수 있습니다.

  * 이 문서와 리소스 (<{link/rel}> 속성(attribute)에 의해 주어진) 사이의 관계
  * 리소스의 제목 (<code>title</code> 속성(attribute)에 의해 주어진).
  * 리소스의 주소 (<{link/href}> 속성(attribute)에 의해 주어진).
  * 리소스의 언어 (<code>hreflang</code> 속성(attribute)에 의해 주어진).
  * 리소스에 대한 최고의 매체 (<code>media</code> 속성(attribute)에 의해 주어진).

  유저 에이전트는 리소스의 유형과 같은 (<code>type</code> 속성(attribute)에 의해 주어진), 다른 
  정보를 포함할 수 있습니다.

  <p class="note">
    <{link}> 요소(element)와 그것의 <{link/rel}> 속성(attribute)을 가지고 생성된 하이퍼링크들은 전체 
    페이지에 적용됩니다. 이것은 컨텍스트가 문서 안의 링크의 위치에 의해 주어진 위치인 링크의 유형을
    나타내는, <{a}>와 <{area}> 요소(element)의 <{link/rel}> 속성(attribute)과 대조를 이룹니다.
  </p>

  <dfn element-attr for="link"><code>media</code></dfn> 속성(attribute)은 리소스가 적용될 매체를 말해줍니다.
  값은 <a lt="valid media query list">유효한 미디어 쿼리 목록</a>이어야(must) 합니다.

  <div class="impl">
    링크가 <a lt="hyperlink">하이퍼링크</a>라면 <code>media</code> 속성(attribute)은 순수하게 조언적이고, and
    문제의 문서가 어떤 매체에 대해 설계되었는지를 설명합니다.

    하지만, 링크가 <a lt="external resource link">외부 리소스 링크</a>라면, <code>media</code> 
    속성(attribute)은 지시적인 것입니다. 유저 에이전트는 <code>media</code> 속성(attribute)의 값이
    <a lt="matches the environment">환경과 일치</a>하고 다른 관련 조건들이 적용되는 경우 외부 리소스를 
    적용해야(must)하고, 그렇지 않으면 적용하지 않아야(must) 합니다.

    <p class="note">
      외부 리소스는 그것의 적용 가능성 제한 내에서 정의된 추가 제한 사항을 가질 수 있습니다. 
      예를 들어, CSS 스타일 시트는 일부 <code>@media</code> 블럭을 가질 수 있습니다. 이 명세는 
      그러한 추가 제한 사항이나 요구사항을 재정의 하지 않습니다.
    </p>
  </div>

  <code>media</code> 속성(attribute)이 생력되었다면 기본 값은 기본값에 의해 링크가 모든 매체에
  적용 됨을 의미하는 "<code>all</code>" 입니다.

  <{link}> 요소(element)의 <dfn element-attr for="link"><code>hreflang</code></dfn> 속성(attribute)은 
  <{a}> 요소(element)의 <code>hreflang</code> 속성(attribute)과 동일한 의미를 가집니다.

  <dfn element-attr for="link"><code>type</code></dfn> 속성(attribute)은 링크되는 리소스의 
  <a lt="MIME type">MIME 타입</a>을 제공합니다. 이것은 순수하게 조언적입니다. 값은 
  <a lt="valid mime type">유효한 MIME 타입</a>이어야(must) 합니다.

  <a lt="external resource links">외부 리소스 링크</a>에 대해, <code>type</code> 속성(attribute)은 
  유저 에이전트가 지원하지 않는 리소스를 가져오는 것을 방지할 수 있도록 유저 에이전트에 대한 힌트로
  사용됩니다. <span class="impl">속성(attribute)이 존재하지 않는다면, 유저 에이전트는 (그것이
  <a lt="valid mime type">유효한 MIME 타입</a>, 예를 들어, 빈 문자열이라 하더라도) 리소스가 주어진 
  유형의 것으로 추정해야(must) 합니다. 속성(attribute)이 생략되었고, 외부 리소스 링크 유형이 정의된 
  기본 유형을 가진다면, 유저 에이전트는 리소스를 그 유형의 것으로 추정해야(must) 합니다. 유저 에이전트가
  주어진 링크 관계에 대해 주어진 <a lt="MIME type">MIME 타입</a>을 지원하지 않는다면, 유저 에이전트는
  리소스를 <a lt="obtain">획득</a>하지 않아야(should) 합니다; 유저 에이전트가 주어진 링크 관계에
  대해 주어진 <a lt="MIME type">MIME 타입</a>을 지원하지 않는다면, 유저 에이전트는
  <a lt="external resource link">외부 리소스 링크</a>의 특정 유형에 대해  명시된 대로 적절한 시간에
  리소스를 <a lt="obtain">획득</a>해야(should) 합니다. 속성(attribute)이 생략되었고, 외부 리소스 링크
  유형이 정의된 기본 유형을 가지지 않고, 유형이 알려져 있고 지원되는 경우 유저 에이전트가 리소스를
  <a lt="obtain">획득</a> 한다면, 유저 에이전트는 그것이 지원된다는 가정 하에 리소스를
  <a lt="obtain">획득</a> 해야(should) 합니다.</span>

  <div class="impl">
    유저 에이전트는 <code>type</code> 속성(attribute)을 믿을만한 것으로 간주하지 않아야(must) 합니다 
    &mdash; 리소스를 가져오는데에, 유저 에이전트는 <code>type</code> 속성(attribute)을 그것의 실제 
    유형을 결정하기 위해 사용하지 않아야(must) 합니다. 오직 실제 유형은 (다음 문단에 정의된 것과 같이)
    리소스에 <em>적용</em> 할지 여부를 결정짓기 위해서 사용되는 것이지, 앞서 언급된 가정된 유형이 
    아닙니다.

    <dfn lt="determining the type of the resource"></dfn>외부 리소스 링크 유형이 리소스의 
    <a lt="Content-Type metadata">Content-Type 메타데이터</a> 처리에 대한 규칙을 정의한다면, 그 
    규칙은 적용됩니다. 그렇지 않고, 리소스가 이미지가 예상된다면, 유저 에이전트는 리소스의
    <a lt="Content-Type metadata">Content-Type 메타데이터</a>로부터 유형이 결정된 
    <var>official type</var>을 가지고 <a lt="image sniffing rules">이미지 스니핑 규칙들</a>을 적용할 
    수 있고, 결과로 나온 <a lt="computed type of the resource">계산 된 리소스의 유형</a>을 그것이
    실제 유형인것 처럼 사용할 수 있습니다. 그렇지 않고, 이 조건들을 적용하거나 유저 에이전트가 이미지
    스니핑 규칙을 적용하지 않기로 한다면, 유저 에이전트는 리소스의 유형을 결정하기 위해 리소스의
    <a lt="Content-Type metadata">Content-Type 메타데이터</a>를 사용해야(must) 합니다. 유형
    메타데이터가 없고 외부 리소스 링크 유형이 정의된 기본 유형을 가진다면, 유저 에이전트는 리소스를 
    그 유형의 것으로 추정해야(must) 합니다.

    <p class="note">
      <code>stylesheet</code> 링크 유형은 리소스의 
      <a lt="Content-Type metadata">Content-Type 메타데이터</a> 처리에 대한 규칙을 정의합니다.
    </p>

    유저 에이전트가 리소스의 유형을 설정 할 때, 유저 에이전트는 지원되는 유형의 것이고 다른 관련 
    조건이 적용된다면 리소스를 적용해야(must)하고, 그렇지 않으면 리소스를 무시해야(must) 합니다.

    <div class="example">
      문서가 다음과 같이 라벨링 된 스타일 시트 링크를 포함한다면:

      <pre highlight="html">
        &lt;link rel="stylesheet" href="A" type="text/plain"&gt;
        &lt;link rel="stylesheet" href="B" type="text/css"&gt;
        &lt;link rel="stylesheet" href="C"&gt;
      </pre>

     ...CSS 스타일 시트만을 지원하는 호환 유저 에이전트는 B와 C파일을 가져오고, A파일은 생략할 
     것입니다 (<code>text/plain</code>은 CSS 스타일 시트에 대한 <a lt="MIME type">MIME 타입</a>이 
     아니기 때문에).

     B와 C 파일에 대해, 이것은 이후 서버에 의해 반환된 실제 유형을 검사할 것입니다. 
     <code>text/css</code>로 보내어진 것들에 대해, 이것은 스타일 시트를 적용할 것이지만, 
     <code>text/plain</code>으로 라벨링 된 것들에 대해 혹은 다른 유형에 대해서는 그렇지 않을 것입니다.

     두 파일 중 하나가  <a>Content-Type</a> 메타데이터 없이 혹은, 
     <code>Content-Type:&nbsp;"null"</code>과 같은 구문적으로 틀린 유형을 가지고 반환된다면, 
     <code>stylesheet</code> 링크들에 대한 기본 유형이 효과를 낼 것입니다. 그 기본 유형이 
     <code>text/css</code>이기 때문에, 스타일 시트는 그럼에도 불구하고 적용 <em>될</em> 것입니다.
    </div>
  </div>

  <dfn element-attr for="link"><code>title</code></dfn> 속성(attribute)은 링크의 제목(title)을 
  제공합니다. 한 가지 예외를 가지고, 이것은 순수하게 조언적입니다. 값은 텍스트입니다. 예외 사항은 
  <code>title</code> 속성(attribute)이 <a lt="alternative style sheet sets">대체 스타일 시트 세트</a>를 
  정의하는 스타일 시트에 대한 것입니다.

  <p class="note">
    <{link}> 요소(element)들의 <code>title</code> 속성(attribute)은 제목이 부모 요소(element)의 
    제목을 상속 받지 않는 링크라는 점에서 대다수 다른 요소(element)들의 범용 <code>title</code> 
    속성(attribute)과는 차이가 있습니다: 그것은 단지 제목을 가지지 않습니다.
  </p>

  <code>sizes</code> 속성(attribute)은 <code>icon</code> 링크 유형과 함께 사용됩니다. 
  속성(attribute)은 <code>icon</code> 키워드를 명시한 <{link/rel}> 속성(attribute)을 가지지 않는 
  <{link}> 요소(element)들에 명시되지 않아야(must) 합니다.

  <div class="impl">
    <a lt="hyperlinks">하이퍼링크</a>들을 생성하는 <code>link</code> 요소(element)들의 
    <a lt="activation behavior">활성화 동작</a>은 다음 단계들을 수행하는 것입니다:

    1. <{link}> 요소(element)의 <a lt="node document">노드 문서</a>가, 
        <a lt="fully active">완전히 활성화</a>가 아니라면, 이 단계들을 중단합니다.
    2. <code>link</code> 요소(element)에 의해 생성된 <a lt="follow the hyperlink">하이퍼링크를 따라갑니다</a>.

    HTTP <code>Link:</code> 헤더가 지원된다면, HTTP 메세지에 주어진 순서에 따라, 문서 내 모든 
    링크들 앞에 오는 것으로 추정되어야(must) 합니다. 이 헤더들은 관련 명세에 주어진 규칙을 따라 처리 
    됩니다. [[!HTTP]] [[!RFC5988]]

    <p class="note">
      HTTP 링크의 등록 관계 유형: 헤더는 <a lt="HTML link types">HTML 링크 유형들</a>과 구별되고, 
      따라서 그것들의 의미는 동일한 이름의 HTML 유형들과 다를 수 있습니다.
    </p>

    IDL 속성(attribute)들 <dfn attribute for="HTMLLinkElement"><code>href</code></dfn>, <dfn attribute for="HTMLLinkElement"><code>rel</code></dfn>,
	<dfn attribute for="HTMLLinkElement"><code>rev</code></dfn>, <dfn attribute for="HTMLLinkElement"><code>media</code></dfn>, <dfn attribute for="HTMLLinkElement"><code>hreflang</code></dfn>,
    <dfn attribute for="HTMLLinkElement"><code>type</code></dfn>, <dfn attribute for="HTMLLinkElement"><code>sizes</code></dfn>는 동일한 이름의 각 콘텐트 속성(attribute)들을 
	<a lt="reflect">반영</a>해야(must) 합니다.

    <dfn attribute for="HTMLLinkElement"><code>crossOrigin</code></dfn> IDL 속성(attribute)은
    콘텐트 속성(attribute)을 <a lt="reflect">반영</a>해야(must) 합니다.

    IDL 속성(attribute) <dfn attribute for="HTMLLinkElement"><code>relList</code></dfn>은 
    <{link/rel}> 콘텐트 속성을 <a lt="reflect">반영</a> <span class="impl">해야(must)</span> 합니다.

    <code>relList</code>의 <code>DOMTokenList</code>의 <a lt="supported tokens">지원되는 토큰들</a>은 
    <code>link</code> 요소(element)들에 허용되고 유저 에이전트에 의해 지원된 
    <a lt="HTML link types">HTML 링크 유형들</a>에 정의된 키워드들입니다.

    <{link/rel}>의 <a lt="supported tokens">지원되는 토큰들</a>은 <code>link</code> 
    요소(element)들에 허용되고, 처리 모델에 영향을 주고, 유저 에이전트에 의해 지원되는
    <a lt="HTML link types">HTML 링크 유형들</a>에 정의된 키워드들입니다. 가능한 지원되는 토큰들은
    <code>alternate</code>, <a>dns-prefetch</a>, <code>icon</code>, <a>preconnect</a>,
    <a>prefetch</a>, <a>prerender</a>, <code>stylesheet</code> 입니다. <{link/rel}>의
    <a lt="supported tokens">지원되는 토큰들</a>은 유저 에이전트가 처리 모델에 대해 구현하는
    이 목록의 토큰들을 포함해야(must) 합니다.

    다른 명세들은 [[!RESOURCE-HINTS]]과 같은, <a lt="Other link types">다른 링크 유형들</a>에 정의 
    된 <a lt="HTML link types">HTML 링크 유형들</a>을 추가할 수 있습니다. 이 명세들은 그들의 링크 
    유형들이 <{link/rel}>의 지원되는 토큰들에 포함되도록 요구할 수 있습니다.
  </div>

  <code>LinkStyle</code> 인터페이스는 또한 이 요소(element)에 의해 구현됩니다. [[!CSSOM]]

  <div class="example">
    여기, <{link}> 요소(element)들의 세트가 일부 스타일 시트들을 제공합니다:

    <pre highlight="html">
      &lt;!-- a persistent style sheet -->
      &lt;link rel="stylesheet" href="default.css">

      &lt;!-- the preferred alternate style sheet -->
      &lt;link rel="stylesheet" href="green.css" title="Green styles">

      &lt;!-- some alternate style sheets -->
      &lt;link rel="alternate stylesheet" href="contrast.css" title="High contrast">
      &lt;link rel="alternate stylesheet" href="big.css" title="Big fonts">
      &lt;link rel="alternate stylesheet" href="wide.css" title="Wide screen">
    </pre>
  </div>

  <div class="example">
    다음 예제는 대체 형식을 사용하고 다른 언어를 대상으로하며 다른 매체에 대해 의도된 페이지의 
    버전을 지정할 수 있는 방법을 보여줍니다:

    <pre highlight="html">
      &lt;link rel=alternate href="/en/html" hreflang=en type=text/html title="English HTML">
      &lt;link rel=alternate href="/fr/html" hreflang=fr type=text/html title="French HTML">
      &lt;link rel=alternate href="/en/html/print" hreflang=en type=text/html media=print title="English HTML (for printing)">
      &lt;link rel=alternate href="/fr/html/print" hreflang=fr type=text/html media=print title="French HTML (for printing)">
      &lt;link rel=alternate href="/en/pdf" hreflang=en type=application/pdf title="English PDF">
      &lt;link rel=alternate href="/fr/pdf" hreflang=fr type=application/pdf title="French PDF">
    </pre>
  </div>

<h4 id="the-meta-element">The <dfn element><code>meta</code></dfn> element</h4>

  <dl class="element">
    <dt><a lt="Categories">카테고리</a>:</dt>
    <dd><a>Metadata content</a>.</dd>
    <dt><a lt="Contexts in which this element can be used">이 요소(element)가 사용될 수 있는 컨텍스트</a>:</dt>
    <dd>
      If the <code>charset</code> attribute is present, or if the element's <code>http-equiv</code>
      attribute is in the <a state for="http-equiv">encoding declaration state</a>: in a <{head}> element.
    </dd>
    <dd>
      If the <code>http-equiv</code> attribute is present but not in the
      <a state for="http-equiv">encoding declaration state</a>: in a <{head}> element.
    </dd>
    <dd>
      If the <code>http-equiv</code> attribute is present but not in the
      <a state for="http-equiv">encoding declaration state</a>: in a <{noscript}> element that is a child of a
      <{head}> element.
    </dd>
    <dd>
      If the <code>name</code> attribute is present: where <a>metadata content</a> is expected.
    </dd>
    <dt><a lt="Content model">콘텐트 모델</a>:</dt>
    <dd><a>Nothing</a>.</dd>
    <dt><a lt="Tag omission in text/html">text/html에서 태그 생략</a>:</dt>
    <dd>No <a>end tag</a>.</dd>
    <dt><a lt="Content attributes">콘텐트 속성(attribute)들</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dd><code>name</code> — Metadata name</dd>
    <dd><code>http-equiv</code> — Pragma directive</dd>
    <dd><code>content</code> — Value of the element</dd>
    <dd><code>charset</code> — <a>Character encoding declaration</a></dd>
    <dt>허용된 <a href="#aria-role-attribute">ARIA 역할(role) 속성(attribute)</a> 값들:</dt>
    <dd>None</dd>
    <dt>허용된 <a href="#state-and-property-attributes">ARIA 상태(state)와 속성(property) 속성(attribute)들</a>:</dt>
    <dd><a lt="Global aria-* attributes">범용 aria-* 속성(attribute)들</a></dd>
    <dt><a lt="DOM interface">DOM 인터페이스</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl" dfn-for="HTMLMetaElement">
        interface HTMLMetaElement : HTMLElement {
          attribute DOMString name;
          attribute DOMString httpEquiv;
          attribute DOMString content;
        };
      </pre>
    </dd>
  </dl>

  The <{meta}> element <a>represents</a> various kinds of metadata that cannot be
  expressed using the <a element for="html"><code>title</code></a>, <{base}>, <{link}>, <{style}>,
  and <{script}> elements.

  The <{meta}> element can represent document-level metadata with the <code>name</code>
  attribute, pragma directives with the <dfn element-attr for="meta"><code>http-equiv</code></dfn> attribute, and the file's
  <a>character encoding declaration</a> when an HTML document is serialized to string form (e.g., for
  transmission over the network or for disk storage) with the <code>charset</code> attribute.

  Exactly one of the <code>name</code>, <code>http-equiv</code>, and <code>charset</code>
  attributes must be specified.

  If either <code>name</code> or <code>http-equiv</code> is
  specified, then the <code>content</code> attribute must also be
  specified. Otherwise, it must be omitted.

  The <dfn element-attr for="meta"><code>charset</code></dfn> attribute specifies the character
  encoding used by the document. This is a <a>character encoding declaration</a>. If the
  attribute is present in an <a>XML document</a>, its value must be an
  <a>ASCII case-insensitive</a> match for the string "<code>utf-8</code>" (and the
  document is therefore forced to use <a>UTF-8</a> as its encoding).

  <p class="note">The <code>charset</code> attribute on the
  <{meta}> element has no effect in XML documents, and is only allowed in order to
  facilitate migration to and from XHTML.</p>

  There must not be more than one <{meta}> element with a <code>charset</code> attribute
  per document.

  The <dfn element-attr for="meta"><code>content</code></dfn> attribute gives the value of the
  document metadata or pragma directive when the element is used for those purposes. The allowed
  values depend on the exact context, as described in subsequent sections of this specification.

  If a <{meta}> element has a <dfn element-attr for="meta"><code>name</code></dfn>
  attribute, it sets document metadata. Document metadata is expressed in terms of name-value pairs,
  the <code>name</code> attribute on the <{meta}> element giving the
  name, and the <code>content</code> attribute on the same element giving
  the value. The name specifies what aspect of metadata is being set; valid names and the meaning of
  their values are described in the following sections. If a <{meta}> element has no
  <code>content</code> attribute, then the value part of the metadata name-value pair is the empty
  string.

  The <dfn attribute for="HTMLMetaElement"><code>name</code></dfn> and <dfn attribute for="HTMLMetaElement"><code>content</code></dfn> IDL attributes must
  <a>reflect</a> the respective content attributes of the same name. The IDL attribute
  <dfn attribute for="HTMLMetaElement"><code>httpEquiv</code></dfn> must <a>reflect</a> the content attribute
  <{meta/http-equiv}>.

<h5 id="standard-metadata-names">Standard metadata names</h5>

  This specification defines a few names for the <code>name</code> attribute of the
  <{meta}> element.

  Names are case-insensitive<span class="impl">, and must be compared in an
  <a>ASCII case-insensitive</a> manner</span>.

  : <dfn><code>application-name</code></dfn>
  :: The value must be a short free-form string giving the name of the Web application that the page
      represents. If the page is not a Web application, the <code>application-name</code> metadata
      name must not be used. Translations of the Web application's name may be given, using the
      <{global/lang}> attribute to specify the language of each name.

      There must not be more than one <{meta}> element with a given <a>language</a> and
      with its <code>name</code> attribute set to the value <code>application-name</code> per
      document.

      <div class="impl">
        User agents may use the application name in UI in preference to the page's
        <a element for="html"><code>title</code></a>, since the title might include status messages and the like relevant to
        the status of the page at a particular moment in time instead of just being the name of the
        application.

        To find the application name to use given an ordered list of languages (e.g., British
        English, American English, and English), user agents must run the following steps:

        1. Let <var>languages</var> be the list of languages.
        2. Let <var>default language</var> be the <a>language</a> of the {{Document}}'s
            <a>root element</a>, if any, and if that language is not unknown.
        3. If there is a <var>default language</var>, and if it is not the same language as any of
            the languages in <var>languages</var>, append it to <var>languages</var>.
        4. Let <var>winning language</var> be the first language in <var>languages</var> for which
            there is a <{meta}> element in the {{Document}} that has its
            <code>name</code> attribute set to the value <code>application-name</code> and whose
            <a>language</a> is the language in question.

            If none of the languages have such a <{meta}> element, then abort these steps;
            there's no given application name.
        5. Return the value of the <code>content</code> attribute of the first <code>meta</code>
            element in the {{Document}} in <a>tree order</a> that has its <code>name</code>
            attribute set to the value <code>application-name</code> and whose <a>language</a> is
            <var>winning language</var>.

        <p class="note">
          This algorithm would be used by a browser when it needs a name for the page, for instance,
          to label a bookmark. The languages it would provide to the algorithm would be the user's
          preferred languages.
        </p>
      </div>

  : <dfn><code>author</code></dfn>
  :: The value must be a free-form string giving the name of one of the page's authors.

  : <dfn><code>description</code></dfn>
  :: The value must be a free-form string that describes the page. The value must be appropriate for
      use in a directory of pages, e.g., in a search engine. There must not be more than one
      <{meta}> element with its <code>name</code> attribute set to the value
      <code>description</code> per document.

  : <dfn><code>generator</code></dfn>
  :: The value must be a free-form string that identifies one of the software packages used to
      generate the document. This value must not be used on pages whose markup is not generated by
      software, e.g., pages whose markup was written by a user in a text editor.

      <div class="example">
        Here is what a tool called "Frontweaver" could include in its output, in the page's
        <{head}> element, to identify itself as the tool used to generate the page:

        <pre highlight="html">&lt;meta name=generator content="Frontweaver 8.2"&gt;</pre>
      </div>

  : <dfn><code>keywords</code></dfn>
  :: The value must be a <a>set of comma-separated tokens</a>, each of which is a keyword relevant
      to the page.

      <div class="example">
        This page about typefaces on British motorways uses a <{meta}> element to specify
        some keywords that users might use to look for the page:

        <pre highlight="html">
          &lt;!DOCTYPE HTML&gt;
          &lt;html lang="en-GB"&gt;
            &lt;head&gt;
              &lt;title&gt;Typefaces on UK motorways&lt;/title&gt;
              &lt;meta name="keywords" content="british,type face,font,fonts,highway,highways"&gt;
            &lt;/head&gt;
            &lt;body&gt;
            ...
        </pre>
      </div>

      <p class="note">
        Many search engines do not consider such keywords, because this feature has historically
        been used unreliably and even misleadingly as a way to spam search engine results in a way
        that is not helpful for users.
      </p>

      <div class="impl">
        To obtain the list of keywords that the author has specified as applicable to the page, the
        user agent must run the following steps:

        1. Let <var>keywords</var> be an empty list.
        2. For each <{meta}> element with a <code>name</code> attribute and a
            <code>content</code> attribute and whose <code>name</code> attribute's value is
            <code>keywords</code>, run the following substeps:
            1. <a lt="split a string on commas">Split the value of the element's <code>content</code> attribute on commas</a>.
            2. Add the resulting tokens, if any, to <var>keywords</var>.
        3. Remove any duplicates from <var>keywords</var>.
        4. Return <var>keywords</var>. This is the list of keywords that the author has specified as
            applicable to the page.

        User agents should not use this information when there is insufficient confidence in the
        reliability of the value.

        <p class="example">
          For instance, it would be reasonable for a content management system to use the keyword
          information of pages within the system to populate the index of a site-specific search
          engine, but a large-scale content aggregator that used this information would likely find
          that certain users would try to game its ranking mechanism through the use of
          inappropriate keywords.
        </p>
      </div>

<h5 id="other-metadata-names">Other metadata names</h5>

  <dfn lt="register the names|register the name|metadata names">Extensions to the predefined set of metadata names</dfn> may be registered in the
  <a href="https://wiki.whatwg.org/wiki/MetaExtensions">WHATWG Wiki MetaExtensions page</a>. [[WHATWGWIKI]]

  Anyone is free to edit the WHATWG Wiki MetaExtensions page at any time to add a type. These new
  names must be specified with the following information:

  : Keyword
  :: The actual name being defined. The name should not be confusingly similar to any other defined
      name (e.g., differing only in case).

  : Brief description
  :: A short non-normative description of what the metadata name's meaning is, including the format
      the value is required to be in.

  : Specification
  :: A link to a more detailed description of the metadata name's semantics and requirements. It
      could be another page on the Wiki, or a link to an external page.

  : Synonyms
  :: A list of other names that have exactly the same processing requirements. Authors should not
      use the names defined to be synonyms, they are only intended to allow user agents to support
      legacy content. Anyone may remove synonyms that are not used in practice; only names that need
      to be processed as synonyms for compatibility with legacy content are to be registered in this
      way.

  : Status
  :: One of the following:
      : Proposed
      :: The name has not received wide peer review and approval. Someone has proposed it and is, or
          soon will be, using it.

      : Ratified
      :: The name has received wide peer review and approval. It has a specification that
          unambiguously defines how to handle pages that use the name, including when they use it in
          incorrect ways.

      : Discontinued
      :: The metadata name has received wide peer review and it has been found wanting. Existing
          pages are using this metadata name, but new pages should avoid it. The "brief description"
          and "specification" entries will give details of what authors should use instead, if
          anything.

      If a metadata name is found to be redundant with existing values, it should be removed and
      listed as a synonym for the existing value.

      If a metadata name is registered in the "proposed" state for a period of a month or more
      without being used or specified, then it may be removed from the registry.

      If a metadata name is added with the "proposed" status and found to be redundant with existing
      values, it should be removed and listed as a synonym for the existing value. If a metadata
      name is added with the "proposed" status and found to be harmful, then it should be changed to
      "discontinued" status.

      Anyone can change the status at any time, but should only do so in accordance with the
      definitions above.

  <div class="impl">
    Conformance checkers may use the information given on the WHATWG Wiki MetaExtensions page to
    establish if a value is allowed or not: values defined in this specification or marked as
    "proposed" or "ratified" must be accepted, whereas values marked as "discontinued" or not listed
    in either this specification or on the aforementioned page must be reported as invalid.
    Conformance checkers may cache this information (e.g., for performance reasons or to avoid the
    use of unreliable network connectivity).

    When an author uses a new metadata name not defined by either this specification or the Wiki
    page, conformance checkers should offer to add the value to the Wiki, with the details described
    above, with the "proposed" status.
  </div>

  Metadata names whose values are to be <a for="url">URLs</a> must not be proposed or accepted. Links must be
  represented using the <{link}> element, not the <{meta}> element.

<h5 id="pragma-directives">Pragma directives</h5>

  When the <dfn><code>http-equiv</code></dfn> attribute is specified on a <{meta}> element,
  the element is a pragma directive.

  The <code>http-equiv</code> attribute is an <a>enumerated attribute</a>. The following table lists
  the keywords defined for this attribute. The states given in the first cell of the rows with
  keywords give the states to which those keywords map. <span class="impl">Some of the keywords are
  non-conforming, as noted in the last column.</span>

  <table id="table-http-equiv">
    <thead>
      <tr>
        <th>State</th>
        <th>Keyword</th>
        <th>Notes</th>
      </tr>
    </thead>
    <tbody>
      <tr class="impl">
        <td><a state for="http-equiv" lt="content-language">Content Language</a></td>
        <td><code>content-language</code></td>
        <td>Non-conforming</td>
      </tr>
      <tr>
        <td><a state for="http-equiv" lt="content-type">Encoding declaration</a></td>
        <td><code>content-type</code></td>
        <td></td>
      </tr>
      <tr>
        <td><a state for="http-equiv" lt="default-style">Default style</a></td>
        <td><code>default-style</code></td>
        <td></td>
      </tr>
      <tr>
        <td><a state for="http-equiv" lt="refresh">Refresh</a></td>
        <td><code>refresh</code></td>
        <td></td>
      </tr>
      <tr class="impl">
        <td><a state for="http-equiv" lt="set-cookie">Cookie setter</a></td>
        <td><code>set-cookie</code></td>
        <td>Non-conforming</td>
      </tr>
    </tbody>
  </table>

  <div class="impl">
    When a <{meta}> element is <a for="document">inserted into the document</a>, if its
    <code>http-equiv</code> attribute is present and represents one of the above states, then the
    user agent must run the algorithm appropriate for that state, as described in the following
    list:
  </div>

  <div class="impl">
    : <dfn state for="http-equiv" lt="content-language">Content language state</dfn> (<code>http-equiv="content-language"</code>)
    ::
        <p class="note">
          This feature is non-conforming. Authors are encouraged to use the <{global/lang}>
          attribute instead.
        </p>

        This pragma sets the <dfn>pragma-set default language</dfn>. Until such a pragma is
        successfully processed, there is no <a>pragma-set default language</a>.

        1. If the <{meta}> element has no <code>content</code> attribute, then abort these
            steps.
        2. If the element's <code>content</code> attribute contains a U+002C COMMA character (,)
            then abort these steps.
        3. Let <var>input</var> be the value of the element's <code>content</code> attribute.
        4. Let <var>position</var> point at the first character of <var>input</var>.
        5. <a>Skip whitespace</a>.
        6. <a>Collect a sequence of characters</a> that are not <a>space characters</a>.
        7. Let <var>candidate</var> be the string that resulted from the previous step.
        8. If <var>candidate</var> is the empty string, abort these steps.
        9. Set the <a>pragma-set default language</a> to <var>candidate</var>.
            <p class="note">
              If the value consists of multiple space-separated tokens, tokens after the first are
              ignored.
            </p>

        <p class="note">
          This pragma is not the same as the HTTP <code>Content-Language</code> header of the same name.
          HTTP <code>Content-Language</code> values with more than one language tag will be rejected as invalid by this pragma.
          [[!HTTP]]
        </p>
  </div>

  : <dfn state for="http-equiv" lt="content-type|encoding declaration state">Encoding declaration state</dfn> (<code>http-equiv="content-type"</code>)
  :: The <a state for="http-equiv" lt="content-type">encoding declaration state</a> is just an alternative form of setting the
      <code>charset</code> attribute: it is a <a>character encoding declaration</a>.
      <span class="impl">This state's user agent requirements are all handled by the parsing section
      of the specification.</span>

      For <{meta}> elements with an <code>http-equiv</code> attribute in the <a state for="http-equiv">encoding declaration state</a>, the <code>content</code> attribute must have a value that is an
      <a>ASCII case-insensitive</a> match for a string that consists of: the literal string
      "<code>text/html;</code>", optionally followed by any number of <a>space characters</a>,
      followed by the literal string "<code>charset=</code>", followed by one of the <a lt="character encoding">labels</a>
      of the <a>character encoding</a> of the <a>character encoding declaration</a>.

      A document must not contain both a <{meta}> element with an <code>http-equiv</code>
      attribute in the <a state for="http-equiv">encoding declaration state</a> and a <{meta}> element with the
      <code>charset</code> attribute present.

      The <a state for="http-equiv" lt="content-type">encoding declaration state</a> may be used in <a>HTML documents</a> and in
      <a>XML Documents</a>. If the <a state for="http-equiv" lt="content-type">encoding declaration state</a> is used in
      <a>XML Documents</a>, the name of the <a>character encoding</a> must be an
      <a>ASCII case-insensitive</a> match for the string "<code>UTF-8</code>" (and  the document is
      therefore forced to use UTF-8 as its encoding).

      <p class="note">
        The <a state for="http-equiv" lt="content-type">encoding declaration state</a> has no effect in XML documents, and is only allowed in
        order to facilitate migration to and from XHTML.
      </p>

  : <dfn state for="http-equiv" lt="default-style">Default style state</dfn> (<code>http-equiv="default-style"</code>)
  :: This pragma sets the name of the default <a>alternative style sheet set</a>.
      <div class="impl">
        1. If the <{meta}> element has no <code>content</code> attribute, or if that
            attribute's value is the empty string, then abort these steps.
        2. Set the <a>preferred style sheet set</a> to the value of the element's
            <code>content</code> attribute. [[!CSSOM]]
      </div>

  : <dfn state for="http-equiv" lt="refresh">Refresh state</dfn> (<code>http-equiv="refresh"</code>)
  :: This pragma acts as timed redirect.
        1. If another <{meta}> element with an <code>http-equiv</code> attribute in the
            <a state for="http-equiv" lt="refresh">Refresh state</a> has already been successfully processed (i.e., when it was inserted
            the user agent processed it and reached the step labeled <i>end</i>), then abort
            these steps.
        2. If the <{meta}> element has no <code>content</code> attribute, or if that
            attribute's value is the empty string, then abort these steps.
        3. Let <var>input</var> be the value of the element's <code>content</code> attribute.
        4. Let <var>position</var> point at the first character of <var>input</var>.
        5. <a>Skip whitespace</a>.
        6. <a>Collect a sequence of characters</a> that are <a>ASCII digits</a>, and parse the
            resulting string using the <a>rules for parsing non-negative integers</a>. If the
            sequence of characters collected is the empty string, then no number will have been
            parsed; abort these steps. Otherwise, let <var>time</var> be the parsed number.
        7. <a>Collect a sequence of characters</a> that are <a>ASCII digits</a> and U+002E FULL STOP
            characters (.). Ignore any collected characters.
        8. Let <var>url</var> be the <{meta}> element's <a>node document</a>'s
            <a for="url">URL</a>.
        9. If <var>position</var> is past the end of <var>input</var>, jump to the step labeled
            <i>end</i>.
        10. If the character in <var>input</var> pointed to by <var>position</var> is not a U+003B
            SEMICOLON character (;), a U+002C COMMA character (,), or a <a>space character</a>, then
            abort these steps.
        11. <a>Skip whitespace</a>.
        12. If the character in <var>input</var> pointed to by <var>position</var> is a U+003B
            SEMICOLON character (;), a U+002C COMMA character (,), then advance <var>position</var>
            to the next character.
        13. <a>Skip whitespace</a>.
        14. If <var>position</var> is past the end of <var>input</var>, jump to the step labeled
            <i>end</i>.
        15. Let <var>url</var> be equal to the substring of <var>input</var> from the character at
            <var>position</var> to the end of the string.
        16. If the character in <var>input</var> pointed to by <var>position</var> is a U+0055 LATIN
            CAPITAL LETTER U character (U) or a U+0075 LATIN SMALL LETTER U character (u), then
            advance <var>position</var> to the next character. Otherwise, jump to the step labeled
            <i>skip quotes</i>.
        17. If the character in <var>input</var> pointed to by <var>position</var> is a U+0052 LATIN
            CAPITAL LETTER R character (R) or a U+0072 LATIN SMALL LETTER R character (r), then
            advance <var>position</var> to the next character. Otherwise, jump to the step labeled
            <var>Parse</var>.
        18. If the character in <var>input</var> pointed to by <var>position</var> is s U+004C LATIN
            CAPITAL LETTER L character (L) or a U+006C LATIN SMALL LETTER L character (l), then
            advance <var>position</var> to the next character. Otherwise, jump to the step labeled
            <var>Parse</var>.
        19. <a>Skip whitespace</a>.
        20. If the character in <var>input</var> pointed to by <var>position</var> is a U+003D
            EQUALS SIGN (=), then advance <var>position</var> to the next character. Otherwise, jump
            to the step step labeled <var>Parse</var>.
        21. <a>Skip whitespace</a>.
        22. <i>Skip quotes</i>: If the character in <var>input</var> pointed to by
            <var>position</var> is either a U+0027 APOSTROPHE character (') or U+0022 QUOTATION MARK
            character ("), then let <var>quote</var> be that character, and advance
            <var>position</var> to the next character. Otherwise, let <var>quote</var> be the empty
            string.
        23. Let <var>url</var> be equal to the substring of <var>input</var> from the character at
            <var>position</var> to the end of the string.
        24. If <var>quote</var> is not the empty string, and there is a character in <var>url</var>
            equal to <var>quote</var>, then truncate <var>url</var> at that character, so that it
            and all subsequent characters are removed.
        25. <var>Parse</var>: <a>Parse</a> <var>url</var> relative to the <{meta}> element's
            <a>node document</a>. If that fails, abort these steps. Otherwise, let
            <var>urlRecord</var> be the <a>resulting URL record</a>.
        26. <i>End</i>: Perform one or more of the following steps:
            * After the refresh has come due (as defined below), if the user has not canceled the
                redirect and if the <{meta}> element's <a>node document</a>'s <a>active
                sandboxing flag set</a> does not have the <a>sandboxed automatic features browsing
                context flag</a> set, <a>navigate</a> the {{Document}}'s
                <a>browsing context</a> to <var>urlRecord</var>, with <a>replacement enabled</a>,
                and with the {{Document}}'s <a>browsing context</a> as the
                <a>source browsing context</a>.

                For the purposes of the previous paragraph, a refresh is said to have come due as
                soon as the <em>later</em> of the following two conditions occurs:
                * At least <var>time</var> seconds have elapsed since the document has
                    <a>completely loaded</a>, adjusted to take into account user or user agent
                    preferences.
                * At least <var>time</var> seconds have elapsed since the <{meta}> element
                    was <a for="document">inserted into the document</a>, adjusted to take into account
                    user or user agent preferences.
            * Provide the user with an interface that, when selected, <a>navigates</a> a
                <a>browsing context</a> to <var>urlRecord</var>, with the {{Document}}'s
                <a>browsing context</a> as the <a>source browsing context</a>.
            * Do nothing.

            In addition, the user agent may, as with anything, inform the user of any and all
            aspects of its operation, including the state of any timers, the destinations of any
            timed redirects, and so forth.

      For <{meta}> elements with an <code>http-equiv</code> attribute in the
      <a state for="http-equiv" lt="refresh">Refresh state</a>, the <code>content</code> attribute must have a value consisting either
      of:

      * just a <a>valid non-negative integer</a>, or
      * a <a>valid non-negative integer</a>, followed by a U+003B SEMICOLON character (;), followed
        by one or more <a>space characters</a>, followed by a substring that is an
        <a>ASCII case-insensitive</a> match for the string "<code>URL</code>", followed by a U+003D
        EQUALS SIGN character (=), followed by a <a>valid URL</a> that does not start with a literal
        U+0027 APOSTROPHE (') or U+0022 QUOTATION MARK (") character.

      In the former case, the integer represents a number of seconds before the page is to be
      reloaded; in the latter case the integer represents a number of seconds before the page is to
      be replaced by the page at the given <a for="url">URL</a>.

      <div class="example">
        A news organization's front page could include the following markup in the page's
        <{head}> element, to ensure that the page automatically reloads from the server
        every five minutes:

        <pre highlight="html">&lt;meta http-equiv="Refresh" content="300"&gt;</pre>
      </div>

      <div class="example">
        A sequence of pages could be used as an automated slide show by making each page refresh to
        the next page in the sequence, using markup such as the following:

        <pre highlight="html">&lt;meta http-equiv="Refresh" content="20; URL=page4.html"&gt;</pre>
      </div>

    : <dfn state for="http-equiv" lt="set-cookie">Cookie setter</dfn> (<code>http-equiv="set-cookie"</code>)
    :: This pragma sets an HTTP cookie. [[!COOKIES]]

        It is non-conforming. Real HTTP headers should be used instead.

        1. If the <{meta}> element has no <code>content</code> attribute, or if that
            attribute's value is the empty string, then abort these steps.
        2. Act as if <a>receiving a set-cookie-string</a> for <a>the document's address</a> via a
            "non-HTTP" API, consisting of the value of the element's <code>content</code> attribute
            <a>encoded as UTF-8</a>. [[!COOKIES]] [[!ENCODING]]

    : <dfn state for="http-equiv">Content security policy state</dfn> (<code>http-equiv="content-security-policy"</code>)
    :: This pragma <a lt="enforced">enforces</a> a <a>Content Security Policy</a> on a {{Document}}.
        [[CSP3]]

        1. If the <{meta}> element is not a child of a <{head}> element, abort these steps.
        2. If the <{meta}> element has no <{meta/content}> attribute, or if that attribute's value
            is the empty string, then abort these steps.
        3. Let <var>policy</var> be the result of executing Content Security Policy's
            <a>parse a serialized Content Security Policy</a> algorithm on the <{meta}> element's
            <{meta/content}> attribute's value.
        4. Remove all occurrences of the <a><code>report-uri</code></a>,
            <a><code>frame-ancestors</code></a>, and <a><code>sandbox</code></a> <a>directives</a>
            from <var>policy</var>.
        5. <a>Enforce the policy</a> <var>policy</var>.

        For <{meta}> elements with an <{meta/http-equiv}> attribute in the
        <a state for="http-equiv">Content security policy state</a>, the <{meta/content}> attribute
        must have a value consisting of a <a>valid Content Security Policy</a>, but must not contain
        any <a><code>report-uri</code></a>, <a><code>frame-ancestors</code></a>, or
        <a><code>sandbox</code></a> <a>directives</a>. The <a>Content Security Policy</a> given in
        the <{meta/content}> attribute will be <a>enforced</a> upon the current document. [[CSP3]]

        <div class="example">
        A page might choose to mitigate the risk of cross-site scripting attacks by preventing the
        execution of inline JavaScript, as well as blocking all plugin content, using a policy such
        as the following:
          <pre highlight="html">
            &lt;meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none'">
          </pre>
        </div>

  There must not be more than one <{meta}> element with any particular state in the
  document at a time.

<h5 id="other-pragma-directives">Other pragma directives</h5>

  <dfn>Extensions to the predefined set of pragma directives</dfn> may, under certain conditions, be
  registered in the <a>WHATWG Wiki PragmaExtensions page</a>. [[WHATWGWIKI]]

  Such extensions must use a name that is identical to an HTTP header registered in the Permanent
  Message Header Field Registry, and must have behavior identical to that described for the HTTP
  header. [[!IANAPERMHEADERS]]

  Pragma directives corresponding to headers describing metadata, or not requiring specific user
  agent processing, must not be registered; instead, use <a>metadata names</a>. Pragma directives
  corresponding to headers that affect the HTTP processing model (e.g., caching) must not be
  registered, as they would result in HTTP-level behavior being different for user agents that
  implement HTML than for user agents that do not.

  Anyone is free to edit the <a>WHATWG Wiki PragmaExtensions page</a> at any time to add a pragma directive
  satisfying these conditions. Such registrations must specify the following information:

  : Keyword
  :: The actual name being defined. The name must match a previously-registered HTTP name with the
      same requirements.

  : Brief description
  :: A short non-normative description of the purpose of the pragma directive.

  : Specification
  :: A link to the specification defining the corresponding HTTP header.

  <div class="impl">
    Conformance checkers must use the information given on the <a>WHATWG Wiki PragmaExtensions page</a> to
    establish if a value is allowed or not: values defined in this specification or listed on the
    aforementioned page must be accepted, whereas values not listed in either this specification or
    on the aforementioned page must be rejected as invalid. Conformance checkers may cache this
    information (e.g., for performance reasons or to avoid the use of unreliable network
    connectivity).
  </div>

<h5 id="specifying-the-documents-character-encoding">Specifying the document's character encoding</h5>

  A <dfn>character encoding declaration</dfn> is a mechanism by which the <a>character encoding</a>
  used to store or transmit a document is specified.

  The following restrictions apply to <a>character encoding declarations</a>:

  * The character encoding name given must be an <a>ASCII case-insensitive</a> match for one of the
      <a lt="character encoding">labels</a> of the <a>character encoding</a> used to serialize the file. [[!ENCODING]]
  * The character encoding declaration must be serialized without the use of
      <a>character references</a> or character escapes of any kind.
  * The element containing the character encoding declaration must be serialized completely
      within <dfn>the first 1024 bytes</dfn> of the document.

  In addition, due to a number of restrictions on <{meta}> elements, there can only be one
  <code>meta</code>-based character encoding declaration per document.

  If an <a>HTML document</a> does not start with a BOM, and its <a>encoding</a> is not explicitly
  given by <a>Content-Type metadata</a>, and the document is not <a lt="iframe srcdoc document">an <code>iframe</code>
  <code>srcdoc</code> document</a>, then the character encoding used must be an
  <a>ASCII-compatible encoding</a>, and the encoding must be specified using a <code>meta</code>
  element with a <code>charset</code> attribute or a <{meta}> element with an
  <code>http-equiv</code> attribute in the <a state for="http-equiv" lt="content-type">encoding declaration state</a>.

  <p class="note">
    A character encoding declaration is required (either in the <a>Content-Type metadata</a> or
    explicitly in the file) even if the encoding is US-ASCII, because a character encoding is needed
    to process non-ASCII characters entered by the user in forms, in URLs generated by scripts, and
    so forth.
  </p>

  If the document is <a lt="iframe srcdoc document">an <code>iframe</code> <code>srcdoc</code> document</a>, the document must
  not have a <a>character encoding declaration</a>. (In this case, the source is already decoded,
  since it is part of the document that contained the <{iframe}>.)

  If an <a>HTML document</a> contains a <{meta}> element with a <code>charset</code>
  attribute or a <{meta}> element with an <code>http-equiv</code> attribute in the
  <a state for="http-equiv" lt="content-type">encoding declaration state</a>, then the character encoding used must be an
  <a>ASCII-compatible encoding</a>.

  Authors should use <a>UTF-8</a>. Conformance checkers may advise authors against using legacy encodings.
  [[!ENCODING]]

  Authoring tools should default to using <a>UTF-8</a> for newly-created documents. [[!ENCODING]]

  Authors must not use encodings that are not defined in the WHATWG Encoding standard. Additionally,
  authors should not use <a>ISO-2022-JP</a>.  [[!ENCODING]]

  <p class="note">
    Some encodings that are not defined in the WHATWG Encoding standard use bytes in the range 0x20
    to 0x7E, inclusive, to encode characters other than the corresponding characters in the range
    U+0020 to U+007E, inclusive, and represent a potential security vulnerability: A user agent
    might end up interpreting supposedly benign plain text content as HTML tags and JavaScript.
  </p>

  <p class="note">
    Using non-UTF-8 encodings can have unexpected results on form submission and URL encodings,
    which use the <a>document's character encoding</a> by default.
  </p>

  In XHTML, the XML declaration should be used for inline character encoding information, if
  necessary.

  <div class="example">
    In HTML, to declare that the character encoding is UTF-8, the author could include the following
    markup near the top of the document (in the <{head}> element):

    <pre highlight="html">&lt;meta charset="utf-8"&gt;</pre>

    In XML, the XML declaration would be used instead, at the very top of the markup:

    <pre highlight="html">&lt;?xml version="1.0" encoding="utf-8"?&gt;</pre>
  </div>

<h4 id="the-style-element">The <dfn element><code>style</code></dfn> element</h4>

  <dl class="element">
    <dt><a lt="Categories">카테고리</a>:</dt>
    <dd><a>Metadata content</a>.</dd>
    <dt><a lt="Contexts in which this element can be used">이 요소(element)가 사용될 수 있는 컨텍스트</a>:</dt>
    <dd>
      Where <a>metadata content</a> is expected.
    </dd>
    <dd>
      In a <{noscript}> element that is a
      child of a <{head}> element.
    </dd>
    <dt><a lt="Content model">콘텐트 모델</a>:</dt>
    <dd>
      Depends on the value of the <code>type</code> attribute, but must match requirements described
      in prose below.
    </dd>
    <dt><a lt="Tag omission in text/html">text/html에서 태그 생략</a>:</dt>
    <dd>Neither tag is omissible.</dd>
    <dt><a lt="Content attributes">콘텐트 속성(attribute)들</a>:</dt>
    <dd><a>Global attributes</a></dd>
    <dd><code>media</code> — Applicable media</dd>
    <dd><{style/nonce}> - Cryptographic nonce used in <em>Content Security Policy</em> checks [[CSP3]]</dd>
    <dd><code>type</code> — Type of embedded resource</dd>
    <dd>
      Also, the <{style/title}> attribute has special semantics on this element: Alternative
      style sheet set name.
    </dd>
    <dt>허용된 <a href="#aria-role-attribute">ARIA 역할(role) 속성(attribute)</a> 값들:</dt>
    <dd>None</dd>
    <dt>허용된 <a href="#state-and-property-attributes">ARIA 상태(state)와 속성(property) 속성(attribute)들</a>:</dt>
    <dd><a lt="Global aria-* attributes">범용 aria-* 속성(attribute)들</a></dd>
    <dt><a lt="DOM interface">DOM 인터페이스</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl" dfn-for="HTMLStyleElement">
        interface HTMLStyleElement : HTMLElement {
          attribute DOMString media;
          attribute DOMString nonce;
          attribute DOMString type;
        };
        HTMLStyleElement implements LinkStyle;
      </pre>
    </dd>
  </dl>

  <p class="warning">There are no known native implementations of blocking the <{style}> element based on CSP3 directives. Therefore this feature should not be relied upon.</p>
  
  The <{style}> element allows authors to embed style information in their documents. The
  <{style}> element is one of several inputs to the styling processing model. The element
  does not <a>represent</a> content for the user.

  The <dfn element-attr for="style"><code>type</code></dfn> attribute gives the styling language. If the attribute is
  present, its value must be a <a>valid mime type</a> that designates a styling language. The
  <code>charset</code> parameter must not be specified. The default value for the <code>type</code>
  attribute, which is used if the attribute is absent, is "<code>text/css</code>". [[!RFC2318]]

  <div class="impl">
    When examining types to determine if they support the language, user agents must not ignore
    unknown MIME parameters — types with unknown parameters must be assumed to be unsupported. The
    <code>charset</code> parameter must be treated as an unknown parameter for the purpose of
    comparing <a>MIME types</a> here.
  </div>

  The <dfn element-attr for="style"><code>media</code></dfn> attribute says which media the styles apply to. The value must
  be a <a>valid media query list</a>. <span class="impl">The user agent must apply the styles when
  the <code>media</code> attribute's value <a>matches the environment</a> and the other relevant
  conditions apply, and must not apply them otherwise.</span>

  <div class="impl">
    <p class="note">
      The styles might be further limited in scope, e.g., in CSS with the use of <code>@media</code>
      blocks. This specification does not override such further restrictions or requirements.
    </p>
  </div>

  The default, if the <code>media</code> attribute is omitted, is "<code>all</code>", meaning that
  by default styles apply to all media.

  <p class="note">
    A <{style}> element is restricted to
    appearing in the <{head}> of the document.
  </p>

  The <dfn element-attr for="style"><code>nonce</code></dfn> attribute represents a cryptographic
  nonce ("number used once") which can be used by <a>Content Security Policy</a> to determine
  whether or not the style specified by an element will be applied to the document. The value is
  text. [[CSP3]]

  The <dfn element-attr for="style"><code>title</code></dfn> attribute on <{style}> elements defines
  <a>alternative style sheet sets</a>. If the <{style}> element has no <code>title</code>
  attribute, then it has no title; the <code>title</code> attribute of ancestors does not apply to
  the <{style}> element. [[!CSSOM]]

  <p class="note">
    The <code>title</code> attribute on <{style}> elements, like the <code>title</code>
    attribute on <{link}> elements, differs from the global <code>title</code> attribute in
    that a <code>style</code> block without a title does not inherit the title of the parent
    element: it merely has no title.
  </p>

  The {{Node/textContent}} of a <{style}> element must match the <code>style</code>
  production in the following ABNF, the character set for which is Unicode. [[!ABNF]]

  <pre data-highlight="abnf">
    style         = no-c-start *( c-start no-c-end c-end no-c-start )
    no-c-start    = &lt; any string that doesn't contain a substring that matches c-start &gt;
    c-start       = "&lt;!--"
    no-c-end      = &lt; any string that doesn't contain a substring that matches c-end &gt;
    c-end         = "--&gt;"
  </pre>

  <hr />

  <div class="impl">
    The user agent must run the <dfn>update a <code>style</code> block</dfn> algorithm that
    applies for the style sheet language specified by the <{style}> element's <{style/type}>
    attribute, passing it the element's <dfn>style data</dfn>, whenever one of the following
    conditions occur:

    * the element is popped off the <a>stack of open elements</a> of an <a>HTML parser</a> or
        <a>XML parser</a>,
    * the element is not on the <a>stack of open elements</a> of an <a>HTML parser</a> or
        <a>XML parser</a>, and it is <a for="document">inserted into a document</a> or
        <a for="document">removed from a document</a>,
    * the element is not on the <a>stack of open elements</a> of an <a>HTML parser</a> or
        <a>XML parser</a>, and one of its child nodes is modified by a script,

    For styling languages that consist of pure text (as opposed to XML), a <code>style</code>
    element's <a>style data</a> is the concatenation of the contents of all the <code>Text</code>
    nodes that are children of the <{style}> element (not any other nodes such as comments
    or elements), in <a>tree order</a>. For XML-based styling languages, the <a>style data</a>
    consists of all the child nodes of the <{style}> element.

    The <a>update a <code>style</code> block</a> algorithm for CSS (<code>text/css</code>) is as
    follows:

    1. Let <var>element</var> be the <{style}> element.
    2. If <var>element</var> has an <a spec="cssom">associated CSS style sheet</a>,
        <a spec="cssom" lt="remove a CSS style sheet">remove the CSS style sheet</a> in question.
    3. If <var>element</var> is not <a>in a <code>Document</code></a>, then abort
        these steps.
    4. If the <a>Should element's inline behavior be blocked by Content Security Policy?</a>
        algorithm returns "<code>Blocked</code>" when executed upon the <{style}> element,
        "<code>style</code>", and the <{style}> element's <a>style data</a>, then abort these steps.
        [[CSP3]]
    5. <a spec="cssom">create a CSS style sheet</a> with the following properties:

        : <{style/type}>
        :: <code>text/css</code>
        : <a>owner node</a>
        :: <var>element</var>
        : <{style/media}>
        :: The <code>media</code> attribute of <var>element</var>.
            <p class="note">
              This is a reference to the (possibly absent at this time) attribute, rather than a
              copy of the attribute's current value. The CSSOM specification defines what happens
              when the attribute is dynamically set, changed, or removed.
            </p>
        : <{style/title}>
        :: The <{style/title}> attribute of <var>element</var>.
            <p class="note">Again, this is a <em>reference</em> to the attribute.</p>
        : <a>alternate flag</a>
        :: Unset.
        : <a>origin-clean flag</a>
        :: Set.
        : <a>parent CSS style sheet</a>
        : <a>owner CSS rule</a>
        :: null
        : <a>disabled flag</a>
        :: Left at its default value.
        : <a>CSS rules</a>
        :: Left uninitialized.

    This specification does not define any other styling language's
    <i>update a <code>style</code> block</i> algorithm.

    Once the attempts to obtain the style sheet's <a>critical subresources</a>, if any, are
    complete, or, if the style sheet has no <a>critical subresources</a>, once the style sheet has
    been parsed and processed, the user agent must, if the loads were successful or there were none,
    <a>queue a task</a> to <a>fire a simple event</a> named <code>load</code> at the
    <{style}> element, or, if one of the style sheet's <a>critical subresources</a> failed
    to completely load for any reason (e.g., DNS error, HTTP 404 response, a connection being
    prematurely closed, unsupported Content-Type), <a>queue a task</a> to <a>fire a simple event</a>
    named <code>error</code> at the <{style}> element. Non-network errors in processing the
    style sheet or its subresources (e.g., CSS parse errors, PNG decoding errors) are not failures
    for the purposes of this paragraph.

    The <a>task source</a> for these <a>tasks</a> is the <a>DOM manipulation task source</a>.

    The element must <a>delay the load event</a> of the element's <a>node document</a> until all the
    attempts to obtain the style sheet's <a>critical subresources</a>, if any, are complete.
  </div>

  <p class="note">
    This specification does not specify a style system, but CSS is expected to be supported by most
    Web browsers. [[!CSS-2015]]
  </p>

  <div class="impl">
    The <dfn attribute for="HTMLStyleElement"><code>media</code></dfn>,
    <dfn attribute for="HTMLStyleElement"><code>nonce</code></dfn>, and
    <dfn attribute for="HTMLStyleElement"><code>type</code></dfn>
    IDL attributes must <a>reflect</a> the respective content
    attributes of the same name.
  </div>

  The <code>LinkStyle</code> interface is also implemented by this element. [[!CSSOM]]

  <div class="example">
    The following document has its stress emphasis styled as bright red text rather than italics
    text, while leaving titles of works and Latin words in their default italics. It shows how using
    appropriate elements enables easier restyling of documents.

    <pre highlight="html">&lt;!DOCTYPE html&gt;
      &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;My favorite book&lt;/title&gt;
          &lt;style&gt;
            body { color: black; background: white; }
            em { font-style: normal; color: red; }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;p&gt;My &lt;em&gt;favorite&lt;/em&gt; book of all time has &lt;em&gt;got&lt;/em&gt; to be
          &lt;cite&gt;A Cat's Life&lt;/cite&gt;. It is a book by P. Rahmel that talks
          about the &lt;i lang="la"&gt;Felis Catus&lt;/i&gt; in modern human society.&lt;/p&gt;
        &lt;/body&gt;
      &lt;/html&gt;</pre>
  </div>

  <h4 id="interactions-of-styling-and-scripting">Interactions of styling and scripting</h4>

  Style sheets, whether added by a <{link}> element, a <{style}> element, an
  <code>&lt;?xml-stylesheet?&gt;</code> PI, an HTTP <code>Link</code> header, or some other
  mechanism, have a <dfn>style sheet ready</dfn> flag, which is initially unset.

  When a style sheet is ready to be applied, its <a>style sheet ready</a> flag must be set. If the
  style sheet referenced no other resources (e.g., it was an internal style sheet given by a
  <{style}> element with no <code>@import</code> rules), then the style rules must be
  <a>immediately</a> made available to script; otherwise, the style rules must only be made
  available to script once the <a>event loop</a> reaches its <i>update the rendering</i> step.

  A style sheet in the context of the {{Document}} of an <a>HTML parser</a> or <a>XML parser</a> is
  said to be <dfn>a style sheet that is blocking scripts</dfn> if the element was created by that
  {{Document}}'s parser, and the element is either a <{style}> element or a <{link}> element that
  was an <a href="#link-type-stylesheet">external resource link</a> when the element was created by
  the parser, and the element's style sheet was enabled when the element was created by the parser,
  and the element's <a>style sheet ready</a> flag is not yet set, and, the last time the
  <a>event loop</a> reached step 1, the element was in that {{Document}}, and the user
  agent hasn't given up on that particular style sheet yet. A user agent may give up on a style
  sheet at any time.

  <p class="note">
    Giving up on a style sheet before the style sheet loads, if the style sheet eventually does
    still load, means that the script might end up operating with incorrect information. For
    example, if a style sheet sets the color of an element to green, but a script that inspects
    the resulting style is executed before the sheet is loaded, the script will find that the
    element is black (or whatever the default color is), and might thus make poor choices (e.g.,
    deciding to use black as the color elsewhere on the page, instead of green). Implementors have
    to balance the likelihood of a script using incorrect information with the performance impact
    of doing nothing while waiting for a slow network request to finish.
  </p>

  A {{Document}} <dfn lt="have a style sheet that is blocking scripts|has a style sheet that is blocking scripts">has a style sheet that is blocking scripts</dfn> if there is either
  <a>a style sheet that is blocking scripts</a> in the context of that {{Document}}, or
  if that {{Document}} is in a <a>browsing context</a> that has a
  <a>parent browsing context</a>, and the <a>active document</a> of that
  <a>parent browsing context</a> itself <a>has a style sheet that is blocking scripts</a>.

  A {{Document}} <dfn>has no style sheet that is blocking scripts</dfn> if it does not
  <a>have a style sheet that is blocking scripts</a> as defined in the previous paragraph.

</section>
