<section>

<h3 id="document-metadata">문서 메타데이터</h3>

<h4 id="the-head-element"><dfn element><code>head</code></dfn> 요소(element)</h4>

  <dl class="element">
    <dt><a lt="Categories">카테고리</a>:</dt>
    <dd>없음.</dd>
    <dt><a lt="Contexts in which this element can be used">이 요소(element)가 사용될 수 있는 컨텍스트</a>:</dt>
    <dd><{html}> 요소(element) 내 첫 번째 요소(element).</dd>
    <dt><a lt="Content model">콘텐트 모델</a>:</dt>
    <dd>
      문서가 <a lt="iframe srcdoc document"><code>iframe</code> <code>srcdoc</code> 문서</a>이거나 
      제목(title) 정보가 상위 프로토콜에서 사용 가능하다면: <a element for="html"><code>title</code></a> 
      요소(element)가 한 개를 초과하지 않고 <{base}> 요소(element)가 한 개를 초과하지 않는, 
      <a lt="metadata content">메타데이터 콘텐트</a>의 0개 이상의 요소(element).
    </dd>
    <dd>
      그렇지 않으면: 정확히 하나가 <a element for="html"><code>title</code></a> 요소(element)와
      <{base}> 요소(element)가 한 개를 초과하지 않는, <a lt="metadata content">메타데이터 콘텐트</a>의 
      한 개 이상의 요소(element).
    </dd>
    <dt><a lt="Tag omission in text/html">text/html에서 태그 생략</a>:</dt>
    <dd>
      <{head}> 요소(element)의 <a lt="start tag">시작 태그</a>는 요소(element)가 비어있거나 <{head}>
      요소(element) 내의 첫 번째 것이 요소(element)라면 생략될 수 있습니다.
    </dd>
    <dd>
      <{head}> 요소(element)의 <a lt="end tag">종료 태그</a>는 <{head}> 요소(element)에 <a lt="space character">공백 문자</a>나
      <a lt="comment">주석</a>이 즉시 따르지 않는다면 생략될 수 있습니다.
    </dd>
    <dt><a lt="Content attributes">콘텐트 속성(attribute)들</a>:</dt>
    <dd><a lt="Global attributes">범용 속성(attribute)들</a></dd>
    <dt>허용된 <a href="#aria-role-attribute">ARIA 역할(role) 속성(attribute)</a> 값들:</dt>
    <dd>없음</dd>
    <dt>허용된 <a href="#state-and-property-attributes">ARIA 상태(state)와 속성(property) 속성(attribute)들</a>:</dt>
    <dd><a lt="Global aria-* attributes">범용 aria-* 속성(attribute)들</a></dd>
    <dt><a lt="DOM interface">DOM 인터페이스</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl" dfn-for="HTMLHeadElement">
        interface HTMLHeadElement : HTMLElement {};
      </pre>
    </dd>
  </dl>

  <{head}> 요소(element)는 {{Document}}에 대한 메타데이터의 컬렉션을 <a lt="represents">나타냅니다</a>.

  <div class="example">
    <{head}> 요소(element) 내 메타데이터의 컬렉션은 많거나 적을 수 있습니다. 여기 매우 짧은 것의 
    예가 있습니다:

    <pre highlight="html">
      &lt;!doctype html>
      &lt;html>
        &lt;head>
          &lt;title>A document with a short head&lt;/title>
        &lt;/head>
        &lt;body>
          ...
    </pre>

    여기 긴 것의 예가 있습니다:

    <pre highlight="html">
      &lt;!DOCTYPE HTML>
        &lt;HTML>
        &lt;HEAD>
          &lt;META CHARSET="UTF-8">
          &lt;BASE HREF="https://www.example.com/">
          &lt;TITLE>An application with a long head&lt;/TITLE>
          &lt;LINK REL="STYLESHEET" HREF="default.css">
          &lt;LINK REL="STYLESHEET ALTERNATE" HREF="big.css" TITLE="Big Text">
          &lt;SCRIPT SRC="support.js">&lt;/SCRIPT>
          &lt;META NAME="APPLICATION-NAME" CONTENT="Long headed application">
        &lt;/HEAD>
        &lt;BODY>
          ...
    </pre>
  </div>

  <p class="note">
    <a element for="html"><code>title</code></a> 요소(element)는 대부분 상황에서 요구된 자식이지만, 
    상위 레벨 프로토콜이 제목(title) 정보를 제공하는 경우, 예를 들어 HTML이 이메일 작성 서식으로 
    사용되는 경우 이메일의 제목 줄에, <a element for="html"><code>title</code></a> 요소(element)는
    생략 될 수 있습니다.
  </p>

  <p class="note">
    처음 1024바이트 내에서 <a lt="character encoding declaration">문자 인코딩 선언</a>의 적절한 감지를
    허용하기 위해 <{head}> 요소(element)에 정의된 속성(attribute)들과 그 값들의 사용을 최소한으로
    유지하는 것이 권장됩니다.
  </p>

<h4 id="the-title-element"><dfn element><code>title</code></dfn> 요소(element)</h4>

  <dl class="element">
    <dt><a lt="Categories">카테고리</a>:</dt>
    <dd><a lt="Metadata content">메타데이터 콘텐트</a>.</dd>
    <dt><a lt="Contexts in which this element can be used">이 요소(element)가 사용될 수 있는 컨텍스트</a>:</dt>
    <dd>다른 <a element for="html"><code>title</code></a> 요소(element)를 포함하지 않는 <{head}>요소(element) 안.</dd>
    <dt><a lt="Content model">콘텐트 모델</a>:</dt>
    <dd><a lt="inter-element whitespace">요소(element) 간 여백</a>이 아닌 <a lt="Text">텍스트</a>.</dd>
    <dt><a lt="Tag omission in text/html">text/html에서 태그 생략</a>:</dt>
    <dd>어느 태그도 생략 가능하지 않습니다.</dd>
    <dt><a lt="Content attributes">콘텐트 속성(attribute)들</a>:</dt>
    <dd><a lt="Global attributes">범용 속성(attribute)들</a></dd>
    <dt>허용된 <a href="#aria-role-attribute">ARIA 역할(role) 속성(attribute)</a> 값들:</dt>
    <dd>없음</dd>
    <dt>허용된 <a href="#state-and-property-attributes">ARIA 상태(state)와 속성(property) 속성(attribute)들</a></a>:</dt>
    <dd><a lt="Global aria-* attributes">범용 aria-* 속성(attribute)들</a></dd>
    <dt><a lt="DOM interface">DOM 인터페이스</a>:</dt>
    <dd>
      <pre class="idl" data-hightlight="webidl" dfn-for="HTMLTitleElement">
        interface HTMLTitleElement : HTMLElement {
          attribute DOMString text;
        };
      </pre>
    </dd>
  </dl>

  <a element for="html"><code>title</code></a> 요소(element)는 문서의 제목(title)이나 이름을 
  <a lt="represents">나타냅니다</a>. 작성자는 문서가 문맥 밖에서, 예를 들어 사용자의 방문 기록이나 
  북마크에 혹은 검색 결과에 사용될 때 조차도 문서를 알아보게 하는 제목을 사용해야(should) 합니다. 
  문서의 첫 번째 제목(heading)은 문맥에서 벗어날 경우 혼자 있을 필요가 없기 때문에, 문서의 제목(title)은
  종종 문서의 첫 번째 제목(heading)과 다릅니다.

  문서 당 하나의 <a element for="html"><code>title</code></a> 요소(element)만 있어야(must) 합니다.

  <p class="note">
    {{Document}}가 제목을 가지 않는 것이 타당하다면, <code>title</code> 요소(element)는 아마도 요구 
    되지 않습니다. 요소(element)가 요구되는 경우의 설명에 대한 <{head}> 요소(element)의 콘텐트 모델을 
    참고하세요.
  </p>

  <dl class="domintro">
    <dt><var>title</var> . <code>text</code> [ = <var>value</var> ]</dt>
    <dd>
      <code>Text</code> 노드가 아닌 자식 노드들을 무시하여, 요소(element)의 콘텐트를 반환합니다.

      주어진 값으로 요소(element)의 자식을 바꾸기 위해, 설정 될 수 있습니다.
    </dd>
  </dl>

  <div class="impl">
    IDL 속성(attribute) <dfn attribute for="HTMLTitleElement"><code>text</code></dfn>는 
    <a lt="tree order">트리 순서</a>에 따라 <a element for="html"><code>title</code></a> 요소(element)의 
    자식인 (주석이나 요소(element) 같은 다른 노드들은 무시하여) 모든 <code>Text</code> 노드의 콘텐트의 
    연결을 반환해야(must) 합니다. 설정할 때, {{Node/textContent}} IDL 속성(attribute)과 동일한 
    방법으로 동작해야(must) 합니다.
  </div>

  <div class="example">
    여기 최상위 동일한 페이지에 사용될 수 있는 제목(heading)과 대조되는 적절한 제목의 몇 가지 예가 
    있습니다.

    <pre highlight="html">
      &lt;title>Introduction to The Mating Rituals of Bees&lt;/title>
      ...
      &lt;h1>Introduction&lt;/h1>
      &lt;p>This companion guide to the highly successful
      &lt;cite>Introduction to Medieval Bee-Keeping&lt;/cite> book is...
    </pre>

    다음 페이지는 동일한 사이트의 일부입니다. 첫 번째 제목(heading)이 독자가 문맥이 무엇인지 알고
    따라서 춤이 살사인지 알츠인지 궁금해하지 않는다고 가정하면서 제목(title)이 주제를 분명하게 
    설명하는 방법에 주목하세요:

    <pre highlight="html">
      &lt;title>Dances used during bee mating rituals&lt;/title>
      ...
      &lt;h2>The Dances&lt;/h2>
    </pre>
  </div>

  문서의 제목(title)로 사용하기 위한 문자열은 <code>document.title</code> IDL 속성(attribute)에 의해
  주어집니다.

  <div class="impl">
    유저 에이전트들은 유저 인터페이스에서 문서로 참조할 때 문서의 제목(title)을 사용해야(should) 합니다.
    <a element for="html"><code>title</code></a> 요소(element)의 콘텐트가 이 방법으로 사용되는 경우,
    그 <a element for="html"><code>title</code></a> 요소(element)의 <a lt="the directionality">방향성</a>은
    유저 인터페이스에서 문서의 제목(title)의 방향성을 설정하는데 사용되어야(should) 합니다.
  </div>

<h4 id="the-base-element"><dfn element><code>base</code></dfn> 요소(element)</h4>

  <dl class="element">
    <dt><a lt="Categories">카테고리</a>:</dt>
    <dd><a lt="Metadata content">메타데이터 콘텐트</a>.</dd>
    <dt><a lt="Contexts in which this element can be used">이 요소(element)가 사용될 수 있는 컨텍스트</a>:</dt>
    <dd>다른 <{base}> 요소(element)들을 포함하지 않는 <{head}> 요소(element) 안.</dd>
    <dt><a lt="Content model">콘텐트 모델</a>:</dt>
    <dd><a lt="Nothing">없음</a>.</dd>
    <dt><a lt="Tag omission in text/html">text/html에서 태그 생략</a>:</dt>
    <dd><a lt="end tag">종료 태그</a> 없음.</dd>
    <dt><a lt="Content attributes">콘텐트 속성(attribute)들</a>:</dt>
    <dd><a lt="Global attributes">범용 속성(attribute)들</a></dd>
    <dd><code>href</code> — <a lt="Document base URL">문서 기본 URL</a></dd>
    <dd>
      <code>target</code> — <a lt="hyperlink">하이퍼링크</a> <a lt="navigation">탐색(navigation)</a>과 
      [[#forms-form-submission]]에 대한 기본 <a lt="browsing context">브라우징 컨텍스트</a>
    </dd>
    <dt>허용된 <a href="#aria-role-attribute">ARIA 역할(role) 속성(attribute)</a> 값들:</dt>
    <dd>없음</dd>
    <dt>허용된 <a href="#state-and-property-attributes">ARIA 상태(state)와 속성(property) 속성(attribute)들</a>:</dt>
    <dd><a lt="Global aria-* attributes">범용 aria-* 속성(attribute)들</a>.</dd>
    <dt><a lt="DOM interface">DOM 인터페이스</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl" dfn-for="HTMLBaseElement">
        interface HTMLBaseElement : HTMLElement {
          attribute DOMString href;
          attribute DOMString target;
        };
      </pre>
    </dd>
  </dl>

  <{base}> 요소(element)는 작성자가 <a lt="parsing relative URLs">상대 URL들 해석</a>의 목적에 대한
  <a lt="document base URL">문서 기본 URL</a>과 <a lt="following hyperlinks">하이퍼링크들을 따라가는 것</a>의
  목적에 대한 기본 <a lt="browsing context">브라우징 컨텍스트</a>의 이름을 명시하는 것을 허용합니다.
  요소(element)는 이 정보를 넘어 어떤 컨텐트도 <a lt="represent">나타내지</a> 않습니다.

  문서 당 하나의 <{base}> 요소(element)만 있어야(must) 합니다.

  <{base}> 요소(element)는 <{base/href}> 속성(attribute)이나 <code>target</code> 속성(attribute), 
  혹은 둘 모두를 가져야(must) 합니다.

  <dfn element-attr for="base"><code>href</code></dfn> 콘텐트 속성(attribute)이 명시되었다면, 이 
  속성(attribute)은 <a lt="valid URL potentially surrounded by spaces">유효한 잠정적으로 공백으로 
  둘러 싸일 수 있는 URL</a>을 포함해야(must) 합니다.

  <{base}> 요소(element)가 <{base/href}> 속성(attribute)을 가진다면 <{base}> 요소(element)는 <{html}> 
  요소를 제외하고 <a for="url" lt="URLs">URL들</a>을 취하는 것으로 정의된 속성을 가지는 트리 내의 
  다른 요소들(element) 앞에 와야(must) 합니다.

  <div class="impl">
    <p class="note">
      <{base/href}> 속성(attribute)들을 가진 여러 개의 <{base}> 요소(element)들이 있다면, 첫 번째를
      제외하고 모두 무시됩니다.
    </p>
  </div>

  <dfn element-attr for="base"><code>target</code></dfn> 속성(attribute)가 명시되었다면, 이 속성은 
  {{Document}}의 <a lt="hyperlinks">하이퍼링크</a>들과 <a lt="forms">양식들</a>이 
  <a lt="navigation">탐색(navigation)</a>을 야기하는 경우 어느 
  <a lt="browsing context">브라우징 컨텍스트</a>가 기본으로 사용되는지를 명시하는 
  <a lt="valid browsing context name or keyword">유효한 브라우징 컨텍스트 이름이나 키워드</a>를 
  포함해야(must) 합니다.

  <{base}> 요소(element)가 <code>target</code> 속성(attribute)을 가진다면 <{base}> 요소(element)는 
  elements in the tree that represent <a lt="hyperlinks">하이퍼링크들</a>을 나타내는 트리 내 모든 
  요소(element)들 앞에 와야(must) 합니다.

  <div class="impl">
    <p class="note">
      <code>target</code> 속성(attribute)들을 가진 여러 개의 <{base}> 요소(element)들이 있다면, 첫 번째를
      제외하고 모두 무시됩니다.
    </p>

    특정 {{Document}}의 <{base/href}> 콘텐트 속성(attribute)을 가진 첫 번째 <{base}> 요소(element)인
    <{base}> 요소(element)는 <dfn lt="frozen base URL">고정(frozen) 기본 URL</dfn>을 가집니다.
    <a lt="frozen base URL">고정(frozen) 기본 URL</a>은 다음 상황의 어떤 것이 발생될 때에든지
    요소(element)에 대해 <a lt="immediately">즉시</a> <a lt="set the frozen base URL">설정</a>되어야(must)
    합니다:

    * <{base}> 요소(element)가 그것의 {{Document}}에 <a lt="tree order">트리 순서</a>에 따라
        <{base/href}> 콘텐트 속성(attribute)을 가진 첫 번째 <{base}> 요소(element)가 되는 경우.
    * <{base}> 요소(element)가 그것의 {{Document}}에 <a lt="tree order">트리 순서</a>에 따라 
        <{base/href}> 콘텐트 속성(attribute)을 가진 첫 번째 <{base}> 요소(element)이고, 그것의
        <{base/href}>콘텐트 속성(attribute)이 변경되는 경우.

    요소(element) <var>element</var>에 대해, 
	<dfn lt="set the frozen base URL">고정(frozen) 기본 URL을 설정</dfn>하기 위해:

    1. <var>document</var>를 <var>element</var>의 <a lt="node document">노드 문서</a>로 둡니다.
    2. <var>urlRecord</var>를 <var>element</var>의 <var>document</var>의
        <a lt="fallback base URL">폴백 기본 URL</a>과 <var>document</var>의 
        <a lt="character encoding">문자 인코딩</a>을 가진 <{base/href}> 콘텐트 속성(attribute)의 값을 
        <a lt="parsing">해석</a>한 결과로 둡니다. (따라서 <{base}> 요소(element)는 자신에 의해 영향을 
        받지 않습니다.)
    3. <var>elements</var>의 <a lt="frozen base URL">고정(frozen) 기본 URL</a>을 <var>urlRecord</var>이
        실패하거나 <a lt="resulting URL record">결과 URL 레코드</a>에
        <a lt="Is base allowed for Document?">기본(base)이 문서에 대해 허용되는가?</a>를 실행 중이고
        <var>document</var>가 "<code>Blocked</code>"를 반환한다면 <var>document</var>의
        <a lt="fallback base URL">폴백 기본 URL</a>로 설정하고, 그렇지 않으면 <var>urlRecord</var>로
        설정합니다.

    <dfn attribute for="HTMLBaseElement"><code>href</code></dfn> IDL 속성(attribute)은 가져올 때
    다음 알고리즘을 수행한 결과를 반환해야(must) 합니다:

    1. <var>document</var>를 <var>element</var>의 <a lt="node document">노드 문서</a>로 둡니다.
    2. <var>url</var>을 <{base}> 요소(element)의 <{base/href}> 속성(attribute)의 값을 가진다면
        그 값으로 두고, 그렇지 않으면 빈 문자열로 둡니다.
    3. <var>urlRecord</var>를 <var>url</var>을 <var>document</var>의 
        <a lt="fallback base url">폴백 기본 URL</a>과 <var>document</var>의 
        <a lt="character encoding">문자 인코딩</a>을 가지고 <a lt="parsing">해석</a>한 결과로 둡니다. 
        (따라서, <{base}> 요소(element)는 다른 <{base}> 요소(element)나 자신에 의해서 영향을 받지 
        않습니다.)
    4. <var>urlRecord</var>이 실패라면, <var>url</var>을 반환합니다.
    5. <var>urlRecord</var>의 <a for="url" lt="serialization">직렬화</a>를 반환합니다.

    {{HTMLBaseElement/href}} IDL 속성(attribute)은 설정할 때 <{base/href}> 콘텐트 속성(attribute)을 
    주어진 새로운 값으로 설정해야(must) 합니다.

    <dfn attribute for="HTMLBaseElement"><code>target</code></dfn> IDL 속성(attribute)은 동일한 
    이름의 콘텐트 속성(attribute)을 <a lt="reflect">반영</a>해야(must) 합니다.
  </div>

  <div class="example">
    이 예제에서, <{base}> 요소(element)는 <a lt="document base URL">문서 기본 URL</a>을 설정하는데 
    사용됩니다:

    <pre highlight="html">
      &lt;!DOCTYPE html>
      &lt;html>
        &lt;head>
          &lt;title>This is an example for the &amp;lt;base&amp;gt; element&lt;/title>
          &lt;base href="https://www.example.com/news/index.html">
        &lt;/head>
        &lt;body>
          &lt;p>Visit the &lt;a href="archives.html">archives&lt;/a>.&lt;/p>
        &lt;/body>
      &lt;/html>
    </pre>

    위 예제에서 링크는 "<code>https://www.example.com/news/archives.html</code>"로의 링크가 될 것입니다.
  </div>

<h4 id="the-link-element"><dfn element><code>link</code></dfn> 요소(element)</h4>

  <dl class="element">
    <dt><a lt="Categories">카테고리</a>:</dt>
    <dd><a lt="Metadata content">메타데이터 콘텐트</a>.</dd>
    <dt><a lt="Contexts in which this element can be used">이 요소(element)가 사용될 수 있는 컨텍스트</a>:</dt>
    <dd><a lt="metadata content">메타데이터 콘텐트</a>가 기대되는 곳.</dd>
    <dd><{head}> 요소(element)의 자식인 <{noscript}> 요소(element) 안.</dd>
    <dt><a lt="Content model">콘텐트 모델</a>:</dt>
    <dd><a lt="Nothing">없음</a>.</dd>
    <dt><a lt="Tag omission in text/html">text/html에서 태그 생략</a>:</dt>
    <dd><a lt="end tag">종료 태그</a> 없음.</dd>
    <dt><a lt="Content attributes">콘텐트 속성(attribute)들</a>:</dt>
    <dd><a lt="Global attributes">범용 속성(attribute)들</a></dd>
    <dd><code>href</code> — <a lt="hyperlink">하이퍼링크</a>의 주소</dd>
    <dd><code>crossorigin</code> — 요소(element)가 교차출처(crossorigin) 요청들을 처리하는 방법</dd>
    <dd><{link/rel}> — 이 문서 (또는 하위 섹션/주제)에서 목적지 리소스로의 관계</dd>
    <dd><{link/rev}> — 목적지 리소스에서 이 문서 (또는 하위 섹션/주제)로의 <a lt="Reverse link">역방향 링크</a> 관계</dd>
    <dd><code>media</code> — 적용가능한 매체</dd>
    <dd><code>hreflang</code> — 연결된 리소스의 언어</dd>
    <dd><code>type</code> — 참조된 리소스의 유형에 대한 힌트</dd>
    <dd><code>sizes</code> — 아이콘의 (for <{link/rel}>="<code>icon</code>"에 대한) 크기</dd>
    <dd>
      또한, <{link/title}> 속성(attribute)은 이 요소(elemnt)에 특별한 의미(semantics)를 가집니다: 
      링크의 제목(title); 대체 스타일 시트의 이름을 설정합니다.
    </dd>
    <dt>허용된 <a href="#aria-role-attribute">ARIA 역할(role) 속성(attribute)</a> 값들:</dt>
    <dd><a><code>link</code></a> (기본 값 - <a lt="do not set"><em>설정 하지 마세요</em></a>).</dd>
    <dt>허용된 <a href="#state-and-property-attributes">ARIA 상태(state)와 속성(property) 속성(attribute)들</a>:</dt>
    <dd><a lt="Global aria-* attributes">범용 aria-* 속성(attribute)들</a></dd>
    <dd><a href="#allowed-aria-roles-states-and-properties">허용된 역할(role)들에 적용 가능한</a> 모든 <code>aria-*</code> 속성(attribute)들.</dd>
    <dd><code>role</code> 값에 대한 </dd>
    <dt><a lt="DOM interface">DOM 인터페이스</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl" dfn-for="HTMLLinkElement">
        interface HTMLLinkElement : HTMLElement {
          attribute DOMString href;
          attribute DOMString? crossOrigin;
          attribute DOMString rel;
          attribute DOMString rev;
          [SameObject, PutForwards=value]readonly attribute DOMTokenList relList;
          attribute DOMString media;
          attribute DOMString hreflang;
          attribute DOMString type;
          [SameObject, PutForwards=value] readonly attribute DOMTokenList sizes;
        };
        HTMLLinkElement implements LinkStyle;
      </pre>
    </dd>
  </dl>

  <{link}> 요소(element)는 작성자가 그들의 문서를 다른 리소스들에 연결시키는 것을 허용합니다.

  링크(들)의 목적지는 <dfn element-attr for="link"><code>href</code></dfn> 속성(attribute)에 의해 
  주어지고, 이 속성(attribute)는 존재해야(must) 하고 
  <a lt="valid non-empty URL potentially surrounded by spaces">유효한 잠정적으로 공백으로 둘러 싸일 수 있는 비어있지 않은 URL</a>을 
  포함해야(must) 합니다. <span class="impl"><{link/href}> 속성이 존재하지 않ㄴ흔다면, 요소(element)는 
  링크를 정의하지 않습니다.</span>

  <{link}> 요소(element)는 <{link/rel}> 속성(attribute)을 가져야(must) 합니다.

  <p class="note">
    <{link/rel}> 속성(attribute)이 사용되었다면, 요소(element)는 <code>head</code> 요소(element)에 
    제한됩니다.
  </p>

  표현된 링크의 유형 (관계)는 <dfn element-attr for="link"><code>rel</code></dfn> 속성(attribute)의 
  값에 의해 주어지고, 이것이 존재한다면, <a lt="set of space-separated tokens">공백으로 분리된 토큰 집합</a>인
  값을 가져야(must) 합니다. <a lt="allowed keywords and their meanings">허용된 키워드와 그것들의 의미(meanings)</a>는
  이후 섹션에서 정의됩니다.  <{link/rel}> 속성(attribute)이 존재하지 않는다면 키워드를 가지지 않거나,
  사용된 어떤 키워드도 이 명세에서의 정의를 따라 허용된 것이 아니라면, 요소(element)는 어떤 연결도 
  생성하지 않습니다.

  링크의 두 카테고리들은 <{link}> 요소(element)를 사용하여 생성될 수 있습니다:
  <a lt="Links to external resources">외부 리소스들로의 링크들</a>과 <a lt="hyperlinks">하이퍼링크들</a>.
  [[#sec-link-types]] 섹션은 특정 링크 유형이 외부 리소스인지 하이퍼링크인지를 정의합니다.
  한 개 <code>link</code> 요소(element)는 여러 개의 링크들을 (일부는 외부 리소스 링크일 수 있고
  일부는 하이퍼링크일 수 있습니다) 생성할 수 있습니다; 정확히 어떤 그리고 몇 개의 링크들이 생성 되는지는
  <{link/rel}> 속성(attribute)에 주어진 키워드에 달려 있습니다. 유저 에이전트들은 요소(element) 단위가 
  아닌 링크 단위로 처리해야(must) 합니다.

  <p class="note">
    <{link}> 요소(element)에 대해 생성 된 각 링크는 별도로 처리됩니다. 예를 들어, <code>rel="stylesheet"</code>를
    가진 두 개의 <{link}> 요소(element)가 있따면, 각각은 독립적으로 자신의 속성(attbribute)에 의해
    영향을 받습니다. 마찬가지로, <code>next stylesheet</code> 값을 가진 <{link/rel}> 속성(attribute)을
    가진 단일 <{link}> 요소(element)가 있다면, 이것은 (<code>next</code> 키워드에 대한) <a lt="hyperlink">하이퍼링크</a>와
    (<code>stylesheet</code> 키워드에 대한) <a lt="external resource link">외부 리소스 링크</a>를 
    생성하고, 그것들은 다른 속성(attribute)들에 의해 (<code>media</code>나 <code>title</code> 같은)
    다르게 영향을 받습니다.
  </p>

  <div class="example">
    예를 들어, 다음 <{link}> 요소(element)는 두 하이퍼링크들을 (동일한 페이지에 대한) 생성합니다 :

    <pre highlight="html">&lt;link rel="author license" href="/about"></pre>

    이 요소(element)에 의해 생성된 두 링크들은 의미(semantic)가 현재 페이지의 작성자에 대한 정보를 
    가진 대상 페이지인 하나와, 의미(semantic)가 현재 페이지가 어떤 라이센스 하에 제공되는지에 관한  
    정보를 가지는 대상 페이지인 하나입니다.
  </div>

  <{link}>와 <{a}> 요소(element)들은 <{links/href}>에 의해 명시된 리소스로부터 현재 문서로의
  <a lt="reverse link">역방향 연결</a> 관계를 설명하는데 사용되는 
  <dfn element-attr for="a,link,links"><code>rev</code></dfn> 속성(attribute)도 가질 수 있습니다.
  이것이 존재한다면 이 속성(attribute)의 값은
  <a lt="set of space-separated tokens">공백으로 분리된 토큰 집합</a>이어야 합니다. <{links/rel}> 
  속성(attribute)처럼, [[#sec-link-types]]은 <{links/rev}> 속성(attribute)에 대한
  <a lt="allowed keywords and their meanings">허용된 키워드와 그것들의 의미(meanings)</a>를 설명합니다.
  <{links/rel}>과 <{links/rev}> 속성(attribute)들은 동일 요소(element)에 모두 존재할 수 있습니다.

  <dfn lt="reverse link|Reverse links">역방향 링크</dfn>는 링크의 역방향 관계를 나타내는 방법입니다.
  값이 정방향 관계를 ("링크가 나에게 관계되는 방법") 전달하는 <{links/rel}> 속성(attribute)과는
  대조적으로, <{links/rev}> 속성(attribute)은 유사한 관계들이 역방향으로 ("내가 이 링크에 관계되는 
  방법") 노출되도록 허용합니다. 이 값들은 유저 에이전트들이 연결된 문서의 보다 포괄적인 지도를 만들 수 
  있게 할 수 있습니다.

  <div class="example">책의 챕터를 각각 포함하는 두 개의 문서가 주어지면, 그것들 사이의 링크는 다음과
  같이 <{link/rel}>과 <{links/rev}> 속성(attribute)들을 가지고 기술될 수 있습니다:

  "chapter1.html" URL를 가진 문서
  <pre highlight="html">&lt;link href="chapter2.html" rel="next" rev="prev"&gt;</pre>

  "chapter2.html" URL를 가진 문서
  <pre highlight="html">
&lt;link href="chapter1.html" rel="prev" rev="next"&gt;
&lt;link href="chapter3.html" rel="next" rev="prev"&gt;</pre>

  chapter1.html에서 chapter2.html로의 연결은  정방향으로 시리즈에서 "<code>next</code>" 챕터이고,
  역방향으로는 (chapter2.html에서 chapter1.html으로) "<code>previous</code>" 챕터 입니다.
  </div>

  <div class="example">콘텐트 목록 문서에서 링크들은 <{links/rel}>과 <{links/rev}>를 사용하여
  다음과 같이 기술 될 수 있습니다:
  <pre highlight="html">
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="chapter1.html" rev="toc" rel="next"&gt;chapter 1&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="chapter2.html" rev="toc"&gt;&lt;/a&gt;chapter 2&lt;/li&gt;
    &lt;li&gt;&lt;a href="chapter3.html" rev="toc"&gt;&lt;/a&gt;chapter 3&lt;/li&gt;
  &lt;/ol&gt;
  </pre>

  콘텐트 목록에서 "<code>next</code>" 논리 경로는 <{links/rel}>을 사용하여 노출 된 첫 번째 챕터 입니다.
  각 챕터 링크는 현재 문서가 매 챕터에 대한 콘텐트 목록 문서 임을 나타내는 "<code>toc</code>"
  <{links/rev}> 값을 가집니다.

  </div>

  <dfn element-attr for="link"><code>crossorigin</code></dfn> 속성(attribute)은 
  <a lt="CORS settings attribute">CORS 설정 속성(attribute)</a>입니다. 이것은 외부 리소스 링크와 
  함께 사용하도록 의도된 것입니다.

  외부 리소스로의 링크에 대한 정확한 동작은 관련 링크 유형에 대해 정의된 정확한 관계에 달려있습니다.
  일부 속성(attribute)들은 외부 리소스가 적용 될지 (아래 정의된 대로) 여부를 제어합니다.

  DOM에 표현되는 외부 리소스에 대해 (예를 들어, 스타일시트), DOM 표현은 리스소가 적용 되지 않는다
  하더라도 사용 가능 하게 되어야(must) 합니다 (모듈 교차 출처 제한).
  <dfn lt="obtain|obtain the resource">리소스를 획득</dfn>하기 위해, 유저 에이전트는 다음 단계들을 
  수행해야(must) 합니다:


  1. <{link/href}> 속성(attribute)의 값이 빈 문자열이라면, 이 단계들을 중단합니다.
  2. 요소(element)의 <a lt="node document">노드 문서</a>에 관련하여, <{link/href}> 속성(attribute)에
      의해 주어진 <a for="url">URL</a>을 <a lt="parse">해석</a>합니다. 그것이 실패한다면, 이 단계들을
      중단합니다. 그렇지 않으면, <var>url</var>을 <a lt="resulting URL record">결과 URL 레코드</a>로 
      둡니다.
  3. <var>corsAttributeState</var>를 요소(element)의 <{link/crossorigin}> 콘텐트 속성(attribute)의 
      현재 상태로 둡니다.
  4. <var>request</var>를 <var>url</var>과 <var>corsAttributeState</var>가 주어진 
      <a lt="creating a potential-CORS request">잠재적 CORS 요청 생성</a>의 결과로 둡니다.
  5. <var>request</var>의 <a lt="client">클라이언트</a>를 <{link}> 요소(element)의
      <a lt="node document">노드 문서</a>의 {{Window}} 객체의 
      <a lt="environment settings object">환경 설정 객체</a>로 둡니다.
  6. <var>request</var>를 <a lt="fetch">가져옵니다</a>.

  유저 에이전트들은 적용되지 않은 모든 리소스들을 능동적으로 가져오는 대신, 그것들이 필요할 경우 그
  리소스를 얻기 위해 시도하기로 선택할 수 있습니다.

  외부 리소스를 가져올 때 사용된 프로토콜의 (예를 들어, HTTP) 의미(semantics)를 따라야(must) 합니다. 
  (예를 들어, 리다이렉트가 뒤따르는 것과 404 응답은 외부 리소스가 적용되지 않는 것을 야기합니다.)

  일단 리소스를 얻으려는 시도와 그것의 <a lt="critical subresources">중요한 하위 리소스들</a>이 완료되면,
  유저 에이전트는 로드가 성공적이었다면, <{link}> 요소(element)에 <code>load</code>라고 이름이
  붙은 <a lt="fire a simple event">단순 이벤트를 발생</a>시키기 위한 <a lt="queue a task">작업을 대기열에 넣거나</a>,
  리소스나 그것의 <a lt="critical subresources">중요한 하위 리소스들</a>의 하나가 어떤 이유로
  (예를 들어, DNS 오류, HTTP 404 응답, 너무 빨리 닫히는 연결, 지원되지 않은 Content-Type) 완전한
  로드가 실패되었다면, <{link}> 요소(element)에 <code>error</code>라고 이름이 붙은
  <a lt="fire a simple event">단순 이벤트를 발생</a>시키기 위한 <a lt="queue a task">작업을 대기열에 넣습니다</a>.
  리소스나 하위 리소스들 처리에 비 네트워크 오류들은 (예를 들어, CSS 해석 오류, PNG 디코딩 오류)
  이 문단의 목적을 위한 실패가 아닙니다.

  이 <a lt="tasks">작업들</a>에 대한 <a lt="task source">작업 소스</a>는 
  <a lt="DOM manipulation task source">DOM 조작 작업 소스</a>입니다.

  요소(element)는 리소스와 그것의 <a lt="critical subresources">중요한 하위 리소스들</a>을 얻기 위한 
  모든 시도가 완료될 때까지 요소(element)의 <a lt="node document">노드 문서</a>의
  <a lt="delay the load event">로드 이벤트를 지연</a>시켜야(must) 합니다. (유저 에이전트가 아직 얻으려고
  시도하지 않은 리소스는, 예를 들어 리소스가 필요하기를 기다리고 있기 때문에,
  <a lt="delay the load event">로드 이벤트를 지연</a>시키지 않습니다.)

  <hr />

  대화형 유저 에이전트들은 유저 인터페이스의 어딘가에서 <{link}> 요소(element)를 사용하여 생성된
  <a lt="follow the hyperlinks">하이퍼링크들을 따르기</a> 위한 방법을 사용자에게 제공할 수 있습니다.
  정확한 인터페이스는 이 명세에 정의되지 않지만, 문서 내 각 <{link}> 요소(element)를 가지고 생성된 각
  하이퍼링크에 대해, 일부 형식이나 다른 것에서 (아마도 간소화 된), 다음 정보를 (아래 정의된 대로,
  요소(element)의 속성으로부터 얻어진) 포함할 수 있습니다.

  * 이 문서와 리소스 (<{link/rel}> 속성(attribute)에 의해 주어진) 사이의 관계
  * 리소스의 제목 (<code>title</code> 속성(attribute)에 의해 주어진).
  * 리소스의 주소 (<{link/href}> 속성(attribute)에 의해 주어진).
  * 리소스의 언어 (<code>hreflang</code> 속성(attribute)에 의해 주어진).
  * 리소스에 대한 최고의 매체 (<code>media</code> 속성(attribute)에 의해 주어진).

  유저 에이전트들은 리소스의 유형과 같은 (<code>type</code> 속성(attribute)에 의해 주어진), 다른 
  정보를 포함할 수 있습니다.

  <p class="note">
    <{link}> 요소(element)와 그것의 <{link/rel}> 속성(attribute)을 가지고 생성된 하이퍼링크들은 전체 
    페이지에 적용됩니다. 이것은 컨텍스트가 문서 안의 링크의 위치에 의해 주어진 위치인 링크의 유형을
    나타내는, <{a}>와 <{area}> 요소(element)의 <{link/rel}> 속성(attribute)과 대조를 이룹니다.
  </p>

  <dfn element-attr for="link"><code>media</code></dfn> 속성(attribute)은 리소스가 적용될 매체를 말해줍니다.
  값은 <a lt="valid media query list">유효한 미디어 쿼리 목록</a>이어야(must) 합니다.

  <div class="impl">
    링크가 <a lt="hyperlink">하이퍼링크</a>라면 <code>media</code> 속성(attribute)은 순수하게 조언적이고, and
    문제의 문서가 어떤 매체에 대해 설계되었는지를 설명합니다.

    하지만, 링크가 <a lt="external resource link">외부 리소스 링크</a>라면, <code>media</code> 
    속성(attribute)은 지시적인 것입니다. 유저 에이전트는 <code>media</code> 속성(attribute)의 값이
    <a lt="matches the environment">환경과 일치</a>하고 다른 관련 조건들이 적용되는 경우 외부 리소스를 
    적용해야(must)하고, 그렇지 않으면 적용하지 않아야(must) 합니다.

    <p class="note">
      외부 리소스는 그것의 적용 가능성 제한 내에서 정의된 추가 제한 사항을 가질 수 있습니다. 
      예를 들어, CSS 스타일 시트는 일부 <code>@media</code> 블럭을 가질 수 있습니다. 이 명세는 
      그러한 추가 제한 사항이나 요구사항을 재정의 하지 않습니다.
    </p>
  </div>

  <code>media</code> 속성(attribute)이 생력되었다면 기본 값은 기본값에 의해 링크가 모든 매체에
  적용 됨을 의미하는 "<code>all</code>" 입니다.

  <{link}> 요소(element)의 <dfn element-attr for="link"><code>hreflang</code></dfn> 속성(attribute)은 
  <{a}> 요소(element)의 <code>hreflang</code> 속성(attribute)과 동일한 의미를 가집니다.

  <dfn element-attr for="link"><code>type</code></dfn> 속성(attribute)은 링크되는 리소스의 
  <a lt="MIME type">MIME 타입</a>을 제공합니다. 이것은 순수하게 조언적입니다. 값은 
  <a lt="valid mime type">유효한 MIME 타입</a>이어야(must) 합니다.

  <a lt="external resource links">외부 리소스 링크</a>에 대해, <code>type</code> 속성(attribute)은 
  유저 에이전트가 지원하지 않는 리소스를 가져오는 것을 방지할 수 있도록 유저 에이전트에 대한 힌트로
  사용됩니다. <span class="impl">속성(attribute)이 존재하지 않는다면, 유저 에이전트는 (그것이
  <a lt="valid mime type">유효한 MIME 타입</a>, 예를 들어, 빈 문자열이라 하더라도) 리소스가 주어진 
  유형의 것으로 추정해야(must) 합니다. 속성(attribute)이 생략되었고, 외부 리소스 링크 유형이 정의된 
  기본 유형을 가진다면, 유저 에이전트는 리소스를 그 유형의 것으로 추정해야(must) 합니다. 유저 에이전트가
  주어진 링크 관계에 대해 주어진 <a lt="MIME type">MIME 타입</a>을 지원하지 않는다면, 유저 에이전트는
  리소스를 <a lt="obtain">획득</a>하지 않아야(should) 합니다; 유저 에이전트가 주어진 링크 관계에
  대해 주어진 <a lt="MIME type">MIME 타입</a>을 지원하지 않는다면, 유저 에이전트는
  <a lt="external resource link">외부 리소스 링크</a>의 특정 유형에 대해  명시된 대로 적절한 시간에
  리소스를 <a lt="obtain">획득</a>해야(should) 합니다. 속성(attribute)이 생략되었고, 외부 리소스 링크
  유형이 정의된 기본 유형을 가지지 않고, 유형이 알려져 있고 지원되는 경우 유저 에이전트가 리소스를
  <a lt="obtain">획득</a> 한다면, 유저 에이전트는 그것이 지원된다는 가정 하에 리소스를
  <a lt="obtain">획득</a> 해야(should) 합니다.</span>

  <div class="impl">
    유저 에이전트들은 <code>type</code> 속성(attribute)을 믿을만한 것으로 간주하지 않아야(must) 합니다 
    &mdash; 리소스를 가져오는데에, 유저 에이전트들은 <code>type</code> 속성(attribute)을 그것의 실제 
    유형을 결정하기 위해 사용하지 않아야(must) 합니다. 오직 실제 유형은 (다음 문단에 정의된 것과 같이)
    리소스에 <em>적용</em> 할지 여부를 결정짓기 위해서 사용되는 것이지, 앞서 언급된 가정된 유형이 
    아닙니다.

    <dfn lt="determining the type of the resource"></dfn>외부 리소스 링크 유형이 리소스의 
    <a lt="Content-Type metadata">Content-Type 메타데이터</a> 처리에 대한 규칙을 정의한다면, 그 
    규칙은 적용됩니다. 그렇지 않고, 리소스가 이미지가 예상된다면, 유저 에이전트들은 리소스의
    <a lt="Content-Type metadata">Content-Type 메타데이터</a>로부터 유형이 결정된 
    <var>official type</var>을 가지고 <a lt="image sniffing rules">이미지 스니핑 규칙들</a>을 적용할 
    수 있고, 결과로 나온 <a lt="computed type of the resource">계산 된 리소스의 유형</a>을 그것이
    실제 유형인것 처럼 사용할 수 있습니다. 그렇지 않고, 이 조건들을 적용하거나 유저 에이전트가 이미지
    스니핑 규칙을 적용하지 않기로 한다면, 유저 에이전트는 리소스의 유형을 결정하기 위해 리소스의
    <a lt="Content-Type metadata">Content-Type 메타데이터</a>를 사용해야(must) 합니다. 유형
    메타데이터가 없고 외부 리소스 링크 유형이 정의된 기본 유형을 가진다면, 유저 에이전트는 리소스를 
    그 유형의 것으로 추정해야(must) 합니다.

    <p class="note">
      <code>stylesheet</code> 링크 유형은 리소스의 
      <a lt="Content-Type metadata">Content-Type 메타데이터</a> 처리에 대한 규칙을 정의합니다.
    </p>

    유저 에이전트가 리소스의 유형을 설정 할 때, 유저 에이전트는 지원되는 유형의 것이고 다른 관련 
    조건이 적용된다면 리소스를 적용해야(must)하고, 그렇지 않으면 리소스를 무시해야(must) 합니다.

    <div class="example">
      문서가 다음과 같이 라벨링 된 스타일 시트 링크를 포함한다면:

      <pre highlight="html">
        &lt;link rel="stylesheet" href="A" type="text/plain"&gt;
        &lt;link rel="stylesheet" href="B" type="text/css"&gt;
        &lt;link rel="stylesheet" href="C"&gt;
      </pre>

     ...CSS 스타일 시트만을 지원하는 호환 유저 에이전트는 B와 C파일을 가져오고, A파일은 생략할 
     것입니다 (<code>text/plain</code>은 CSS 스타일 시트에 대한 <a lt="MIME type">MIME 타입</a>이 
     아니기 때문에).

     B와 C 파일에 대해, 이것은 이후 서버에 의해 반환된 실제 유형을 검사할 것입니다. 
     <code>text/css</code>로 보내어진 것들에 대해, 이것은 스타일 시트를 적용할 것이지만, 
     <code>text/plain</code>으로 라벨링 된 것들에 대해 혹은 다른 유형에 대해서는 그렇지 않을 것입니다.

     두 파일 중 하나가  <a>Content-Type</a> 메타데이터 없이 혹은, 
     <code>Content-Type:&nbsp;"null"</code>과 같은 구문적으로 틀린 유형을 가지고 반환된다면, 
     <code>stylesheet</code> 링크들에 대한 기본 유형이 효과를 낼 것입니다. 그 기본 유형이 
     <code>text/css</code>이기 때문에, 스타일 시트는 그럼에도 불구하고 적용 <em>될</em> 것입니다.
    </div>
  </div>

  <dfn element-attr for="link"><code>title</code></dfn> 속성(attribute)은 링크의 제목(title)을 
  제공합니다. 한 가지 예외를 가지고, 이것은 순수하게 조언적입니다. 값은 텍스트입니다. 예외 사항은 
  <code>title</code> 속성(attribute)이 <a lt="alternative style sheet sets">대체 스타일 시트 세트</a>를 
  정의하는 스타일 시트에 대한 것입니다.

  <p class="note">
    <{link}> 요소(element)들의 <code>title</code> 속성(attribute)은 제목이 부모 요소(element)의 
    제목을 상속 받지 않는 링크라는 점에서 대다수 다른 요소(element)들의 범용 <code>title</code> 
    속성(attribute)과는 차이가 있습니다: 그것은 단지 제목을 가지지 않습니다.
  </p>

  <code>sizes</code> 속성(attribute)은 <code>icon</code> 링크 유형과 함께 사용됩니다. 
  속성(attribute)은 <code>icon</code> 키워드를 명시한 <{link/rel}> 속성(attribute)을 가지지 않는 
  <{link}> 요소(element)들에 명시되지 않아야(must) 합니다.

  <div class="impl">
    <a lt="hyperlinks">하이퍼링크</a>들을 생성하는 <code>link</code> 요소(element)들의 
    <a lt="activation behavior">활성화 동작</a>은 다음 단계들을 수행하는 것입니다:

    1. <{link}> 요소(element)의 <a lt="node document">노드 문서</a>가, 
        <a lt="fully active">완전히 활성화</a>가 아니라면, 이 단계들을 중단합니다.
    2. <code>link</code> 요소(element)에 의해 생성된 <a lt="follow the hyperlink">하이퍼링크를 따라갑니다</a>.

    HTTP <code>Link:</code> 헤더가 지원된다면, HTTP 메세지에 주어진 순서에 따라, 문서 내 모든 
    링크들 앞에 오는 것으로 추정되어야(must) 합니다. 이 헤더들은 관련 명세에 주어진 규칙을 따라 처리 
    됩니다. [[!HTTP]] [[!RFC5988]]

    <p class="note">
      HTTP 링크의 등록 관계 유형: 헤더는 <a lt="HTML link types">HTML 링크 유형들</a>과 구별되고, 
      따라서 그것들의 의미는 동일한 이름의 HTML 유형들과 다를 수 있습니다.
    </p>

    IDL 속성(attribute)들 <dfn attribute for="HTMLLinkElement"><code>href</code></dfn>, <dfn attribute for="HTMLLinkElement"><code>rel</code></dfn>,
	<dfn attribute for="HTMLLinkElement"><code>rev</code></dfn>, <dfn attribute for="HTMLLinkElement"><code>media</code></dfn>, <dfn attribute for="HTMLLinkElement"><code>hreflang</code></dfn>,
    <dfn attribute for="HTMLLinkElement"><code>type</code></dfn>, <dfn attribute for="HTMLLinkElement"><code>sizes</code></dfn>는 동일한 이름의 각 콘텐트 속성(attribute)들을 
	<a lt="reflect">반영</a>해야(must) 합니다.

    <dfn attribute for="HTMLLinkElement"><code>crossOrigin</code></dfn> IDL 속성(attribute)은
    콘텐트 속성(attribute)을 <a lt="reflect">반영</a>해야(must) 합니다.

    IDL 속성(attribute) <dfn attribute for="HTMLLinkElement"><code>relList</code></dfn>은 
    <{link/rel}> 콘텐트 속성을 <a lt="reflect">반영</a> <span class="impl">해야(must)</span> 합니다.

    <code>relList</code>의 <code>DOMTokenList</code>의 <a lt="supported tokens">지원되는 토큰들</a>은 
    <code>link</code> 요소(element)들에 허용되고 유저 에이전트에 의해 지원된 
    <a lt="HTML link types">HTML 링크 유형들</a>에 정의된 키워드들입니다.

    <{link/rel}>의 <a lt="supported tokens">지원되는 토큰들</a>은 <code>link</code> 
    요소(element)들에 허용되고, 처리 모델에 영향을 주고, 유저 에이전트에 의해 지원되는
    <a lt="HTML link types">HTML 링크 유형들</a>에 정의된 키워드들입니다. 가능한 지원되는 토큰들은
    <code>alternate</code>, <a>dns-prefetch</a>, <code>icon</code>, <a>preconnect</a>,
    <a>prefetch</a>, <a>prerender</a>, <code>stylesheet</code> 입니다. <{link/rel}>의
    <a lt="supported tokens">지원되는 토큰들</a>은 유저 에이전트가 처리 모델에 대해 구현하는
    이 목록의 토큰들을 포함해야(must) 합니다.

    다른 명세들은 [[!RESOURCE-HINTS]]과 같은, <a lt="Other link types">다른 링크 유형들</a>에 정의 
    된 <a lt="HTML link types">HTML 링크 유형들</a>을 추가할 수 있습니다. 이 명세들은 그들의 링크 
    유형들이 <{link/rel}>의 지원되는 토큰들에 포함되도록 요구할 수 있습니다.
  </div>

  <code>LinkStyle</code> 인터페이스는 또한 이 요소(element)에 의해 구현됩니다. [[!CSSOM]]

  <div class="example">
    여기, <{link}> 요소(element)들의 세트가 일부 스타일 시트들을 제공합니다:

    <pre highlight="html">
      &lt;!-- a persistent style sheet -->
      &lt;link rel="stylesheet" href="default.css">

      &lt;!-- the preferred alternate style sheet -->
      &lt;link rel="stylesheet" href="green.css" title="Green styles">

      &lt;!-- some alternate style sheets -->
      &lt;link rel="alternate stylesheet" href="contrast.css" title="High contrast">
      &lt;link rel="alternate stylesheet" href="big.css" title="Big fonts">
      &lt;link rel="alternate stylesheet" href="wide.css" title="Wide screen">
    </pre>
  </div>

  <div class="example">
    다음 예제는 대체 형식을 사용하고 다른 언어를 대상으로하며 다른 매체에 대해 의도된 페이지의 
    버전을 지정할 수 있는 방법을 보여줍니다:

    <pre highlight="html">
      &lt;link rel=alternate href="/en/html" hreflang=en type=text/html title="English HTML">
      &lt;link rel=alternate href="/fr/html" hreflang=fr type=text/html title="French HTML">
      &lt;link rel=alternate href="/en/html/print" hreflang=en type=text/html media=print title="English HTML (for printing)">
      &lt;link rel=alternate href="/fr/html/print" hreflang=fr type=text/html media=print title="French HTML (for printing)">
      &lt;link rel=alternate href="/en/pdf" hreflang=en type=application/pdf title="English PDF">
      &lt;link rel=alternate href="/fr/pdf" hreflang=fr type=application/pdf title="French PDF">
    </pre>
  </div>

<h4 id="the-meta-element"><dfn element><code>meta</code></dfn> 요소(element)</h4>

  <dl class="element">
    <dt><a lt="Categories">카테고리</a>:</dt>
    <dd><a lt="Metadata content">메타데이터 콘텐트</a>.</dd>
    <dt><a lt="Contexts in which this element can be used">이 요소(element)가 사용될 수 있는 컨텍스트</a>:</dt>
    <dd>
      <code>charset</code> 속성(attribute)이 존재하거나, 요소(element)의 <code>http-equiv</code> 
      속성(attribute)이 <a state for="http-equiv" lt="encoding declaration state">인코딩 선언 상태</a>에 
      있다면: <{head}> 요소(element) 안.
    </dd>
    <dd>
      <code>http-equiv</code> 속성(attribute)이 존재하지만 
      <a state for="http-equiv" lt="encoding declaration state">인코딩 선언 상태</a>에 있지 않다면:
      <{head}> 요소(element) 안.
    </dd>
    <dd>
      <code>http-equiv</code> 속성(attribute)이 존재하지만 
      <a state for="http-equiv" lt="encoding declaration state">인코딩 선언 상태</a>에 있지 않다면: 
      <{head}> 요소(element)의 자식인 <{noscript}> 요소(element) 안.
    </dd>
    <dd>
      <code>name</code> 속성(attribute)이 존재한다면: <a lt="metadata content">메타데이터 콘텐트</a>가
      기대되는 곳.
    </dd>
    <dt><a lt="Content model">콘텐트 모델</a>:</dt>
    <dd><a lt="Nothing">없음</a>.</dd>
    <dt><a lt="Tag omission in text/html">text/html에서 태그 생략</a>:</dt>
    <dd><a lt="end tag">종료 태그</a> 없음.</dd>
    <dt><a lt="Content attributes">콘텐트 속성(attribute)들</a>:</dt>
    <dd><a lt="Global attributes">범용 속성(attribute)들</a></dd>
    <dd><code>name</code> — 메타데이터 이름</dd>
    <dd><code>http-equiv</code> — 선처리(pragma) 지시자</dd>
    <dd><code>content</code> — 요소(element)의 값</dd>
    <dd><code>charset</code> — <a lt="character encoding declaration">문자 인코딩 선언</a></dd>
    <dt>허용된 <a href="#aria-role-attribute">ARIA 역할(role) 속성(attribute)</a> 값들:</dt>
    <dd>없음</dd>
    <dt>허용된 <a href="#state-and-property-attributes">ARIA 상태(state)와 속성(property) 속성(attribute)들</a>:</dt>
    <dd><a lt="Global aria-* attributes">범용 aria-* 속성(attribute)들</a></dd>
    <dt><a lt="DOM interface">DOM 인터페이스</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl" dfn-for="HTMLMetaElement">
        interface HTMLMetaElement : HTMLElement {
          attribute DOMString name;
          attribute DOMString httpEquiv;
          attribute DOMString content;
        };
      </pre>
    </dd>
  </dl>

  <{meta}> 요소(element)는 <a element for="html"><code>title</code></a>, <{base}>, <{link}>, 
  <{style}>, <{script}> 요소(element)들을 사용하여 나타낼 수 없는 메타데이터의 다양한 종류를 
  <a lt="represents">나타냅니다</a>.

  <{meta}> 요소(element)는 <code>name</code> 속성(attribute)으로 문서 수준의 메타데이터를, 
  <dfn element-attr for="meta"><code>http-equiv</code></dfn> 속성(attribute)으로 선처리(pragma) 
  지시자들을, <code>charset</code> 속성(attribute)으로 HTML 문서가 문자열 형식으로 직렬화 될 때 
  (예를 들어, 네트워크나 디스크 기억 장치를 통한 전송에 대해) 파일의 
  <a lt="character encoding declaration">문자 인코딩 선언</a>을 나타낼 수 있습니다.

  <code>name</code>, <code>http-equiv</code>, <code>charset</code> 속성(attribute)들 중 정확히 하나는 
  명시 되어야(must) 합니다.

  <code>name</code>나 <code>http-equiv</code>가 명시되었다면, <code>content</code> 속성(attribute)도 
  명시되어야(must) 합니다. 그렇지 않으면 생략 되어야(must) 합니다.

  <dfn element-attr for="meta"><code>charset</code></dfn> 속성(attribute)은 문서에 사용된 문자 
  인코딩을 명시합니다. 이것이 <a lt="character encoding declaration">문자 인코딩 선언</a> 입니다. 
  속성(attribute)이 <a lt="XML document">XML 문서</a>에 존재한다면, 그 값은 문자열 
  "<code>utf-8</code>"에 <a lt="ASCII case-insensitive">ASCII 대소문자 구분 없이</a> 일치해야(must) 
  합니다 (그리고 문서는 따라서 그 인코딩으로 <a>UTF-8</a>을 사용하도록 강제됩니다).

  <p class="note"><{meta}> 요소(element)의 <code>charset</code> 속성(attribute)은 XML 문서들에 
  영향을 가지지 않고, XHTML로부터 그리고 XHMTL로의 마이그레이션을 가능하게 하기 위해서만 허용됩니다.</p>

  문서 당 <code>charset</code> 속성(attribute)을 가진 <{meta}> 요소(element)는 하나를 초과하여
  존재하지 않아야(must) 합니다.

  <dfn element-attr for="meta"><code>content</code></dfn> 속성(attribute)은 요소(element)가 그 
  목적에 대해 사용될 때 문서 메타데이터의 값이나 선처리(pragma) 지시자의 값을 제공합니다. 허용된 
  값은 이 명세의 다음 섹션에 설명된 대로, 정확한 컨텍스트에 달려 있습니다.

  <{meta}> 요소(element)가 <dfn element-attr for="meta"><code>name</code></dfn> 속성(attribute)을 
  가진다면, 문서 메테데이터를 설정합니다. 문서 메타데이터는, 이름을 제공하는 <{meta}> 요소(element)의 
  <code>name</code> 속성(attribute)과, 값을 제공하는 동일한 요소(element)의 <code>content</code> 속성, 
  이름-값 쌍의 용어로 표현됩니다. 이름은 메타데이터의 측면이 설정하는 것을 명시합니다; 유효한 이름들과 
  그 값의 의미가 다음 섹션에 설명되어 있습니다. <{meta}> 요소(element)가 <code>content</code> 속성을 
  가지지 않는다면, 메타데이터 이름-값 쌍의 값은 빈 문자열 입니다.

  <dfn attribute for="HTMLMetaElement"><code>name</code></dfn>과 
  <dfn attribute for="HTMLMetaElement"><code>content</code></dfn> IDL 속성(attribute)들은 동일한 
  이름의 각각의 콘텐트 속성(attribute)들을 <a lt="reflect">반영</a>해야(must) 합니다. IDL 
  속성(attribute) <dfn attribute for="HTMLMetaElement"><code>httpEquiv</code></dfn>는 콘텐트 
  속성(attribute) <{meta/http-equiv}>를 <a lt="reflect">반영</a>해야(must) 합니다.

<h5 id="standard-metadata-names">표준 메타데이터 이름들</h5>

  이 명세는 <{meta}> 요소(element)의 <code>name</code> 속성(attribute)에 대한 몇 가지 이름들을 
  정의합니다.

  이름들은 ASCII 대소문자 구분이 없고<span class="impl">, 
  <a lt="ASCII case-insensitive">ASCII 대소문자 비구분</a> 방법으로 비교되어야(must) 합니다</span>.

  : <dfn><code>application-name</code></dfn>
  :: 값은 페이지가 나타내는 웹 어플리케이션의 이름을 제공하는 짧은 자유 형식의 문자열이어야(must) 
      합니다. 페이지가 웹 어플리케이션이 아니라면, <code>application-name</code> 메타데이터 이름은 
      사용되지 않아야(must) 합니다. 각 이름의 언어를 명시하기 위한 <{global/lang}> 속성을 사용하여 
      웹 어플리케이션의 이름의 번역이 제공될 수 있습니다.

      주어진 <a lt="language">언어</a>와 <code>application-name</code> 값으로 설정하는 
      <code>name</code> 속성(attribute)을 가진 <{meta}> 요소(element)는 문서 당 하나를 초과하여 
      존재하지 않아야(must) 합니다.

      <div class="impl">
        제목(title)은 어플리케이션의 이름이 되는 것 대신에 특정 순간의 상태 메세지와 페이지의
        상태와 유사한 것을 포함할 수 있기 때문에, 유저 에이전트들은 페이지의 
        <a element for="html"><code>title</code></a>보다 우선적으로 UI에서 어플리케이션 이름을 
        사용할 수 있습니다.

        주어진 언어의 정렬된 목록을 (예를 들어, 영국 영어, 미국 영어, 영어) 사용하기 위한 
        어플리케이션 이름을 찾기 위해, 유저 에이전트들은 다음 단계들을 수행해야(must) 합니다:

        1. <var>languages</var>를 언어의 목록으로 둡니다.
        2. <var>default language</var>를 {{Document}}의 <a lt="root element">루트 요소(element)</a>의 
            <a lt="language">언어</a>가 있다면 그것으로두고, 그 언어는 알 수 없는 것이 아닙니다.
        3. <var>default language</var>가 있다면, 그리고 그것이 <var>languages</var>의 언어 중 어떠한 
            것과도 동일한 언어가 아니라면, <var>languages</var>에 그것을 추가(append) 합니다.
        4. <var>winning language</var>를 값 <code>application-name</code>로 설정된 <code>name</code> 
            속성(attribute)을 가지고 <a lt="language">언어</a>가 문제의 언어인 {{Document}}의 
            <{meta}> 요소(element)에 있는 <var>languages</var>의 첫 번째 언어로 둡니다.

            언어들어 어떠한 것도 그러한 <{meta}> 요소(element)를 가지지 않는다면, 이 단계들을 
            중단합니다; 주어진 어플리케이션 이름이 없습니다.
        5. <a lt="tree order">트리 순서</a>에 따라 값 <code>application-name</code>로 설정된 
            <code>name</code> 속성(attribute)을 가지고 <a lt="language">언어</a>가 
            <var>winning language</var>인 {{Document}}의 첫 번째 <code>meta</code> 요소(element)의 
            <code>content</code> 속성(attribute)의 값을 반환합니다.

        <p class="note">
          이 알고리즘은 페이지에 대한 이름이 요구될 때, 예를 들어 북마크에 라벨을 붙이기 위해, 
          브라우저에 의해 사용됩니다. 알고리즘에 제공될 언어는 사용자가 선호하는 언어가 될 것입니다.
        </p>
      </div>

  : <dfn><code>author</code></dfn>
  :: 값은 페이지의 작성자 하나의 이름을 제공하는 자유 형식의 문자열이어야(must) 합니다.

  : <dfn><code>description</code></dfn>
  :: 값은 페이지를 설명하는 자유 형식의 문자열이어야(must)합니다. 값은 페이지의 디렉토리에서 
      사용하기에, 예를 들어, 검색엔진에서, 적절해야(must) 합니다. 문서 당 값 
      <code>description</code>로 설정된 <code>name</code> 속성(attribute)을 가진 <{meta}> 
      요소(element)는 하나를 초과하여 존재하지 않아야(must) 합니다.

  : <dfn><code>generator</code></dfn>
  :: 값은 문서를 생성하는데 사용된 소프트웨어 패키지들의 하나를 확인하는 자유 형식의 
      문자열이어야(must) 합니다. 이 값은 소프트웨어에 의행 생성되지 않은 마크업의 페이지에는, 
      예를 들어, 텍스트 에디터로 사용자에 의해 작성된 마크업의 페이지에는 사용되지 않아야(must) 
	  합니다.

      <div class="example">
        여기 "Frontweaver"라고 불리는 도구가, 페이지의 <{head}> 요소(element)에서, 페이지를 생성하는데
        사용된 것으로 그 자신을 식별하기 위해, 그것의 출력물에 포함할 수 있는 것이 있습니다.

        <pre highlight="html">&lt;meta name=generator content="Frontweaver 8.2"&gt;</pre>
      </div>

  : <dfn><code>keywords</code></dfn>
  :: 값은 각각이 페이지에 관련된 키워드인, 
      <a lt="set of comma-separated tokens">콤마로 분리된 토큰의 집합</a>이어야(must) 합니다.

      <div class="example">
        영국 고속도로의 서체에 대한 이 페이지는 <{meta}> 요소(element)를 사용자가 페이지를 찾는데 
        사용할 수 있는 몇 가지 키워드를 명시하기위해 사용합니다:

        <pre highlight="html">
          &lt;!DOCTYPE HTML&gt;
          &lt;html lang="en-GB"&gt;
            &lt;head&gt;
              &lt;title&gt;Typefaces on UK motorways&lt;/title&gt;
              &lt;meta name="keywords" content="british,type face,font,fonts,highway,highways"&gt;
            &lt;/head&gt;
            &lt;body&gt;
            ...
        </pre>
      </div>

      <p class="note">
        이 기능은 역사적으로 신뢰할 수 없고 사용자에게 도움이 되지 않는 방법으로 결과를 내는 스팸 
        검색 엔진을 위한 방법으로 오해시킬 만큼 사용되어 왔기 때문에 많은 검색 엔진들은 그 
        키워드들을 고려하지 않습니다.
      </p>

      <div class="impl">
        작성자가 페이지에 대해 적절한 것으로서 명시한 키워드들의 목록을 얻기 위해 , 유저 에이전트는 
        다음 단계들을 수행해야(must) 합니다:

        1. <var>keywords</var>을 빈 목록으로 둡니다.
        2. <code>name</code> 속성(attribute)과 <code>name</code> 속성(attribute)의 값이 
            <code>keywords</code>인 <code>content</code> 속성(attribute)을 가진 각 <{meta}> 
            요소(element)에 대해, 다음 하위 단계들을 수행합니다:
            1. <a lt="split a string on commas">요소(element)의 <code>content</code> 속성(attribute)의 값을 콤마로 분리합니다</a>.
            2. 결과 토큰들이 있다면 <var>keywords</var>에 추가(add) 합니다.
        3. <var>keywords</var>로부터 중복을 제거합니다.
        4. <var>keywords</var>를 반환합니다. 이것은 작성자가 페이지에 적절한 것으로 명시한 키워드의 
            목록입니다.

        유저 에이전트들은 값의 신뢰성에 대한 확신이 불충분 할 경우 이 정보를 사용하지 않아야(should) 
        합니다.

        <p class="example">
          예를 들어, 사이트 별 검색 엔진의 색인을 덧붙이기 위해 시스템에 페이지의 키워드 정보를 
          사용하기 위한 콘텐츠 관리 시스템은 타당할 것이지만, 이 정보를 사용하는 대규모 콘텐트 제공 
          웹사이트는 특정 사용자가 부적절한 키워드의 사용을 통해 랭킹 메커니즘을 희롱하는 시도를 
          하는 것을 발견할 가능성이 있습니다.
        </p>
      </div>

<h5 id="other-metadata-names">다른 메타데이터 이름들</h5>

  <dfn lt="register the names|register the name|metadata names">미리 정의된 메타데이터 이름들의 세트에 대한 확장들</dfn>은 
  <a href="https://wiki.whatwg.org/wiki/MetaExtensions">WHATWG Wiki MetaExtensions 페이지</a>에 
  등록될 수 있습니다. [[WHATWGWIKI]]

  누구든지 유형을 추가하기 위해 언제든지 WHATWG Wiki MetaExtensions 페이지를 자유롭게 수정할 수 
  있습니다. 이 새로운 이름들은 다음 정보를 가지고 명시되어야(must) 합니다:

  : 키워드(keyword)
  :: 정의되는 실제 이름. 이름은 다른 정의된 이름과 혼란스럽게 유사하지 않아야(should) 합니다
      (예를 들어, 대소문자만 다른).

  : 간단한 설명(brief description)
  :: 그 안에 값이 요구되는 형식을 포함하여, 메타데이터의 이름이 의미하는 것의 짧은 비규범적 설명

  : 명세(specification)
  :: 메타데이터 이름의 의미와 요구사항들의 더 자세한 설명으로의 링크. 다른 위키의 페이지나 외부 
      페이지로의 링크가 될 수 있습니다.

  : 동의어(synonyms)
  :: 정확히 동일한 처리 요구사항을 가지는 다른 이름들의 목록. 작성자는 동의어로 정의된 이름을 
      사용하지 않아야(should)합니다. 그것들은 유저 에이전트들이 레거시 콘텐트를 지원하는 것을 
      허용하도록 의도되었을 뿐입니다. 누구나 실제로 사용되지 않는 동의어를 제거 할 수 있습니다; 
      레거시 콘텐트와 호환성을 위한 동의어로서 처리되도록 요구되는 이름들만 이 방법으로 등록됩니다.

  : 상태(status)
  :: 다음 중 하나:
      : 제안 됨(proposed)
      :: 폭넓은 검토와 승인을 받지 않은 이름. 누군가 그것을 제한했고 곧 사용하게 될 것입니다.

      : 승인 됨(ratified)
      :: 폭넓은 검토와 승인을 받은 이름. 이것은 올바르지 않은 방법으로 사용되는 경우를 포함하여 
          이름을 사용하는 페이지를 처리하는 방법을 분명하게 정의하는 명세를 가집니다.

      : 중단 됨(discontinued)
      :: 폭넓은 검토를 받고 불충분함이 발견된 메타데이터 이름. 기존 페이지들이 이 메티데이터 이름을 
          사용하고 있지만, 새로운 페이지들은 그것을 방지해야(should) 합니다. "간단한 설명"과 "명세" 
          항목은 어떠한 것이라도, 작성자가 대신 사용해야 하는 것의 자세한 내용을 제공할 것입니다.

      메타데이터 이름이 기존 값과 중복된 것으로 발견되면, 그것은 제거되고 기존 값에 대한 동의어로 
      포함되어야(should) 합니다.

      메타데이터 사용되거나 명시되지 않고 이름이 한 달 이상 "제안 됨" 상태에 등록되어있다면, 
      레지스트리로부터 제거될 수 있습니다.

      메타데이터 이름이 "제안 됨" 상태로 추가되었고 기존 값과 중복되는 것이 발견된다면, 그것은 
      제거되고 기존 값에 대한 동의어로 포함되어야(should) 합니다. 메타데이터 이름이 "제안 됨" 상태로 
      추가되었고 위험한 것으로 발견된다면, 그것은 "중단 됨" 상태로 변경되어야(should) 합니다.

      누구든 언제든지 상태를 변경할 수 있지만, 위 정의에 따라서 그렇게만 해야(should) 합니다.

  <div class="impl">
    적합성 검사기는 값이 허용되었는지 아닌지를 확증하기 위해 WHATWG Wiki MetaExtensions 페이지에 
    주어진 정보를 사용할 수 있습니다: "중단 됨"으로 표기된 값이나 이 명세나 앞서 언급된 페이지에 
    포함되지 않은 값은 유효하지 않은 것으로 보고되어야(must) 하는데 반하여, 이 명세에 정의된 값이나 
    "제안 됨"이나 "승인 됨"으로 표시된 값은 받아들여져야(must) 합니다. 적합성 검사기는 이 정보를 
    캐시할 수 있습니다 (예를 들어, 성능상의 이유나 신뢰할 수 없는 네트워크 접속의 사용을 방지하기 
    위해).

    작성자가 이 명세 혹은 위키 페이지에 의해 정의되지 않은 새로운 메타데이터 이름을 사용하는 경우, 
    적합성 검사기는 위에 기술된 상세 내용을 가지고, "제안 됨" 상태로 위키에 값을 추가하도록 
    제안해야(should) 합니다.
  </div>

  값들이 <a for="url">URL</a>들이 되는 메타데이터 이름들은 제안되거나 받아들여지지 않아야(must) 합니다. 
  링크들은 <{meta}> 요소(element)가 아니라, <{link}> 요소(element)를 사용해서 표현되어야(must) 합니다.

<h5 id="pragma-directives">선처리(pragma) 지시자들</h5>

  <{meta}> 요소(element)에 <dfn><code>http-equiv</code></dfn> 속성(attribute)이 명시되어 있다면,
  요소(element)는 선처리(pragma) 지시자입니다.

  <code>http-equiv</code> 속성(attribute)은 <a lt="enumerated attribute">열거 속성</a>입니다. 다음 
  표는 이 속성(attribute)에 대해 정의된 키워드들을 나열합니다. 키워드와 함께 행들의 첫 번째 칸에 
  주어진 상태는 그 키워드가 일치하는 상태를 제공합니다. <span class="impl">마지막 열에 언급된 바와 
  같이 키워드의 일부는 부적합 합니다.</span>

  <table id="table-http-equiv">
    <thead>
      <tr>
        <th>상태</th>
        <th>키워드</th>
        <th>메모</th>
      </tr>
    </thead>
    <tbody>
      <tr class="impl">
        <td><a state for="http-equiv" lt="content-language">Content Language</a></td>
        <td><code>content-language</code></td>
        <td>부적합</td>
      </tr>
      <tr>
        <td><a state for="http-equiv" lt="content-type">Encoding declaration</a></td>
        <td><code>content-type</code></td>
        <td></td>
      </tr>
      <tr>
        <td><a state for="http-equiv" lt="default-style">Default style</a></td>
        <td><code>default-style</code></td>
        <td></td>
      </tr>
      <tr>
        <td><a state for="http-equiv" lt="refresh">Refresh</a></td>
        <td><code>refresh</code></td>
        <td></td>
      </tr>
      <tr class="impl">
        <td><a state for="http-equiv" lt="set-cookie">Cookie setter</a></td>
        <td><code>set-cookie</code></td>
        <td>부적합</td>
      </tr>
    </tbody>
  </table>

  <div class="impl">
    <{meta}> 요소(element)가 <a for="document" lt="inserted into the document">문서에 삽입</a>되는 
    경우, 그것의 <code>http-equiv</code> 속성(attribute)이 존재하고 위 상태 중 하나를 나타낸다면, 
    유저 에이전트는 다음 목록에 정의된 대로, 그 상태에 대해 적절한 알고리즘을 수행해야(must) 합니다:
  </div>

  <div class="impl">
    : <dfn state for="http-equiv" lt="content-language">콘텐트 언어 상태</dfn> (<code>http-equiv="content-language"</code>)
    ::
        <p class="note">
          이 기능은 부적합합니다. 작성자들은 대신 <{global/lang}> 속성(attribute)을 사용하도록
          권장됩니다.
        </p>

        이 선처리(pragma)는 <dfn lt="pragma-set default language">선처리 설정 기본 언어</dfn>를 
        설정합니다. 그 선처리(pragma)가 성공적으로 처리될 때까지, 
        <a lt="pragma-set default language">선처리 설정 기본 언어</a>가 존재하지 않습니다.

        1. <{meta}> 요소(element)가 <code>content</code> 속성(attribute)을 가지지 않는다면, 이 
            단계들을 중단합니다.
        2. 요소(element)의 <code>content</code> 속성(attribute)이 U+002C 콤마 문자 (,)를 포함한다면,
            이 단계들을 중단합니다.
        3. <var>input</var>을 요소(element)의 <code>content</code> 속성(attribute)의 값으로 둡니다.
        4. <var>position</var>를 <var>input</var>의 첫 번째 문자를 가리키게 합니다.
        5. <a lt="Skip whitespace">여백을 건너뜁니다</a>.
        6. <a lt="space characters">공백 문자들</a>이 아닌 
            <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다.
        7. <var>candidate</var>를 이전 단계로부터 결과로 나온 문자열로 둡니다.
        8. <var>candidate</var>가 빈 문자열이라면, 이 단계들을 중단합니다.
        9. <a lt="pragma-set default language">선처리 설정 기본 언어</a>를 <var>candidate</var>로 설정합니다.
            <p class="note">
              값이 공백으로 구분된 토큰들로 구성된다면, 첫 번째 이후 토큰들은 무시됩니다.
            </p>

        <p class="note">
          이 선처리(pragma)는 동일한 이름의 HTTP <code>Content-Language</code> 헤더와 동일하지 
          않습니다. 한 개 언어 태그를 초과한 HTTP <code>Content-Language</code> 값들은 이 
          선처리(pragma)에 의해 비유효한 것으로 거부될 것입니다. [[!HTTP]]
        </p>
  </div>

  : <dfn state for="http-equiv" lt="content-type|encoding declaration state">인코딩 선언 상태</dfn> (<code>http-equiv="content-type"</code>)
  :: <a state for="http-equiv" lt="content-type">인코딩 선언 상태</a>는 단지 <code>charset</code> 
      속성(attribute) 설정의 대체 형식입니다: 이것이 <a lt="character encoding declaration">문자 인코딩 선언</a>입니다.
      <span class="impl">이 상태의 유저 에이전트 요구사항들은 모두 명세의 해석 섹션에 의해 
      처리됩니다.</span>

      <a state for="http-equiv" lt="encoding declaration state">인코딩 선언 상태</a>에 있는 
      <code>http-equiv</code> 속성(attribute)을 가진 <{meta}> 요소(elements)들에 대해, 
      <code>content</code> 속성(attribute)은 <a lt="ASCII case-insensitive">ASCII 대소문자 구분 없이</a> 
      다음으로 구성된 문자열에 일치하는 값을 가져야 합니다: 리터럴 문자열 "<code>text/html;</code>", 
      그 뒤로 선택적으로 얼마든지의 <a lt="space characters">공백 문자들</a>, 그 뒤로 리터럴 문자열
      "<code>charset=</code>", 그 뒤로 <a lt="character encoding declaration">문자 인코딩 선언</a>의 
      <a lt="character encoding">문자 인코딩</a>의 <a lt="character encoding">레이블들</a> 중 하나.

      문서는 <a state for="http-equiv" lt="encoding declaration state">인코딩 선언 상태</a>에 있는 
      <code>http-equiv</code> 속성(attribute)을 가진 <{meta}> 요소(element)와 <code>charset</code> 
      속성(attribute)을 가진 <{meta}> 요소(element)를 모두 포함하지 않아야(must) 합니다.

      <a state for="http-equiv" lt="content-type">인코딩 선언 상태</a>는 
      <a lt="HTML documents">HTML 문서들</a>과 <a lt="XML Documents">XML 문서들</a>에서 사용될 수 
      있습니다. <a state for="http-equiv" lt="content-type">인코딩 선언 상태</a>가 
      <a lt="XML Documents">XML 문서들</a>에서 사용된다면, <a lt="character encoding">문자 인코딩</a>의 
      이름은 문자열 "<code>UTF-8</code>"에 대해 <a lt="ASCII case-insensitive">ASCII 대소문자 구분 없이</a> 
      일치해야(must) 합니다 (그리고 문서는 따라서 그것의 인코딩으로 UTF-8을 사용하도록 강제 됩니다).

      <p class="note">
        <a state for="http-equiv" lt="content-type">인코딩 선언 상태</a>는 XML 문서들에서 어떤 
        영향도 가지지 않고, XHTML로 그리고 XHTML로부터 마이그레이션을 가능하게 하기 위하여만 
        허용됩니다.
      </p>

  : <dfn state for="http-equiv" lt="default-style">기본 스타일 상태</dfn> (<code>http-equiv="default-style"</code>)
  :: 이 선처리(pragma)는 기본 <a lt="alternative style sheet set">대체 스타일 시트 세트</a>의 이름을 
      설정합니다.
      <div class="impl">
        1. <{meta}> 요소(element)가 <code>content</code> 속성(attribute)을 가지지 않거나, 그 
            속성(attribute)의 값이 빈 문자열이라면, 이 단계들을 중단합니다.
        2. <a lt="preferred style sheet set">우선되는 스타일 시트 세트</a>를 요소(element)의 
            <code>content</code> 속성(attribute)의 값으로 설정합니다. [[!CSSOM]]
      </div>

  : <dfn state for="http-equiv" lt="refresh">새로고침 상태</dfn> (<code>http-equiv="refresh"</code>)
  :: 이 선처리(pragma)는 시한(일정 시간 후 작동하도록 장치된) 리다이렉트로 동작합니다.
        1. <a state for="http-equiv" lt="refresh">새로고침 상태</a>에 있는 <code>http-equiv</code> 
            속성(attribute)을 가진 다른 <{meta}> 요소(element)는 이미 성공적으로 처리되었다면 (즉, 
            그것이 삽입될 때 유저 에이전트가 그것을 처리하고 <i>end</i>라고 라벨링 된 단계에 도달할 
            경우), 이 단계들을 중단합니다.
        2. <{meta}> 요소(element)가 <code>content</code> 속성(attribute)을 가지지 않거나, 그 
            속성(attribute)의 값이 빈 문자열이라면, 이 단계들을 중단합니다.
        3. <var>input</var>을 요소(element)의 <code>content</code> 속성(attribute)의 값으로 둡니다.
        4. <var>position</var>을 <var>input</var>의 첫 번째 문자를 가리키게 합니다.
        5. <a lt="Skip whitespace">여백을 건너뜁니다</a>.
        6. <a lt="ASCII digits">ASCII 숫자들</a>인 <a lt="Collect a sequence of characters">일련의 
            문자를 수집</a>하고, <a lt="rules for parsing non-negative integers">음이 아닌 정수 
            해석에 대한 규칙</a>을 사용하여 결과 문자열을 해석합니다. 수집된 일련의 문자들이 빈 
            문자열이라면, 번호가 해석되지 않을 것입니다; 이 단계들을 중단합니다. 그렇지 않으면, 
            <var>time</var>을 해석된 숫자로 둡니다.
        7. <a lt="ASCII digits">ACSII 숫자들</a>이고 U+002E 마침표 문자 (.)인 
            <a lt="Collect a sequence of characters">일련의 문자를 수집</a>합니다. 수집된 모든 
            문자들을 무시합니다.
        8. <var>url</var>을 <{meta}> 요소(element)의 <a lt="node document">노드 문서</a>의 
            <a for="url">URL</a>로 둡니다.
        9. <var>position</var>이 <var>input</var>의 끝을 지났다면, <i>end</i>라고 라벨링 된 단계로 
            건너뜁니다.
        10. <var>position</var>에 의해 가리켜진 <var>input</var> 내 문자가 U+003B 세미콜론 문자 (;)나, 
            U+002C 콤마 문자 (,)나, <a lt="space character">공백 문자</a>가 아니라면, 이 단계들을 
            중단합니다.
        11. <a lt="Skip whitespace">여백을 건너뜁니다</a>.
        12. <var>position</var>에 의해 가리켜진 <var>input</var> 내 문자가 U+003B 세미콜론 문자 (;)나, 
            U+002C 콤마 문자 (,) 라면, <var>position</var>을 다음 문자로 전진시킵니다.
        13. <a lt="Skip whitespace">여백을 건너뜁니다</a>.
        14. <var>position</var>이 <var>input</var>의 끝을 지났다면, <i>end</i>라고 라벨링 된 단계로 
            건너뜁니다.
        15. <var>url</var>을 <var>position</var>에 있는 문자로부터 문자열의 끝까지 <var>input</var>의 
            부분 문자열과 같게 합니다.
        16. <var>position</var>에 의해 가리켜진 <var>input</var> 내 문자가 U+0055 라틴 대문자 U 
            (U)이거나 U+0075 라틴 소문자 U (u)라면, <var>position</var>을 다음 문자로 전진시킵니다. 
            그렇지 않으면, <i>skip quotes</i>로 라벨링 된 단계로 건너뜁니다.
        17. <var>position</var>에 의해 가리켜진 <var>input</var> 내 문자가 U+0052 라틴 대문자 R 
            (R)이거나 U+0072 소문자 R (r)이라면, <var>position</var>을 다음 문자로 전진시킵니다. 
            그렇지 않으면, <var>Parse</var>라고 라벨링 된 단계로 건너뜁니다.
        18. <var>position</var>에 의해 가리켜진 <var>input</var> 내 문자가 U+004C 라틴 대문자 L 
            (L)이거나 U+006C 라틴 소문자 L (l)이라면, <var>position</var>을 다음 문자로 전진시킵니다. 
            그렇지 않으면 <var>Parse</var>라고 라벨링 된 단계로 건너뜁니다.
        19. <a lt="Skip whitespace">여백을 건너뜁니다</a>.
        20. <var>position</var>에 의해 가리켜진 <var>input</var> 내 문자가 U+003D 등호 기호 (=)라면, 
            <var>position</var>를 다음 문자로 전진시킵니다. 그렇지 않으면, <var>Parse</var>로 라벨링 
            된 단계로 건너뜁니다.
        21. <a lt="Skip whitespace">여백을 건너뜁니다</a>.
        22. <i>Skip quotes</i>: <var>position</var>에 의해 가리켜진 <var>input</var> 내 문자가 
            U+0027 어포스트로피 문자 (')나 U+0022 따옴표 문자 (")라면, <var>quote</var>를 그 문자로 
            두고, <var>position</var>을 다음 문자로 전진시킵니다. 그렇지 않으면, <var>quote</var>를
            빈 문자열로 둡니다.
        23. <var>url</var>을 <var>position</var>에 있는 문자부터 문자열의 끝까지 <var>input</var>의 
            부분 문자열과 같게 합니다.
        24. <var>quote</var>가 빈 문자열이 아니고, <var>url</var> 내에 <var>quote</var>와 동일한 
            문자가 있다면, 그 문자에서 <var>url</var>을 버리기 때문에, 그것과 모든 다음의 문자들은 
            제거됩니다.
        25. <var>Parse</var>: <{meta}> 요소(element)의 <a lt="node document">노드 문서</a>에 
            관련하여 <var>url</var>을 <a lt="parse">해석합니다</a>. 그것이 실패한다면, 이 단계들을 
            중단합니다. 그렇지 않으면, <var>urlRecord</var>을 <a lt="resulting URL record">결과 URL 
            레코드</a>로 둡니다.
        26. <i>End</i>: 다음 단계들 중 하나 이상을 수행합니다:
            * 새로 고침이 완료 된 후 (아래 정의된 대로), 사용자가 리다이렉트를 취소하지 않았고 
                <{meta}> 요소(element)의 <a lt="node document">노드 문서</a>의 
                <a lt="active sandboxing flag set">활성화 샌드박싱 플래그 세트</a>가 
                <a lt="sandboxed automatic features browsing context flag">샌드박스 된 자동 기능 브라우징 컨텍스트 플래그</a> 
                세트를 가지지 않는다면, {{Document}}의 <a lt="browsing context">브라우징 컨텍스트</a>를 
                <a lt="replacement enabled">교체 가능</a>하고, 그리고 
                <a lt="source browsing context">소스 브라우징 컨텍스트</a>로서 {{Document}}'의 
                <a lt="browsing context">브라우징 컨텍스트</a>를 가진 <var>urlRecord</var>로 
                <a lt="navigate">탐색</a> 합니다.

                이전 문단의 목적을 위해, 새로고침은 다음 두 조건 발생 <em>이후</em> 즉시 만료된다고 
                합니다:
                * 사용자나 유저 에이전트 환경을 고려하여 조정된 문서가 
                    <a lt="completely loaded">완전히 로드</a>된 이후 최소한 <var>time</var> 초가 
                    경과.
                * 사용자나 유저 에이전트 환경을 고려하여 조정된 
                    <a for="document" lt="inserted into the document">문서에 <{meta}> 요소(element)가 
                    삽입된</a> 이후 최소한 <var>time</var> 초가 경과.
            * <a lt="source browsing context">소스 브라우징 컨텍스트</a>로서 {{Document}}의 
                <a lt="browsing context">브라우징 컨텍스트</a>를 가지고, 
                <a lt="browsing context">브라우징 컨텍스트</a>를 <var>urlRecord</var>로 
                <a lt="navigates">탐색하는</a> 인터페이스를 사용자에게 제공합니다.
            * 아무 것도 하지 않습니다.

            그밖에, 유저 에이전트는, 어떠한 것이라도, 모든 타이머의 상태, 시간이 초과된 모든 
            리다이렉션의 목적지 등등을 포함하여 작동의 모든 측면을 예외 없이 사용자에게 알릴 수 
            있습니다.

      <a state for="http-equiv" lt="refresh">새로고침 상태 </a> 상태에 있는 <code>http-equiv</code> 
      속성(attribute)을 가진 <{meta}> 요소(element)들에 대해, <code>content</code> 속성(attribute)은 
      다음으로 구성되는 값을 가져야(must) 합니다:

      * <a lt="valid non-negative integer">유효한 음이 아닌 정수</a>, 혹은
      * <a lt="valid non-negative integer">유효한 음이 아닌 정수</a>, 그 뒤로 U+003B 세미콜론 문자 
        (;), 그 뒤로 하나 이상의 <a lt="space characters">공백 문자들</a>, 그 뒤로 문자열 
        "<code>URL</code>"에 <a lt="ASCII case-insensitive">ASCII 대소문자 구분 없이</a> 일치하는 
        부분 문자열, 그 뒤로 U+003D 등호 기호 (=), 그 뒤로 리터럴 U+0027 어포스트로피 문자 (')나 
        U+0022 따옴표 문자 (")로 시작하지 않는 <a lt="valid URL">유효한 URL</a>.

      전자의 경우, 정수는 페이지가 리로드 되기 전 몇 초를 나타냅니다; 후자의 경우 정수는 주어진 
      <a for="url">URL</a>로 페이지가 교체되기 몇 초 전을 나타냅니다.

      <div class="example">
        뉴스 조직의 프론트 페이지는 매 5분 마다 서버로부터 페이지가 자동으로 리로드 되는 것을 
        보장하기 위해, 페이지의 <{head}> 요소(element)에 다음 마크업을 포함할 수 있습니다:

        <pre highlight="html">&lt;meta http-equiv="Refresh" content="300"&gt;</pre>
      </div>

      <div class="example">
        일련의 페이지는 다음과 같은 마크업을 사용하여, 순서에 따라 각 페이지가 다음 페이지로 새로고침
        되도록 만드는 것에 의해 자동적인 슬라이드 쇼로 사용될 수 있습니다:

        <pre highlight="html">&lt;meta http-equiv="Refresh" content="20; URL=page4.html"&gt;</pre>
      </div>

    : <dfn state for="http-equiv" lt="set-cookie">쿠키 설정자</dfn> (<code>http-equiv="set-cookie"</code>)
    :: 이 선처리(pragma)는 HTTP 쿠키를 설정합니다. [[!COOKIES]]

        이것은 부적합 합니다. 실제 HTTP 헤더들이 대신 사용되어야(should) 합니다.

        1. <{meta}> 요소(element)가 <code>content</code> 속성(attribute)을 가지지 않거나 그
            속성(attribute)의 값이 빈 문자열이라면, 이 단계들을 중단합니다.
        2. "비 HTTP" API를 통해 <a lt="encoded as UTF-8">UTF-8로 인코드 된</a> 요소(element)의 
            <code>content</code> 속성(attribute) 값으로 구성되는, 
            <a lt="the document's address">문서의 주소</a>에 대해 
            <a lt="receiving a set-cookie-string">쿠키 설정 문자열을 수신</a>하는 것 처럼 행동합니다.
            [[!COOKIES]] [[!ENCODING]]

    : <dfn state for="http-equiv" lt="Content security policy state">콘텐트 보안 정책 상태</dfn> (<code>http-equiv="content-security-policy"</code>)
    :: 이 선처리(pragma)는 {{Document}}에 <a lt="Content Security Policy">콘텐트 보안 정책</a>을 
        <a lt="enforced">강제</a> 합니다. [[CSP3]]

        1. <{meta}> 요소(element)가 <{head}> 요소(element)의 자식이 아니라면, 이 단계들을 중단합니다.
        2. <{meta}> 요소(element)가 <{meta/content}> 속성(attribute)을 가지지 않거나, 그 
            속성(attribute)의 값이 빈 문자열이라면, 이 단계들을 중단합니다.
        3. <var>policy</var> 를 <{meta}> 요소(element)의 <{meta/content}> 속성(attribute)의 값에 
            콘텐트 보안 정책의 <a lt="parse a serialized Content Security Policy">직렬화 된 콘텐트 
            보안 정책 해석</a>을 실행한 결과로 둡니다.
        4. <var>policy</var>부터의 <a><code>report-uri</code></a>, 
            <a><code>frame-ancestors</code></a>, <a><code>sandbox</code></a> 
            <a lt="directives">지시자들</a>의 모든 발생들을 제거합니다.
        5. <var>policy</var> <a lt="Enforce the policy">정책을 강제합니다</a>.

        <a state for="http-equiv" lt="Content security policy state">콘텐트 보안 정책 상태</a>에 
        있는 <{meta/http-equiv}> 속성(attribute)을 가진 <{meta}> 요소(element)들에 대해, 
        <{meta/content}> 속성(attribute)은 <a lt="valid Content Security Policy">유효한 콘텐트 보안 
        정책</a>으로 구성되는 값을 가져야(must) 하고, 어떤 <a><code>report-uri</code></a>나, 
        <a><code>frame-ancestors</code></a>나, <a><code>sandbox</code></a> 
        <a lt="directives">지시자들</a>을 포함하지 않아야(must) 합니다. <{meta/content}> 
        속성(attribute)에 주어진 <a lt="Content Security Policy">콘텐트 보안 정책</a>은 현재 문서에 
        <a lt="enforced">강제</a>될 것입니다.

        <div class="example">
        페이지는 다음과 같은 정책을 사용하여, 모든 플러그인 콘텐트를 차단할 뿐 아니라, 인라인 
        자바스립트의 실행을 막음으로써 교차 사이트 스크립팅 공격의 위험성을 완화시키기 위해 선택할 
        수 있습니다:
          <pre highlight="html">
            &lt;meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none'">
          </pre>
        </div>

  한 번에 문서에 어떤 특정 상태를 가진 <{meta}> 요소(element)는 하나를 초과하여 존재하지 않아야(must) 
  합니다.

<h5 id="other-pragma-directives">다른 선처리(pragma) 지시자들</h5>

  <dfn lt="Extensions to the predefined set of pragma directives">선처리(pragrm) 지시자들의 미리 정의된 세트에 대한 확장들</dfn>은 
  특정 조건 하에, <a lt="WHATWG Wiki PragmaExtensions page">WHATWG Wiki PragmaExtensions 페이지</a>에 
  등록될 수 있습니다.

  그 확장들은 영구 메시지 헤더 필드 레지스트리에 등록된 HTTP 헤더와 같은 이름을 사용해야(must) 하고, 
  HTTP 헤더에 대해 기술된 것과 같은 동작을 가져야(must) 합니다. [[!IANAPERMHEADERS]]

  메타데이터를 설명하는 헤더에 해당하는 선처리(Pragma) 지시자들이나, 특정 유저 에이전트 처리를 
  요구하지 않는 선처리(Pragma) 지시자들은 등록되지 않아야(must) 합니다; 대신에, 
  <a lt="metadata names">메타데이터 이름들</a>을 사용하세요. HTTP 처리 모델에 (예를 들어, 캐싱) 
  영향을 주는 헤더에 해당하는 선처리(Pragma) 지시자들은 그것들은 HTTP 수준 동작에서 HTML을 구현하는 
  유저 에이전트들과 그렇지 않은 유저 에이전트들에 차이가 발생될 것이기 때문에, 등록되지 않아야(must) 
  합니다.

  누구든지 이 조건들을 만족하는 선처리(pragma) 지시자를 추가하기 위해 언제든지 
  <a lt="WHATWG Wiki PragmaExtensions page">WHATWG Wiki PragmaExtensions 페이지</a>를 자유롭게 
  수정할 수 있습니다. 그 등록들은 다음 정보를 명시해야(must) 합니다:

  : 키워드(keyword)
  :: 정의되는 실제 이름. 이름은 동일한 요구사항을 가진 앞서 등록된 HTTP 이름과 일치해야(must) 합니다.

  : 간단한 설명(brief description)
  :: 선처리(pragma) 지시자의 목적에 대한 짧은 비 규범적 설명.

  : 명세(specification)
  :: 해당하는 HTTP 헤더를 정의하는 명세로의 링크.

  <div class="impl">
    적합성 검사기는 값이 허용되었는지 아닌지를 확증하기 위해 
    <a lt="WHATWG Wiki PragmaExtensions">WHATWG Wiki PragmaExtensions 페이지</a>에 주어진 정보를 
    사용해야(must) 합니다: 이 명세나 앞서 언급된 페이지에 언급되지 않은 값들이 유효하지 않은 것으로 
    거부되어야(must) 하는데 반하여, 이 명세에 정의된 값이나 앞서 언급된 페이지에 언급된 값들은 
    허용되어야(must)합니다. 적합성 검사기는 이 정보를 캐시할 수 있습니다 (예를 들어, 성능상의 이유나 
    신뢰할 수 없는 네트워크 접속의 사용을 방지하기 위해).
  </div>

<h5 id="specifying-the-documents-character-encoding">문서의 문자 인코딩 명시하기</h5>

  <dfn lt="character encoding declaration">문자 인코딩 선언</dfn>은 문서를 저장하거나 전송하는데 
  사용되는 명시된 <a lt="character encoding">문자 인코딩</a>에 의한 메커니즘입니다.

  다음 제약 사항들이 <a lt="character encoding declarations">문자 인코딩 선언</a>에 적용됩니다:

  * 주어진 문자 인코딩 이름은 파일 직렬화에 사용된 <a lt="character encoding">문자 인코딩</a>의 
      <a lt="character encoding">레이블들</a> 중 하나에 
      <a lt="ASCII case-insensitive">ASCII 대소문자 구분 없이</a> 일치해야(must) 합니다. 
      [[!ENCODING]]
  * 문자 인코딩 선언은 <a lt="character references">문자 참조들</a>이나 어떤 종류의 문자 
      이스케이프의 사용 없이 직렬화 되어야(must) 합니다.
  * 문자 인코딩 선언을 포함하는 요소(element)는 문서의 <dfn lt="the first 1024 bytes">처음 1024 
      바이트</dfn> 내에서 완전히 직렬화 되어야(must) 합니다.

  게다가, <{meta}> 요소(element)들에 몇 가지 제약 사항 때문에, 문서 당 하나의 <code>meta</code> 
  기반 문자 인코딩 선언만 존재 할 수 있습니다.

  <a lt="HTML document">HTML 문서</a>가 BOM으로 시작하지 않고 그것의 <a lt="encoding">인코딩</a>이 
  명시적으로 <a lt="Content-Type metadata">Content-Type 메타데이터</a>에 의해 주어지지 않고, 문서가 
  <a lt="iframe srcdoc document"><code>iframe</code> <code>srcdoc</code> 문서</a>가 아니라면, 사용된 
  문자 인코딩은 <a lt="ASCII-compatible encoding">ASCII 호환 인코딩</a>이어야(must) 하고, 인코딩은 
  <code>charset</code> 속성(attribute)을 가진 <{meta}> 요소(element)나 
  <a state for="http-equiv" lt="content-type">인코딩 선언 상태</a>에 있는 <code>http-equiv</code> 
  속성(attribute)을 가진 <{meta}> 요소(element)를 사용하여 명시되어야(must) 합니다.

  <p class="note">
    인코딩이 US-ASCII일 지라도, 문자 인코딩이 양식, 스크립트에 의해 생성된 URL들 등에서 사용자에 
    의해 입력된 비 ASCII 문자들을 처리하기 위해 필요하기 때문에, 문자 인코딩 선언은 
    (<a lt="Content-Type metadata">Content-Type 메타데이터</a>나 파일에 명시적으로) 요구됩니다.
  </p>

  문서가 <a lt="iframe srcdoc document"><code>iframe</code> <code>srcdoc</code> 문서</a>라면, 
  문서는 <a lt="character encoding declaration">문서 인코딩 선언</a>을 가지지 않아야(must) 합니다. 
  (이 경우에는, <{iframe}>가 포함된 문서의 일부이기 때문에 소스는 이미 디코드 되어있습니다). 

  <a lt="HTML document">HTML 문서</a>가 <code>charset</code> 속성(attribute)을 가진 <{meta}> 
  요소(element)나 <a state for="http-equiv" lt="content-type">문자 인코딩 상태</a>에 있는 
  <code>http-equiv</code> 속성(attribute)을 가진 <{meta}> 요소(element)를 포함한다면, 사용된 문자 
  인코딩은 <a lt="ASCII-compatible encoding">ASCII 호환 인코딩</a>이어야(must) 합니다.

  작성자들은 <a lt="UTF-8">UTF-8</a>을 사용해야(should) 합니다. 적합성 검사기들은 작성자들이 레거시 
  인코딩을 사용하지 않도록 조언할 수 있습니다. [[!ENCODING]]

  작성 도구들은 새롭게 생성되는 문서들에 대해 <a>UTF-8</a> 사용을 기본으로 해야(should) 합니다. 
  [[!ENCODING]]

  작성자들은 WHATWG 인코딩 표준에 정의되지 않은 인코딩을 사용하지 않아야(must) 합니다. 추가적으로, 
  작성자들은 <a>ISO-2022-JP</a>를 사용하지 않아야(should) 합니다. [[!ENCODING]]

  <p class="note">
    WHATWG 인코딩 표준에 정의되지 않은 일부 인코딩들은, U+0020부터 U+007E까지 범위에 해당하는 
    문자들과 다른 문자들을 인코드하기 위해,  0x20부터 0x7E까지의 범위의 바이트를 사용하고, 잠재적인 
    보안 취약점을 나타냅니다: 유저 에이전트는 아마도 정상적인 평문 콘텐트를 HTML 태그와 자바스크립트로 
    해석하게 될 수도 있습니다.
  </p>

  <p class="translator-note">
	위 Note 부분은 일부 번역이 잘못 되었을 수 있습니다.
  </p>

  <p class="note">
    비 UTF-8 인코딩을 사용하는 것은 기본 값으로 <a lt="document's character encoding">문서의 문자 
    인코딩</a>을 사용하는 양식 제출과 URL 인코딩에서 예기치 않은 결과를 가져 올 수 있습니다.
  </p>

  XHTML에서, 필요하다면, XML 선언은 인라인 문자 인코딩 정보에 사용되어야(should) 합니다.

  <div class="example">
    HTML에서, 문자 인코딩이 UTF-8임을 선언하기 위해, 작성자는 문서의 상단 가까이에 (<{head}> 
    요소(element) 안에) 다음 마크업을 포함할 수 있습니다:

    <pre highlight="html">&lt;meta charset="utf-8"&gt;</pre>

    XML에서, 마크업의 최 상단에, XML 선언이 대신 사용될 것입니다:

    <pre highlight="html">&lt;?xml version="1.0" encoding="utf-8"?&gt;</pre>
  </div>

<h4 id="the-style-element"><dfn element><code>style</code></dfn> 요소(element)</h4>

  <dl class="element">
    <dt><a lt="Categories">카테고리</a>:</dt>
    <dd><a lt="Metadata content">메타데이터 콘텐트</a>.</dd>
    <dt><a lt="Contexts in which this element can be used">이 요소(element)가 사용될 수 있는 컨텍스트</a>:</dt>
    <dd>
      <a lt="metadata content">메타데이터 콘텐트</a>가 기대 되는 곳.
    </dd>
    <dd>
      <{head}> 요소(element)의 자식인 <{noscript}> 요소(element) 안.
    </dd>
    <dt><a lt="Content model">콘텐트 모델</a>:</dt>
    <dd>
      <code>type</code> 속성(attribute)의 값에 달려있지만, 아래 본문에 기술된 요구사항들에 
      일치해야(must) 합니다.
    </dd>
    <dt><a lt="Tag omission in text/html">text/html에서 태그 생략</a>:</dt>
    <dd>어느 태그도 생략 가능하지 않습니다.</dd>
    <dt><a lt="Content attributes">콘텐트 속성(attribute)들</a>:</dt>
    <dd><a lt="Global attributes">범용 속성(attribute)들</a></dd>
    <dd><code>media</code> — 적용 가능한 매체</dd>
    <dd><{style/nonce}> - <em>콘텐트 보안 정책</em> 검사에 사용되는 암호화 임시값 [[CSP3]]</dd>
    <dd><code>type</code> — 삽입된 리소스의 유형</dd>
    <dd>
      또한, <{style/title}> 속성(attribute)은 이 요소(element)에서 특별한 의미를 가집니다: 대체 
      스타일 시트 세트 이름.
    </dd>
    <dt>허용된 <a href="#aria-role-attribute">ARIA 역할(role) 속성(attribute)</a> 값들:</dt>
    <dd>없음</dd>
    <dt>허용된 <a href="#state-and-property-attributes">ARIA 상태(state)와 속성(property) 속성(attribute)들</a>:</dt>
    <dd><a lt="Global aria-* attributes">범용 aria-* 속성(attribute)들</a></dd>
    <dt><a lt="DOM interface">DOM 인터페이스</a>:</dt>
    <dd>
      <pre class="idl" data-highlight="webidl" dfn-for="HTMLStyleElement">
        interface HTMLStyleElement : HTMLElement {
          attribute DOMString media;
          attribute DOMString nonce;
          attribute DOMString type;
        };
        HTMLStyleElement implements LinkStyle;
      </pre>
    </dd>
  </dl>

  <p class="warning">CSP3 지시자에 기반한 <{style}> 요소(element)를 차단하는 네이티브 구현은 알려진 것이 없습니다. 따라서 이 기능은 신뢰되지 않아야(should) 합니다.</p>
  
  <{style}> 요소(element)는 작성자들이 그들의 문서에 스타일 정보를 삽입시키는 것을 허용합니다. 
  <{style}> 요소(element)는 스타일링 처리 모델에 몇 가지 입력 중 하나입니다. 요소(element)는 
  사용자에게 콘텐트를 <a lt="represent">나타내지</a> 않습니다. 

  <dfn element-attr for="style"><code>type</code></dfn> 속성(attribute)은 스타일링 언어를 제공합니다. 
  속성(attribute)이 존재한다면, 그 값은 스타일링 언어를 지정하는 <a lt="valid mime type">유효한 MIME 
  타입</a>이어야(must) 합니다. <code>charset</code> 파라미터는 명시되지 않아야(must) 합니다. 
  속성(attribute)이 존재하지 않는다면 사용되는 <code>type</code> 속성(attribute)에 대한 기본 값은
  "<code>text/css</code>"입니다. [[!RFC2318]]

  <div class="impl">
    언어를 지원하는지를 결정하기 위해 유형들을 검토할 경우, 유저 에이전트들은 알려지지 않은 MIME 
    파라미터들을 무시하지 않아야(must) 합니다 — 알려지지 않은 파라미터들을 가진 유현들은 지원되지 
    않는 것으로 간주되어야(must) 합니다. <code>charset</code> 파라미터는 여기 
    <a lt="MIME types">MIME 타입들</a>과 비교할 목적을 위해 알려져지 않은 파라미터로 취급되어야(must) 
    합니다.
  </div>

  <dfn element-attr for="style"><code>media</code></dfn> 속성(attribute)은 스타일이 적용되는 매체를 
  알립니다. 값은 <a lt="valid media query list">유효한 미디어 쿼리 목록</a>이어야(must)합니다. 
  <span class="impl">유저 에이전트는 <code>media</code> 속성(attribute)의 값이 
  <a lt="matches the environment">환경과 일치</a>하고 다른 관련 조건들이 적용되는 경우 스타일을 
  적용해야(must)하고, 그렇지 않으면 적용하지 않아야(must) 합니다.</span>

  <div class="impl">
    <p class="note">
      스타일은 범위에 따라, 예를 들어 <code>@media</code> 블럭을 사용하는 CSS에서, 더 제한될 수 
      있습니다. 이 명세는 그러한 추가적인 제약 사항이나 요구사항들을 재정의 하지 않습니다.
    </p>
  </div>

  <code>media</code> 속성(attribute)이 생략되었다면, 기본 값은 기본적으로 스타일이 모든 매체에 적용 
  됨을 의미하는 "<code>all</code>"입니다.

  <p class="note">
    <{style}> 요소(element)는 문서의 <{head}>에 나타나도록 제한됩니다.
  </p>

  <dfn element-attr for="style"><code>nonce</code></dfn> 속성(attribute)은 요소(element)에 의해 
  명시된 스타일이 문서에 적용될 것인지 아닌지를 결정하기 위해 <a lt="Content Security Policy">콘텐트 
  보안 정책</a>으로 사용될 수 있는 암호화 임시 값("한 번 사용되는 숫자")을 나타냅니다. 값은 텍스트 
  입니다. [[CSP3]]

  <{style}> 요소(element)들의 <dfn element-attr for="style"><code>title</code></dfn> 속성(attribute)은 
  <a lt="alternative style sheet sets">대체 스타일 시트 세트들</a>을 정의합니다. <{style}> 
  요소(element)가 <code>title</code> 속성(attribute)을 가지지 않는다면, 제목(title)을 가지지 않습니다; 
  조상들의 <code>title</code> 속성(attribute)은 <{style}> 요소(element)에 영향을 주지 않습니다. 
  [[!CSSOM]]

  <p class="note">
    <{style}> 요소(element)들의 <code>title</code> 속성(attribute)은 <{link}> 요소(element)들의
    <code>title</code> 속성(attribute)과 같이, 제목(title)이 없는 <code>style</code> 블럭이 부모 
    요소(element)의 제목(title)을 상속하지 않는 점에서 범용 <code>title</code> 속성(attribute)과 
    다릅니다: 그것은 단지 제목(title)을 가지지 않습니다.
  </p>

  <{style}> 요소(element)의 {{Node/textContent}}는 유니코드인 문자 세트인 다음 ABNF의 
  <code>style</code> 산출물과 일치해야(must) 합니다. [[!ABNF]]

  <pre data-highlight="abnf">
    style         = no-c-start *( c-start no-c-end c-end no-c-start )
    no-c-start    = &lt; any string that doesn't contain a substring that matches c-start &gt;
    c-start       = "&lt;!--"
    no-c-end      = &lt; any string that doesn't contain a substring that matches c-end &gt;
    c-end         = "--&gt;"
  </pre>

  <hr />

  <div class="impl">
    유저 에이전트는 다음 조건들 중 하나가 발생할 때 마다, 요소(element)의 
    <dfn lt="style data">스타일 데이터</dfn>를 전달하여, <{style}> 요소(element)의 <{style/type}> 
    속성(attribute)에 의해 명시된 스타일 시트 언어에 대해 적용하는 
    <dfn lt="update a style block"><code>style</code> 블럭 업데이트</dfn> 알고리즘을 수행해야(must) 
    합니다:

    * 요소(element)가 <a lt="HTML parser">HTML 해석기</a>나 <a lt="XML parser">XML 해석기</a>의 
        <a lt="stack of open elements">열린 요소(element)들의 스택</a>에서 사라진 경우,
    * 요소(element)가 <a lt="HTML parser">HTML 해석기</a>나 <a lt="XML parser">XML 해석기</a>의 
        <a lt="stack of open elements">열린 요소(element)들의 스택</a>에 없고, 
        <a for="document" lt="inserted into a document">문서로 삽입</a>되거나 
        <a for="document" lt="removed from a document">문서에서 제거</a>되는 경우,
    * 요소(element)가 <a lt="HTML parser">HTML 해석기</a>나 <a lt="XML parser">XML 해석기</a>의 
        <a lt="stack of open elements">열린 요소(element)들의 스택</a>에 없고, 그것의 자식 노드들 중 
        하나가 스크립트에 의해 수정되는 경우,

    순수 텍스트로 구성된 스타일링 언어에 대한 (XML과 반대로), <code>style</code> 요소(element)의 
    <a lt="style data">스타일 데이터</a>는 <a lt="tree order">트리 순서</a>에 따라, <{style}> 
    요소(element)의 자식인 모든 <code>Text</code> 노드들의 (주석들이나 요소(element)들 같은 다른 
    노드들이 아닌) 콘텐트의 연결입니다. XML 기반 스타일링 언어에 대한, <a lt="style data">스타일 
    데이터</a>는 <{style}> 요소(element)의 모든 자식 노드들로 구성됩니다.

    CSS(<code>text/css</code>)에 대한 <a lt="update a style block"><code>style</code> 블럭 업데이트</a> 
    알고리즘은 다음과 같습니다:

    1. <var>element</var>를 <{style}> 요소(element)로 둡니다.
    2. <var>element</var>가 <a spec="cssom" lt="associated CSS style sheet">연관된 CSS 스타일 시트</a>를 
        가진다면, 문제의 <a spec="cssom" lt="remove a CSS style sheet">CSS 스타일 시트를 제거</a>합니다.
    3. <var>element</var>가 <a lt="in a Document"><code>Document</code> 안에</a> 없다면, 이 단계들을 
        중단합니다.
    4. <a lt="Should element's inline behavior be blocked by Content Security Policy?">요소(element)의 인라인 동작은 콘텐트 보안 정책에 의해 차단되어야(should) 하는가?</a> 
        알고리즘이 <{style}> 요소(element)에서 실행된 경우 "<code>Blocked</code>"와, 
        "<code>style</code>", 그리고 <{style}> 요소(element)의 <a lt="style data">스타일 데이터</a>를 
        반환한다면, 이 단계들을 중단합니다. [[CSP3]]
    5. 다음 속성(property)들을 가지고 
        <a spec="cssom" lt="create a CSS style sheet">CSS 스타일 시트를 생성</a>합니다:

        : <{style/type}>
        :: <code>text/css</code>
        : <a lt="owner node">소유자 노드</a>
        :: <var>element</var>
        : <{style/media}>
        :: <var>element</var>의 <code>media</code> 속성(attribute) .
            <p class="note">
              이것은 속성(attribute)의 현재 값의 복사본 보다는, 속성(attribute)에 대한 (아마도 
              현재는 없을 수도 있습니다) 참조입니다. CSSOM 명세는 속성(attribute)이 동적으로 설정, 
              변경, 제거될 때 일어나는 것을 정의합니다.
            </p>
        : <{style/title}>
        :: <var>element</var>의 <{style/title}> 속성(attribute).
            <p class="note">다시, 이것은 속성(attribute)에 대한 <em>참조</em>입니다.</p>
        : <a lt="alternate flag">대체 플래그</a>
        :: 해제.
        : <a lt="origin-clean flag">origin-clean 플래그</a>
        :: 설정.
        : <a lt="parent CSS style sheet">부모 CSS 스타일 시트</a>
        : <a lt="owner CSS rule">소유자 CSS 규칙</a>
        :: null
        : <a lt="disabled flag">비활성 플래그</a>
        :: 기본 값으로 남음.
        : <a lt="CSS rules">CSS 규칙들</a>
        :: 초기화되지 않은 채로 남음.

    이 명세는 다른 스타일링 언어의 <i><code>style</code> 블럭 업데이트</i> 알고리즘을 정의하지 
    않습니다.

    스타일 시트의 <a lt="critical subresources">중요한 하위 리소스들</a>이 있는 경우 이를 얻기 위한 
    시도가 완료되거나, 스타일 시트가 <a lt="critical subresources">중요한 하위 리소스들</a>을 가지지 
    않는 경우 스타일 시트가 해석되고 처리될 때, 유저 에이전트는 로드가 성공적이거나 
    <a lt="critical subresources">중요한 하위 리소스들</a>이 없었다면 <{style}> 요소(element)에 
    <code>load</code>라고 이름이 붙은 <a lt="fire a simple event">단순 이벤트를 발생</a>시키기 위한 
    <a lt="queue a task">작업을 대기열에 넣어야</a>(must) 하거나, 스타일 시트의 
    <a lt="critical subresources">중요한 하위 리소스들</a> 중 하나가 어떤 이유로 (예를 들어, DSN 오류,
    HTTP 404 응답, 너무 빨리 닫히는 연결, 지원되지 않은 Content-Type) 완전한 로드가 실패되었다면 
    <{style}> 요소(element)에  <code>error</code> 라고 이름이 붙은 <a lt="fire a simple event">단순 
    이벤트를 발생</a>시키기 위한 <a lt="queue a task">작업을 대기열에 넣어야</a>(must) 합니다. 스타일 
    시트나 그것의 하위 리소스들 처리에서 비 네트워크 오류는 (예를 들어, CSS 해석 오류들, PNG 디코딩 
    오류들) 이 단락의 목적에 대한 실패가 아닙니다.

    이 <a lt="tasks">작업들</a>에 대한 <a lt="task source">작업 소스</a>는 
    <a lt="DOM manipulation task source">DOM 조작 작업 소스</a>입니다.

    요소(element)는 스타일 시트의 <a lt="critical subresources">하위 리소스들</a>이 있다면 이들을 
    획득하기 위한 모든 시도가 완료될 때까지, 요소(element)의 <a lt="node document">노드 문서</a>의 
    <a lt="delay the load event">로드 이벤트를 지연</a>시켜야(must) 합니다.
  </div>

  <p class="note">
    이 명세는 스타일 시스템을 명시하지 않지만, CSS는 대다수 브라우저에 의해 지원되는 것으로 
    예상됩니다. [[!CSS-2015]]
  </p>

  <div class="impl">
    <dfn attribute for="HTMLStyleElement"><code>media</code></dfn>,
    <dfn attribute for="HTMLStyleElement"><code>nonce</code></dfn>, 
    <dfn attribute for="HTMLStyleElement"><code>type</code></dfn>
    IDL 속성(attribute)들은 각각의 동일한 이름의 콘텐트 속성(attribute)들을 
    <a lt="reflect">반영</a>해야(must) 합니다.
  </div>

  <code>LinkStyle</code> 인터페이스 또한 이 요소(element)에 의해 구현됩니다. [[!CSSOM]]

  <div class="example">
    다음 문서는 작품의 제목(title)들과 라틴어 단어들이 기본 이탤릭체로 남겨지는 것에 반해, 그것의 
    이탤릭체 텍스트보다 밝은 붉은 텍스트로 스타일 된 강조를 가집니다. 그것은 적절한 요소(element)들을 
    사용하여 문서들의 재스타일링을 쉽게 가능하게 하는 방법을 보여줍니다.

    <pre highlight="html">&lt;!DOCTYPE html&gt;
      &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;My favorite book&lt;/title&gt;
          &lt;style&gt;
            body { color: black; background: white; }
            em { font-style: normal; color: red; }
          &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;p&gt;My &lt;em&gt;favorite&lt;/em&gt; book of all time has &lt;em&gt;got&lt;/em&gt; to be
          &lt;cite&gt;A Cat's Life&lt;/cite&gt;. It is a book by P. Rahmel that talks
          about the &lt;i lang="la"&gt;Felis Catus&lt;/i&gt; in modern human society.&lt;/p&gt;
        &lt;/body&gt;
      &lt;/html&gt;</pre>
  </div>

  <h4 id="interactions-of-styling-and-scripting">스타일링과 스크립팅의 상호작용</h4>

  스타일 시트들은, <{link}> 요소(element)나, <{style}> 요소(element)나, 
  <code>&lt;?xml-stylesheet?&gt;</code> PI나, HTTP <code>Link</code> 헤더나 어떤 다른 메커니즘에 
  의해 추가되었든지 간에, 초기에 해제되어 있는 <dfn lt="style sheet ready">스타일 시트 준비</dfn> 
  플래그를 가집니다.

  스타일 시트가 적용될 준비가 될 경우, 그것의 <a lt="style sheet ready">스타일 시트 준비</a> 
  플래그가 설정됩니다. 스타일 시트가 다른 리소스들을 참조하지 않았다면 (예를 들어, <code>@import</code>
  규칙들 없는 <{style}> 요소(element)에 의해 주어진 내부 스타일 시트였다면), 스타일 규칙들은 
  <a lt="immediately">즉시</a> 스크립트에 사용할 수 있게 되어야(must) 합니다; 그렇지 않으면, 스타일 
  규칙들은 <a lt="event loop">이벤트 반복</a>이 그것의 <i>렌더링 업데이트</i> 단계에 도달할 때에만 
  스크립트에 사용할 수 있게 되어야(must) 합니다.

  <a lt="HTML parser">HTML 해석기</a>나 <a lt="XML parser">XML 해석기</a>의 {{Document}}의 
  컨텍스트에서 스타일 시트는 요소(element)가 그 {{Document}}의 해석기에 의해 생성되었고, 
  요소(element)가 <{style}> 요소(element)나 요소(element)가 해석기에 의해 생성 되었을 때 
  <a href="#link-type-stylesheet">외부 리소스 링크</a>인 <{link}> 요소(element)이고, 요소(element)의 
  스타일 시트가 요소(element)가 해석기에 의해 생성되었을 때 활성화 되었고, 요소(element)의 
  <a lt="style sheet ready">스타일 시트 준비</a> 플래그가 아직 설정되지 않았고, 마지막에 
  <a lt="event loop">이벤트 반복</a>이 단계 1에 도달했을 때 요소(element)가 그 {{Document}}에 있었고 
  유저 에이전트가 아직 그 특정 스타일 시트를 포기하지 않았다면, 
  <dfn lt="a style sheet that is blocking scripts">스크립트들을 차단하는 스타일 시트</dfn>라고 
  알려집니다. 유저 에이전트는 언제든지 스타일 시트를 포기할 수 있습니다.

  <p class="note">
    스타일 시트가 로드되기 전에 스타일 시트를 포기하는 것은, 스타일 시트가 결국 여전히 로드한다면, 
    스크립트가 잘못된 정보를 가지고 작동되는 결과를 초래할 수 있음을 의미합니다. 예를 들어, 스타일 
    시트가 요소(element)의 색상을 녹색으로 설정하지만, 결과 스타일을 검사하는 스크립트는 시트가 
    로드되기 전에 실행된다면, 스크립트는 요소(element)가 검정색임을 (혹은 기본 색상인 어떤 색상) 
    발견하게 될 것이고, 따라서 잘못된 선택을 (예를 들어, 녹색 대신, 페이지의 다른 곳에서 검정색을 
    사용하도록 결정한) 만들 수 있습니다. 구현자는 잘못된 정보를 사용하는 스크립트의 가능성과 느린 
    네트워크 요청이 끝나기를 기다리는 동안 아무 것도 하지 않는 것의 성능 영향을 조정해야(must) 
    합니다.
  </p>

  {{Document}}는 그 {{Document}}의 컨텍스트에서 
  <a lt="a style sheet that is blocking scripts">스크립트들을 차단하는 스타일 시트</a>가 있거나,
  그 {{Document}}가 <a lt="parent browsing context">부모 브라우징 컨텍스트</a>를 가지고 그 
  <a lt="parent browsing context">부모 브라우징 컨텍스트</a>의 <a lt="active document">활성 문서</a>가 
  <a lt="has a style sheet that is blocking scripts">스크립트들을 차단하는 스타일 시트를 가지는</a> 
  <a lt="browsing context">브라우징 컨텍스트</a>에 있다면 
  <dfn lt="have a style sheet that is blocking scripts|has a style sheet that is blocking scripts">스크립트들을 차단하는 스타일 시트를 가집니다</dfn>.

  {{Document}}는 위 단락에서 기술된 바와 같은 
  <a lt="have a style sheet that is blocking scripts">스크립트들을 차단하는 스타일 시트를 가지지</a> 
  않는다면 <dfn lt="has no style sheet that is blocking scripts">스크립트들을 차단하는 스타일 시트를 가지지 않습니다</dfn>.

</section>
